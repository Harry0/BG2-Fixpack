BACKUP ~bg2fixpack/backup~ // location to store files for uninstall purposes
AUTHOR ~webmaster@gibberlings3.net~ // email address displayed if install fails

VERSION ~v9.15~

README ~bg2fixpack/readme-bg2fixpack.html~

ALLOW_MISSING

  //fixpack created files
  ~spin104a.spl~
  ~spwi314a.spl~
  
  // ToB area files
  ~ar3001.are~
  ~ar3003.are~
  ~ar3004.are~
  ~ar3005.are~
  ~ar3006.are~
  ~ar3007.are~
  ~ar3008.are~
  ~ar3009.are~
  ~ar3010.are~
  ~ar3011.are~
  ~ar3012.are~
  ~ar3013.are~
  ~ar3014.are~
  ~ar3016.are~
  ~ar3018.are~
  ~ar3021.are~
  ~ar3022.are~
  ~ar3023.are~
  ~ar4000.are~
  ~ar5000.are~
  ~ar5001.are~
  ~ar5002.are~
  ~ar5003.are~
  ~ar5004.are~
  ~ar5005.are~
  ~ar5006.are~
  ~ar5007.are~
  ~ar5008.are~
  ~ar5009.are~
  ~ar5010.are~
  ~ar5011.are~
  ~ar5012.are~
  ~ar5013.are~
  ~ar5014.are~
  ~ar5015.are~
  ~ar5200.are~
  ~ar5201.are~
  ~ar5202.are~
  ~ar5203.are~
  ~ar5204.are~
  ~ar5501.are~
  ~ar5502.are~
  ~ar5503.are~
  ~ar5504.are~
  ~ar5505.are~
  ~ar5506.are~
  ~ar5507.are~
  ~ar5508.are~
  ~ar5509.are~
  ~ar6000.are~
  ~ar6001.are~
  ~ar6008.are~
  ~ar6011.are~
  ~ar6012.are~
  ~ar6012.are~
  ~ar6100.are~
  ~ar6101.are~
  ~ar6102.are~
  ~ar6103.are~
  ~ar6105.are~
  ~ar6106.are~
  ~ar6107.are~
  ~ar6108.are~
  ~ar6109.are~
  ~ar6110.are~
  ~ar6111.are~
  ~ar6200.are~
  ~ar6300.are~
  ~ar6400.are~
  
  //ToB scripts
  ~ABAZDRAG.BCS~
  ~AESGAR.BCS~
  ~ALARM25.BCS~
  ~amduel1.bcs~
  ~amduel2.bcs~
  ~AMLICH01.BCS~
  ~AMLICH02.BCS~
  ~AR3020.BCS~
  ~AR3021.BCS~
  ~AR3351.BCS~
  ~AR4000.BCS~
  ~BALMONK.BCS~
  ~botsmith.bcs~
  ~CARCH20B.BCS~
  ~CARCH30B.BCS~
  ~CASSA20B.BCS~
  ~CASSA20C.BCS~
  ~CBARB20B.BCS~
  ~CBARD12A.BCS~
  ~CBERS20B.BCS~
  ~CESPEN.BCS~
  ~CFIGH20A.BCS~
  ~CFIGH20B.BCS~
  ~CFIGH30B.BCS~
  ~CFMAG20B.BCS~
  ~chalcy02.bcs~
  ~CHALDIE.BCS~
  ~chaltrol.bcs~
  ~CHALPC01.BCS~
  ~CKENS20B.BCS~
  ~CKENS30B.BCS~
  ~CKMAG20A.BCS~
  ~CKMAG20B.BCS~
  ~CKTHI20B.BCS~
  ~CMACL20A.BCS~
  ~CMAGE20A.BCS~
  ~CMAGE20B.BCS~
  ~CMONK20B.BCS~
  ~ctaltar.bcs~
  ~CTHIE20A.BCS~
  ~CTHIE20B.BCS~
  ~cut207c.bcs~
  ~CUT215A.BCS~
  ~CUT216A.BCS~
  ~DECK622.BCS~
  ~dlich01.bcs~
  ~DRACONIS.BCS~
  ~dragblue.bcs~
  ~DRAGBROW.BCS~
  ~DRAGGRE2.BCS~
  ~DRAGGREE.BCS~
  ~ELTAN.BCS~
  ~FINSOL04.BCS~
  ~FIRLCH01.BCS~
  ~FORCEF.BCS~
  ~FSWHEEL.BCS~
  ~gorbat.bcs~
  ~gorbat1.bcs~
  ~GORCAMB2.BCS~
  ~GORCAMB3.BCS~
  ~GORCAMB4.BCS~
  ~GORCAMB5.BCS~
  ~GORCAMB6.BCS~
  ~GORDECKF.BCS~
  ~GORGOLI.BCS~
  ~gorgua02.bcs~
  ~GORLIC01.BCS~
  ~GORSAL.BCS~
  ~GORSTAM.BCS~
  ~gortan.bcs~
  ~gortan1.bcs~
  ~GPHEALER.BCS~
  ~GPKENSAI.BCS~
  ~GPMAGE1.BCS~
  ~GPMAGE2.BCS~
  ~GPMERC.BCS~
  ~GPTHIEF.BCS~
  ~GRPSHT01.BCS~
  ~hgtrl01.bcs~
  ~ILLASERA.BCS~
  ~ITGLOBES.BCS~
  ~KUOARC20.BCS~
  ~KUOWAR20.BCS~
  ~MAGEHIGH.BCS~
  ~meliss01.bcs~
  ~meliss02.bcs~
  ~meliss03.bcs~
  ~MINDAL01.BCS~
  ~planet.bcs~
  ~salgrfir.bcs~
  ~SARBUL01.BCS~
  ~SARBUL02.BCS~
  ~SARBUL03.BCS~
  ~SARDW01.BCS~
  ~SARDW02.BCS~
  ~SARDW03.BCS~
  ~sarev25.bcs~
  ~sarrein.bcs~
  ~senbattl.bcs~
  ~SENDARK.BCS~
  ~SENGUA04.BCS~
  ~SENGUA05.BCS~
  ~tahazz.bcs~ 
  ~TELTIEF3.BCS~
  ~TELWRAI.BCS~
  ~TIEF3.BCS~
  ~trolic03.bcs~
  ~tomegol4.bcs~
  ~UND5509.BCS~
  ~XEIWIN.BCS~
  ~YAGALT.BCS~
  ~YAGART.BCS~
  ~YSCARA.BCS~
  ~YSGP01.BCS~
  ~YSGP02.BCS~
  ~YSGP03.BCS~
  ~YSGP04.BCS~
  ~YSGRUNT.BCS~
  ~ZILMAG01.BCS~

  // ToB creatures
  ~25spell.cre~
  ~abazigal.cre~
  ~abisred1.cre~
  ~aerie12.cre~
  ~ALUFIE01.CRE~
  ~alufie02.cre~
  ~amarch01.cre~
  ~amarch02.cre~
  ~amasana.cre~
  ~amcapt01.cre~
  ~amcarras.cre~
  ~amcler01.cre~
  ~amcler02.cre~
  ~amcst02.cre~
  ~amcst03.cre~
  ~amcst04.cre~
  ~amduel01.cre~
  ~amduel02.cre~
  ~amduel03.cre~
  ~amelm01.cre~
  ~amfaheed.cre~
  ~amfem01.cre~
  ~amfem02.cre~
  ~amfsleep.cre~
  ~AMGIRL01.CRE~
  ~amlich01.cre~
  ~ammag01.cre~
  ~AMMAJIRA.CRE~
  ~ammayor.cre~
  ~ammerc01.cre~
  ~ammerc02.cre~
  ~ammerc03.cre~
  ~ammerc04.cre~
  ~ammerc07.cre~
  ~ammerc08.cre~
  ~ammerc09.cre~
  ~ammgrd01.cre~
  ~ammgrd02.cre~
  ~ammgrd03.cre~
  ~ammgrd04.cre~
  ~ammgrd05.cre~
  ~ammlegs.cre~
  ~ammonk01.cre~
  ~ammonk02.cre~
  ~ammonk03.cre~
  ~ammonk04.cre~
  ~ammonk05.cre~
  ~ammonk06.cre~
  ~ammonk07.cre~
  ~AMMONK08.CRE~
  ~amsaemon.cre~
  ~amsmith.cre~
  ~amsmug01.cre~
  ~amsmug02.cre~
  ~amtarc01.cre~
  ~amtcap01.cre~
  ~amtcle01.cre~
  ~amtcler0.cre~
  ~amtgen01.cre~
  ~amtmag01.cre~
  ~anomen12.cre~
  ~army01.cre~
  ~argrim.cre~
  ~balelite.cre~
  ~balor01.cre~
  ~balth.cre~
  ~bazdra01.cre~
  ~bazdra02.cre~
  ~bazdra03.cre~
  ~bazeye01.cre~
  ~bazeye02.cre~
  ~bazliz01.cre~
  ~bazliz02.cre~
  ~bazliz03.cre~
  ~bazliz04.cre~
  ~bazmonk.cre~
  ~bazpat01.cre~
  ~bazpat02.cre~
  ~bazpat03.cre~
  ~BEHHIV01.CRE~
  ~bhaal01.cre~
  ~bonebld.cre~
  ~cernd14.cre~
  ~chalcy01.cre~
  ~chalcy02.cre~
  ~chaldt01.cre~
  ~chalin01.cre~
  ~chalpc01.cre~
  ~chalpc02.cre~
  ~chalpc03.cre~
  ~chalpc04.cre~
  ~chalpc05.cre~
  ~chalpc06.cre~
  ~chalpc07.cre~
  ~chalpc08.cre~
  ~chalpc09.cre~
  ~chalpc10.cre~
  ~chalpc11.cre~
  ~chalpc12.cre~
  ~chalpc13.cre~
  ~chalpc14.cre~
  ~chalpc15.cre~
  ~chalpc16.cre~
  ~chalrv01.cre~
  ~chalslay.cre~
  ~chang01.cre~
  ~chang02.cre~
  ~chevil01.cre~
  ~chevil02.cre~
  ~chevil03.cre~
  ~chevil04.cre~
  ~chevil05.cre~
  ~chevil06.cre~
  ~chevil07.cre~
  ~chevil08.cre~
  ~chevil09.cre~
  ~chevil10.cre~
  ~chgood01.cre~
  ~chgood04.cre~
  ~chgood05.cre~
  ~chgood06.cre~
  ~chgood07.cre~
  ~chgood08.cre~
  ~chgood09.cre~
  ~chsam01.cre~
  ~chsam02.cre~
  ~chtaz01.cre~
  ~chtaz02.cre~
  ~cutamfig.cre~
  ~cutamgrd.cre~
  ~cutammag.cre~
  ~cutbalth.cre~
  ~cutgrd01.cre~
  ~cutgrd02.cre~
  ~cutgrd03.cre~
  ~cutgrd04.cre~
  ~cutmelis.cre~
  ~D1GHOST.CRE~
  ~D1GORI.CRE~  
  ~D1MOTHDW.CRE~
  ~D1MOTHEL.CRE~
  ~D1MOTHHA.CRE~
  ~D1MOTHHU.CRE~
  ~d1sarev.cre~
  ~d1skel.cre~
  ~dbonef01.cre~
  ~DEADCOW1.CRE~
  ~DEADCOW2.CRE~
  ~DEADDEM1.CRE~
  ~deaddem2.cre~
  ~DEATHKNI.CRE~
  ~DECK615.CRE~
  ~deck622.cre~
  ~deckass1.cre~
  ~deckwar1.cre~
  ~dedsmug.cre~
  ~DEMABI01.CRE~
  ~DEMCOR01.CRE~
  ~demgla01.cre~
  ~demglab.cre~
  ~demglab2.cre~
  ~demglasu.cre~
  ~demilich.CRE~
  ~demoarch.cre~
  ~democler.cre~
  ~demogor1.cre~
  ~demogor2.cre~
  ~DEMOSUM1.CRE~
  ~DEMOSUM2.CRE~
  ~DEMOSUM3.CRE~
  ~DEMOSUM4.CRE~
  ~demsuc01.cre~
  ~deriny01.cre~
  ~devaevil.cre~
  ~devagood.cre~
  ~devast01.cre~
  ~devmon01.cre~
  ~dimp01.cre~
  ~dglab01.cre~
  ~DPFEMALE.CRE~
  ~dpmale.cre~
  ~DPSTAT05.CRE~
  ~dquas01.cre~
  ~dragblue.cre~
  ~dragbrow.cre~
  ~dragpurp.cre~
  ~dragyell.cre~
  ~dreampc.cre~
  ~drofod01.cre~
  ~drofod02.cre~
  ~drofod03.cre~
  ~drofod04.cre~
  ~DRUEAR01.CRE~
  ~drufir01.cre~
  ~ecolt.cre~
  ~edwin15.cre~
  ~ELEMchan.cre~
  ~elemcryo.cre~
  ~elemhydr.cre~
  ~elemimix.cre~
  ~elemogre.cre~
  ~elemsunn.cre~
  ~elemyanc.cre~
  ~elemzaam.cre~
  ~enddem01.cre~
  ~enddem02.cre~
  ~EYEEGL01.CRE~
  ~EYEGOR01.CRE~
  ~EYEDED01.CRE~
  ~EYESEK01.CRE~
  ~EYESNT01.CRE~
  ~EYEVIG01.CRE~
  ~famcat25.cre~
  ~famdus25.cre~
  ~famfai25.CRE~
  ~famfer25.CRE~
  ~famimp25.cre~ 
  ~fampsd25.CRE~
  ~famqua25.cre~
  ~famrab25.cre~
  ~fangel01.cre~
  ~finmel01.cre~
  ~finsol01.cre~
  ~finsol02.cre~
  ~finsol03.cre~
  ~finsol04.cre~
  ~firlch01.cre~
  ~fsdragon.cre~
  ~fsghos.cre~
  ~fsghos2.cre~
  ~FSGIBB.CRE~
  ~fsglob.cre~
  ~FSGOBL.CRE~
  ~fshorde2.cre~
  ~fshorde4.cre~
  ~fshorde5.cre~
  ~fshorde6.cre~
  ~FSMAGE01.CRE~
  ~FSMAGE02.CRE~
  ~FSMAGE03.CRE~
  ~fsmage04.cre~
  ~fsridd.cre~
  ~FSSKEL.CRE~
  ~fsspir1.cre~
  ~fsspir2.cre~
  ~fsspir3.cre~
  ~fsspira.cre~
  ~fsspirb.cre~
  ~fsspirc.cre~
  ~garock.cre~
  ~GIAFIR01.CRE~
  ~GORAIR01.CRE~
  ~gorair02.cre~
  ~golbon01.cre~
  ~golice01.cre~
  ~golmag01.cre~
  ~GORAPR.CRE~
  ~gorarc.cre~
  ~gorbat1.cre~
  ~gorbat2.cre~
  ~gorbat3.cre~
  ~gorbat4.cre~
  ~gorbat5.cre~
  ~gorbel.cre~
  ~gorcamb.cre~
  ~gorcamb2.cre~
  ~gorcamb3.cre~
  ~gorcamb4.cre~
  ~gorcamb5.cre~
  ~gorcamb6.cre~
  ~gorcamb7.cre~
  ~gorcar.cre~
  ~GORCHR.CRE~
  ~gordeck1.cre~
  ~gordeck2.cre~
  ~gordeck3.cre~
  ~gordeck4.cre~
  ~gordeck5.cre~
  ~gordeck6.cre~
  ~gordeck7.cre~
  ~gordeck8.cre~
  ~gordeck9.cre~
  ~gordecka.cre~
  ~gordeckf.cre~
  ~gordem.cre~
  ~gordem2.cre~
  ~gordemc1.cre~
  ~gorfirg.cre~
  ~gorgit.cre~
  ~gorgitc1.cre~
  ~gorgitc2.cre~
  ~gorgitc3.cre~
  ~gorgitc4.cre~
  ~gorgith2.cre~
  ~gorgua01.cre~
  ~gorgua02.cre~
  ~gorgua03.cre~
  ~gorgua04.cre~
  ~gorgua05.cre~
  ~gorimp01.cre~
  ~gorjelf2.cre~
  ~gorjelfu.cre~
  ~gorjelgr.cre~
  ~gorkuo01.cre~
  ~gorkuo02.cre~
  ~gorkuo03.cre~
  ~gorkuo04.cre~
  ~gorkuo05.cre~
  ~gorlic01.cre~
  ~gorlum.cre~
  ~gormad1.cre~
  ~GORMIM01.CRE~
  ~GORMIM02.CRE~
  ~GORMIM03.CRE~
  ~GORMIM04.CRE~
  ~GORMIND.CRE~
  ~gormisti.cre~
  ~gormistp.cre~
  ~gororc01.cre~
  ~gororc02.cre~
  ~gororc03.cre~
  ~gorpri1.cre~
  ~gorsal.cre~
  ~gorsku01.cre~
  ~gorsnake.cre~
  ~gorsta01.cre~
  ~gorsta02.cre~
  ~gorsta03.cre~
  ~gorsta04.cre~
  ~gorsta05.cre~
  ~gorsta06.cre~
  ~gorsta07.cre~
  ~gorsta08.cre~
  ~gorsta09.cre~
  ~gorsta10.cre~
  ~gorsta11.cre~
  ~gorsta12.cre~
  ~gorstalk.cre~
  ~gorsuc01.cre~
  ~gortan1.cre~
  ~gortan2.cre~
  ~gortan3.cre~
  ~gortan4.cre~
  ~gortan5.cre~
  ~gortan6.cre~
  ~gortor1.cre~
  ~gortor2.cre~
  ~gortor3.cre~
  ~gortor4.cre~
  ~gortor5.cre~
  ~gortor6.cre~
  ~gorwom01.cre~
  ~gorwom02.cre~
  ~gorwom03.cre~
  ~gorwom04.cre~
  ~gorwom05.cre~
  ~gorwom06.cre~
  ~gromg01.cre~
  ~gromg02.cre~
  ~gromg03.cre~
  ~gromg04.cre~
  ~gromg05.cre~
  ~gromg06.cre~
  ~gromg07.cre~
  ~gromg08.cre~
  ~gromg09.cre~
  ~gromg10.cre~
  ~gromg11.cre~
  ~gromg12.cre~
  ~gromg13.cre~
  ~gromg14.cre~
  ~gromnir.cre~
  ~haer19.cre~
  ~HGBER01.CRE~
  ~hgfel01.cre~
  ~hgkar01.cre~
  ~hgmag01.cre~
  ~hgmag02.cre~
  ~hgmis01.cre~
  ~hgmis02.cre~
  ~hgmnd2.cre~
  ~hgmound.cre~
  ~hgnya01.cre~
  ~hgnymph.cre~
  ~hgsal01.cre~
  ~hgskl01.cre~
  ~hgskl02.cre~
  ~hgskl03.cre~
  ~hgskl04.cre~
  ~hgsku01.cre~
  ~hgslv01.cre~
  ~hgtrl01.cre~
  ~hgwar02.cre~
  ~hgwra01.cre~
  ~hgwra02.cre~
  ~hgwra03.cre~
  ~icyuan04.cre~
  ~icyuan05.cre~
  ~illasera.cre~
  ~imoen15.cre~
  ~inp1ivsg.bcs~
  ~jahei14.cre~
  ~jan15.cre~
  ~jondem01.cre~
  ~jondem03.cre~
  ~jondem05.cre~
  ~keldor14.cre~
  ~killmonk.cre~
  ~kobswi01.cre~
  ~korgan15.cre~
  ~kuoarc20.cre~
  ~kuocle20.cre~
  ~kuowar20.cre~
  ~lichel01.cre~
  ~lout.cre~
  ~loveone1.cre~
  ~loveone2.cre~
  ~loveone3.cre~
  ~loveone4.cre~
  ~loveone5.cre~
  ~magcle20.cre~
  ~magetest.cre~
  ~malla01.cre~
  ~malla02.cre~
  ~mazzy15.cre~
  ~mddust.cre~
  ~MDEARTH.CRE~
  ~MDEARTH2.CRE~
  ~mdrak.cre~
  ~mel01.cre~
  ~meliss01.cre~
  ~melsum01.cre~
  ~melsum02.cre~
  ~melsum04.cre~
  ~melsum05.cre~
  ~melsum06.cre~
  ~mindva01.cre~
  ~mugger4.cre~
  ~nalia18.cre~
  ~pheas01.cre~
  ~PLANET01.CRE~
  ~planevil.cre~
  ~plangood.cre~
  ~planwish.cre~
  ~plshhg02.cre~
  ~PPGUY01.CRE~
  ~pudden01.cre~
  ~pudden02.cre~
  ~rabbit.cre~
  ~rock.cre~
  ~salgrfir.cre~
  ~salgrice.cre~
  ~saralegs.cre~
  ~sarbar01.cre~
  ~sarbar02.cre~
  ~sarbha01.cre~
  ~sarbha02.cre~
  ~sarbul01.cre~
  ~sarbul02.cre~
  ~sarbul03.cre~
  ~sarbul04.cre~
  ~sarbul05.cre~
  ~sarbul06.cre~
  ~sarbul07.cre~
  ~sarcpt01.cre~
  ~sarcult.cre~
  ~sarcult2.cre~
  ~sarculto.cre~
  ~SARDW01.CRE~
  ~sardw02.cre~
  ~sardw03.cre~
  ~sardw04.cre~
  ~sardw05.cre~
  ~sarelf01.cre~
  ~sarelf02.cre~
  ~sarelf03.cre~
  ~sarelf04.cre~
  ~sarelf05.cre~
  ~sarelf06.cre~
  ~sarevok.cre~
  ~sarevokg.cre~
  ~SARFAKI2.CRE~
  ~SARFAKIE.CRE~
  ~sargrd01.cre~
  ~sargrd02.cre~
  ~sargrd03.cre~
  ~sargrd04.cre~
  ~sargrd05.cre~
  ~sargrd06.cre~
  ~sargrd07.cre~
  ~sargrd08.cre~
  ~sargrd09.cre~
  ~sargrd10.cre~
  ~sargrd11.cre~
  ~sargrd12.cre~
  ~sargrd13.cre~
  ~sargrd14.cre~
  ~sargrd15.cre~
  ~sargrd16.cre~
  ~sarhal.cre~
  ~saripg01.cre~
  ~saripg02.cre~
  ~saripg03.cre~
  ~saripg04.cre~
  ~sarjai01.cre~
  ~sarkis01.cre~
  ~sarkis02.cre~
  ~sarkis03.cre~
  ~sarkis04.cre~
  ~sarmag01.cre~
  ~sarmat01.cre~
  ~sarmil01.cre~
  ~sarmil02.cre~
  ~sarmist.cre~
  ~sarorc01.cre~
  ~saroro01.cre~
  ~sarpro01.cre~
  ~sarprovf.cre~
  ~sarprovm.cre~
  ~sarrein1.cre~
  ~sarrein2.cre~
  ~sarson01.cre~
  ~sarspir.cre~
  ~SARTEM01.CRE~
  ~sarthf01.cre~
  ~sarthf02.cre~
  ~sartro01.cre~
  ~sartro02.cre~
  ~sartro03.cre~
  ~sarvam01.cre~
  ~sarvam02.cre~
  ~sarvam03.cre~
  ~sarvie01.cre~
  ~sarvolo.cre~
  ~SENANI01.CRE~
  ~SENANI02.CRE~
  ~SENANI03.CRE~
  ~senani04.cre~
  ~senani05.cre~
  ~sendai.cre~
  ~sendai2.cre~
  ~sendai3.cre~
  ~sendai4.cre~
  ~sendai5.cre~
  ~sendai6.cre~
  ~sendai7.cre~
  ~sendai8.cre~
  ~sendark.CRE~
  ~sendro01.cre~
  ~sendro02.cre~
  ~sendro03.cre~
  ~sendro04.cre~
  ~sendro05.cre~
  ~senfod01.cre~
  ~senfod02.cre~
  ~sengua01.cre~
  ~sengua02.cre~
  ~sengua03.cre~
  ~sengua04.cre~
  ~sengua05.cre~
  ~senken01.cre~
  ~senlich.cre~
  ~senmonk.cre~
  ~senorc01.cre~
  ~senorc02.cre~
  ~senorc03.cre~
  ~senorc04.cre~
  ~senpri01.cre~
  ~sensmsp2.cre~
  ~senstalk.cre~
  ~sewarc01.cre~
  ~sewarc02.cre~
  ~sewdue01.cre~
  ~sewdue02.cre~
  ~seworo01.cre~
  ~sewsha01.cre~
  ~sewsha02.cre~
  ~sewsha03.cre~
  ~sewyag01.cre~
  ~sewyag02.cre~
  ~sewyag03.cre~
  ~sewyag04.cre~
  ~shadfi02.cre~
  ~shugar01.cre~
  ~shugfg01.cre~
  ~shugho01.cre~
  ~shugmg01.cre~
  ~shugod01.cre~
  ~shugod02.cre~
  ~shugpr01.cre~
  ~shupol01.cre~
  ~skelar01.cre~
  ~skelar02.cre~
  ~slaysh01.cre~
  ~slifis02.cre~
  ~smspid02.cre~
  ~solar.cre~
  ~solar01.cre~
  ~spellh01.cre~
  ~spidvo01.cre~
  ~squirl.cre~
  ~squirr.cre~
  ~SWAAIR01.CRE~
  ~SWAAIR02.CRE~
  ~SWAEAR01.CRE~
  ~SWAEAR02.CRE~
  ~SWAFIR01.CRE~
  ~SWAAIR01.CRE~
  ~TELBAL1.CRE~
  ~telbal2.cre~
  ~telcam1.cre~
  ~telcor1.cre~
  ~telelfir.cre~
  ~telicesa.cre~
  ~telimp1.cre~
  ~TELPIT1.CRE~
  ~TELPIT2.CRE~
  ~TELSLAV.CRE~
  ~telsuc1.cre~
  ~telqua1.cre~
  ~telqua2.cre~
  ~TELTAN1.CRE~
  ~TELTAN2.CRE~
  ~teltief1.cre~
  ~teltief2.cre~
  ~teltief3.cre~
  ~telwrai.cre~
  ~tobban01.cre~
  ~tobban02.cre~
  ~tobban03.cre~
  ~tobban04.cre~
  ~tobpar01.cre~
  ~tobpar02.cre~
  ~tobpar03.cre~
  ~tobpar04.cre~
  ~tobpar05.cre~
  ~tobpar06.cre~
  ~tomegol1.cre~
  ~tomegol2.cre~
  ~tomegol3.cre~
  ~tomegol4.cre~
  ~trolic03.cre~
  ~trolic04.cre~
  ~turn.CRE~
  ~valyg14.cre~
  ~viconi16.cre~
  ~victown1.cre~
  ~victown2.cre~
  ~victown3.cre~
  ~wauksqu.cre~
  ~weregrdr.cre~
  ~werewyv1.cre~
  ~werewyv2.cre~
  ~wish01.cre~
  ~wish02.cre~
  ~wpwench1.cre~
  ~yaga01.cre~
  ~yaga02.cre~
  ~yaga03.cre~
  ~yaga04.cre~
  ~yaga05.cre~
  ~yagaspir.cre~
  ~yarmy01.cre~
  ~yarmy02.cre~
  ~yarmy03.cre~
  ~yscara01.cre~
  ~yscara02.cre~
  ~yscara03.cre~
  ~yscara05.cre~
  ~ysfire01.cre~
  ~ysfire02.cre~
  ~ysg2.cre~
  ~ysgp01.cre~
  ~ysgp02.cre~
  ~ysgp03.cre~
  ~ysgp04.cre~
  ~ysgp05.cre~
  ~ysgrunt.cre~
  ~ysguar01.cre~
  ~ysguar02.cre~
  ~ysguar03.cre~
  ~ysguar04.cre~
  ~ysguar05.cre~
  ~ysguar06.cre~
  ~ysmage01.cre~
  ~ysmage02.cre~
  ~yssold01.cre~
  ~yssold02.cre~
  ~yssold03.cre~
  ~yssold04.cre~
  ~yssold10.cre~
  ~yssold12.cre~
  ~yssold13.cre~
  ~yssold14.cre~
  ~yssold15.cre~
  ~yssold16.cre~
  ~zilarc01.cre~
  ~zilfgt01.cre~
  ~zilfgt02.cre~
  ~zilmag01.cre~
  
  // ToB items
  ~aeriebab.itm~
  ~ABAZRING.ITM~
  ~amul27.itm~
  ~amul28.itm~
  ~aurstaf.itm~
  ~ax1h16.itm~
  ~BAZPATRG.ITM~
  ~BHAALHP1.ITM~
  ~BHAALIMM.ITM~
  ~blun26.itm~
  ~blun27.itm~
  ~blun30.itm~
  ~blun31.itm~
  ~bolt09.itm~
  ~bonedag.itm~
  ~boot12.itm~
  ~bow20.itm~
  ~bow21.itm~
  ~bow22.itm~
  ~bow23.itm~
  ~bow24.itm~
  ~bow25.itm~
  ~bow26.itm~
  ~brac21.itm~
  ~brdflute.itm~
  ~bull05.itm~
  ~bull06.itm~
  ~chains.itm~
  ~chalcy2.itm~
  ~chalcy3.itm~
  ~CHALSLAY.ITM~
  ~chan20.itm~
  ~chan21.itm~
  ~dart08.itm~
  ~dartmel.itm~
  ~DEMOGORG.ITM~
  ~DEMSUC01.ITM~
  ~DEVA.ITM~
  ~devaevil.itm~
  ~druear.itm~
  ~drufir.itm~
  ~elemchan.itm~
  ~elemcryo.itm~
  ~elemhydr.itm~
  ~elemimix.itm~
  ~elemogre.itm~
  ~elemprin.itm~
  ~elemsunn.itm~
  ~elemyanc.itm~
  ~elemzaam.itm~
  ~eneblade.itm~
  ~famcat25.ITM~
  ~FAMDUS25.ITM~
  ~FAMFAI25.ITM~
  ~FAMFER25.ITM~
  ~FAMIMP25.ITM~
  ~FAMPSD25.ITM~
  ~FAMQUA25.ITM~
  ~FAMRAB25.ITM~
  ~FINMEL01.ITM~
  ~FSSPIR.ITM~
  ~GIAFIR.ITM~
  ~GIAFIR2.ITM~
  ~GIAFIR3.ITM~
  ~globblu1.itm~
  ~globblu3.itm~
  ~globgre1.itm~
  ~globpur3.itm~
  ~globred1.itm~
  ~globred2.itm~
  ~globred4.itm~
  ~golmag01.itm~
  ~gorcamb.itm~
  ~GORCHR.ITM~
  ~GORFIRG.ITM~
  ~GORJELFU.ITM~
  ~GORJELGR.ITM~
  ~GORMISTI.ITM~
  ~gormistp.itm~
  ~gorwom1.itm~
  ~gorwom2.itm~
  ~gorwom4.itm~
  ~HAMM10.ITM~
  ~HAMM11.ITM~
  ~helm30.itm~
  ~helm34.itm~
  ~hgber01.itm~
  ~hgnya01.itm~
  ~HGNYMPH.ITM~
  ~hgwra01.itm~
  ~hgwra02.itm~
  ~HOLDRING.ITM~
  ~icetrl.itm~
  ~impclaw.itm~
  ~INNOC.ITM~
  ~INNOC2.ITM~
  ~INVULNER.ITM~
  ~JWSUPER.ITM~
  ~kuobolt2.itm~
  ~kuobolt3.itm~
  ~leat24.itm~
  ~MEL01.ITM~
  ~mistice.itm~
  ~mistva2.itm~
  ~mound.itm~
  ~planetar.itm~
  ~plat20.itm~
  ~plat22.itm~
  ~plat23.itm~
  ~plot02a.itm~
  ~plot02b.itm~
  ~plot02c.itm~
  ~plot02d.itm~
  ~plot02e.itm~
  ~plot03a.itm~
  ~plot03b.itm~
  ~plot03c.itm~
  ~plot03d.itm~
  ~plot04i.itm~
  ~plot05a.itm~
  ~plot05b.itm~
  ~plot05c.itm~
  ~plot05d.itm~
  ~potn55.itm~
  ~potn56.itm~
  ~psdclaw.itm~
  ~quasclaw.itm~
  ~quiv01.itm~
  ~quiver01.itm~
  ~quiver02.itm~
  ~quiver03.itm~
  ~quiver04.itm~
  ~quiver05.itm~
  ~quiver06.itm~
  ~ravag01.itm~
  ~ravag02.itm~
  ~RAVAG03.ITM~
  ~ring46.itm~
  ~rods06.itm~
  ~sarbone.itm~
  ~sarskel.itm~
  ~sarskul.itm~
  ~scrlb4.itm~
  ~secret01.itm~
  ~secret02.itm~
  ~secret03.itm~
  ~secret04.itm~
  ~sendai.itm~
  ~SENGUA04.ITM~
  ~shakti1.itm~
  ~shararm.itm~
  ~slaysh01.ITM~
  ~spellh01.itm~
  ~sper11.itm~
  ~sper12.itm~
  ~spermel.itm~
  ~staf22.itm~
  ~stonring.ITM~
  ~SUREHP1.ITM~
  ~sw1h58.itm~
  ~sw1h59.itm~
  ~SW1H61.ITM~
  ~sw1h62.itm~
  ~sw1h63.itm~
  ~sw1h64.itm~
  ~sw1h65.itm~
  ~sw1h66.itm~
  ~SW1H69.ITM~
  ~sw1h71.itm~
  ~sw2h19.itm~
  ~sw2h21.itm~
  ~TELSLAV.ITM~
  ~TELSLAV2.ITM~
  ~umber02.itm~
  ~wand18.itm~
  ~wand19.itm~
  ~xbow15.itm~
  ~xbow16.itm~
  ~xbow17.itm~

  // ToB spells
  ~abzaway.spl~
  ~BALSHLD.SPL~
  ~balth01.spl~
  ~balth01a.spl~
  ~balth02.spl~
  ~BALTH03.SPL~
  ~BALTH05.SPL~
  ~balth10.spl~
  ~beguile.spl~
  ~BHAAL1b.SPL~
  ~bhaal2a.spl~
  ~BHAAL3A.SPL~
  ~BHAAL4A.SPL~
  ~BHAAL4B.SPL~
  ~CH3DRAIN.SPL~
  ~demochm.spl~
  ~dgarchon.spl~
  ~dgfaith.spl~
  ~dgright.spl~
  ~DRGRBRHT.SPL~
  ~JWFALL.SPL~
  ~jwglobe.SPL~
  ~JWONEHIT.SPL~
  ~JWSP02.SPL~
  ~LICHTEL.SPL~
  ~melis02.spl~
  ~SAREVEFF.SPL~
  ~senbehkd.spl~
  ~SENSPISU.SPL~
  ~spcl233b.spl~
  ~spcl900.spl~
  ~spcl901.spl~
  ~spcl902.spl~
  ~spcl903.spl~
  ~spcl904.spl~
  ~spcl905.spl~
  ~spcl906.spl~
  ~spcl907.spl~
  ~spcl909.spl~
  ~spcl910.spl~
  ~spcl910b.spl~
  ~spcl911.spl~
  ~spcl911b.spl~
  ~spcl912.spl~
  ~spcl912b.spl~
  ~spcl913.spl~
  ~spcl914.spl~
  ~spcl915.spl~
  ~spcl916.spl~
  ~spcl917.spl~
  ~spcl918.spl~
  ~spcl919.spl~
  ~spcl920.spl~
  ~spcl920a.spl~
  ~spcl921.spl~
  ~spcl921a.spl~
  ~spcl922.spl~
  ~spcl923.spl~
  ~spcl924.spl~
  ~spcl928.spl~
  ~spcl929.spl~
  ~spcl930.spl~
  ~spin529.spl~
  ~spin530.spl~
  ~spin531.spl~
  ~spin532.spl~
  ~spin534.spl~
  ~spin540.spl~
  ~spin544.spl~
  ~spin550.spl~
  ~spin553.spl~
  ~spin554.spl~
  ~spin555.spl~
  ~spin556.spl~
  ~spin557.spl~
  ~spin558.spl~
  ~spin571.spl~
  ~spin575.spl~
  ~spin576.spl~
  ~spin579.spl~
  ~spin580.spl~
  ~spin581.spl~
  ~spin582.spl~
  ~spin583.spl~
  ~spin584.spl~
  ~spin585.spl~
  ~spin586.spl~
  ~spin587.spl~
  ~spin588.spl~
  ~spin589.spl~
  ~spin590.spl~
  ~spin591.spl~
  ~spin594.spl~
  ~spin595.spl~
  ~spin596.spl~
  ~spin607.spl~
  ~spin611.spl~
  ~spin612.spl~
  ~spin613.spl~
  ~spin615.spl~
  ~spin616.spl~
  ~spin618.spl~
  ~spin626.spl~
  ~spin632.spl~
  ~spin640.spl~
  ~spin641.spl~
  ~spin644.spl~
  ~spin646.spl~
  ~spin647.spl~
  ~spin648.spl~
  ~spin649.spl~
  ~spinhum.spl~
  ~spmdslay.spl~
  ~sppr722.spl~
  ~sppr723.spl~
  ~sppr724.spl~
  ~sppr725.spl~
  ~sppr729.spl~
  ~sppr730.spl~
  ~sppr731.spl~
  ~sppr732.spl~
  ~spwi222.spl~
  ~spwi723.spl~
  ~spwi818.spl~
  ~spwi918.spl~
  ~spwi921.spl~
  ~spwi922.spl~
  ~spwi925.spl~
  ~spwish07.spl~
  ~spwish10.spl~
  ~spwish11.spl~
  ~spwish12.spl~
  ~spwish13.spl~
  ~spwish14.spl~
  ~spwish16.spl~
  ~spwish17.spl~
  ~spwish25.spl~
  ~spwish30.spl~
  ~spwish46.spl~
  ~spwm109.spl~
  ~spwm183.spl~
  ~urgekill.spl~

  // ToB stores
  ~25spell2.sto~
  ~amsmug01.sto~
  ~amsmug02.sto~
  ~bag20.sto~
  ~bag21.sto~
  ~bag22.sto~
  ~bag23.sto~
  ~bag24.sto~
  ~bag25.sto~
  ~bag26.sto~
  ~bag27.sto~
  ~bag28.sto~
  ~bag29.sto~
  ~bag30.sto~
  ~garlena.sto~
  ~hgkar01.sto~
  ~sartem01.sto~

  // ToB miscellany
  ~SPCL906B.EFF~

LANGUAGE ~English~                                ~english~ ~bg2fixpack/english/setup.tra~
LANGUAGE ~Polski (by yarpen)~                     ~polski~  ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/polish/setup.tra~
LANGUAGE ~Espanol (by Immortality and Clan DLAN)~ ~spanish~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/spanish/setup.tra~
LANGUAGE ~Deutsch (by Leonardo Watson)~           ~german~  ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/german/setup.tra~
LANGUAGE ~Francais (by Anomaly)~                  ~french~  ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/french/setup.tra~
LANGUAGE ~Korean (by Web2Air)~                    ~korean~  ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/korean/setup.tra~
LANGUAGE ~Italian (by Andrea C.)~                 ~italian~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/italian/setup.tra~
LANGUAGE ~Russian (by Fess)~                      ~russian~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/russian/setup.tra~
LANGUAGE ~Japanese (by Taro)~                    ~japanese~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/japanese/setup.tra~
LANGUAGE ~Traditional Chinese (by good0593)~     ~tchinese~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/tchinese/setup.tra~
LANGUAGE ~Simplified Chinese (by good0593)~      ~schinese~ ~bg2fixpack/english/setup.tra~
                                                            ~bg2fixpack/schinese/setup.tra~

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Begin core component                             \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @0 DESIGNATED 0 // Core Fixes

// os x "can't save" bug
ACTION_IF ~%WEIDU_OS%~ STRING_EQUAL_CASE ~osx~ THEN BEGIN
<<<<<<<< fix-temp
#!/bin/sh
test -f temp && (rm -f temp && mkdir temp)
>>>>>>>>
  COPY ~fix-temp~ ~fix-temp~
  AT_NOW ~sh fix-temp~
END

// allows us to regexp match tabs and newlines
INCLUDE ~bg2fixpack/lib/extra_regexp_vars.tph~

/////                                                  \\\\\
///// string fixes                                     \\\\\
/////                                                  \\\\\

STRING_SET  6709 @140 // weight of regular mace
STRING_SET  8857 @100 // Viconia's non-sequitir line
STRING_SET  8863 @101 // Viconia's non-sequitir line
STRING_SET 14320 @141 // symbol fear descript (1 round per 3 levels, not 2 rounds)
STRING_SET 17890 @127 // [VALYGA01] sound restoration
STRING_SET 25201 @137 // Berserker enrage missing protection list
STRING_SET 26315 @136 // spellstrike descript
STRING_SET 35168 @132 // [HAERDA95] sound restoration
STRING_SET 36460 @139 // flail +2 damage
STRING_SET 37155 @133 // [JANJAN67] sound restoration
// STRING_SET 39798 @107 // captain arat
STRING_SET 45869 @138 // Barbarian rage missing protection list
STRING_SET 58250 @134 // [ELLESI02] sound restoration
STRING_SET 60724 @112 // adalon soundset restoration
STRING_SET 60741 @113 // adalon soundset restoration

ACTION_IF ("%LANGUAGE%" STRING_COMPARE_CASE "korean") THEN BEGIN // no korean translation for these strings

  STRING_SET   176 @146 // speed factor of +2 long bow
  STRING_SET   199 @147 // speed factor of +2 short bow
  STRING_SET  1768 @148 // weight of plate mail
  STRING_SET  2494 @149 // speed factor of spear of withering
  STRING_SET  4330 @150 // [IMOEN20] sound fix
  STRING_SET  4421 @151 // sword of flame +1 speed factor fix
  STRING_SET  4432 @168 // soa dust mephit familiar item description
  STRING_SET  4433 @170 // soa fairy dragon familiar item description
  STRING_SET  4434 @162 // soa ferret familiar item description
  STRING_SET  4435 @164 // soa imp familiar item description
  STRING_SET  4436 @174 // soa quasit familiar item description
  STRING_SET  4437 @160 // soa pseudo-dragon familiar item description
  STRING_SET  4438 @166 // soa rabbit familiar item description
  STRING_SET  5962 @152 // sound resref fix
  STRING_SET  8064 @155 // globe of invulnerability descript
  STRING_SET 11848 @153 // wrong save v. death penalty for claw of kazgaroth
  STRING_SET 12146 @154 // minor globe of invulnerability descript
  STRING_SET 25894 @156 // teleport field has no saving throw
  STRING_SET 41385 @172 // soa cat familiar item description
  STRING_SET 45889 @159 // find familiar spell descript
  
  //Description fixes for item weight, speed factor and other things (Wisp)
  //NB. This will need to be moved based on what translations we get (as will the corresponding ToB part)
  STRING_SET  1764 @209   
              8505 @191
             19359 @177
             21957 @210
             32186 @211
             32187 @212
             34732 @190
             39461 @213
             39511 @179
             39531 @189
             39579 @183
             39626 @196
             39627 @197
             39629 @198
             39631 @199
             39632 @200
             39633 @201
             39634 @202
             41389 @185
             41620 @186
             41621 @187
             47131 @182
             48658 @206
             51884 @204
             51947 @192
             51949 @193
             54340 @180
             57897 @181
             61580 @184
             61593 @208

END

ACTION_IF (FILE_EXISTS_IN_GAME ~mel01.cre~) AND ("%LANGUAGE%" STRING_COMPARE_CASE "korean") THEN BEGIN // tob strings, no korean trans

  STRING_SET 72757 @173 // tob cat familiar item description
  STRING_SET 72760 @169 // tob dust mephit familiar item description
  STRING_SET 72762 @171 // tob fairy dragon familiar item description
  STRING_SET 72763 @163 // tob ferret familiar item description
  STRING_SET 72764 @165 // tob imp familiar item description
  STRING_SET 72765 @161 // tob pseudo-dragon familiar item description
  STRING_SET 72766 @175 // tob quasit familiar item description
  STRING_SET 72767 @167 // tob rabbit familiar item description
  
  //Description fixes for item weight and speed factor (Wisp)
  STRING_SET 66203 @205
             66369 @203
             66372 @194
             66474 @195
             70785 @207
             71058 @188
             71131 @176
             73912 @178
  
END

/////                                                  \\\\\
///// ids fixes                                        \\\\\
/////                                                  \\\\\

// add ToB scripting actions/triggers to SoA; done as a library in case other mods want to nab it
INCLUDE ~bg2fixpack/lib/tob2soa.tph~

// imprisoned summon fix: see cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
APPEND ~gender.ids~ ~66 IMPRISONED_SUMMONED~ UNLESS ~^66 ~

// fixing kit.ids; creature corrections are down in the creature section
COPY_EXISTING ~kit.ids~ ~override~
  REPLACE_TEXTUALLY ~.*\bTRUECLASS\b~              ~0x4000 TRUECLASS~
  REPLACE_TEXTUALLY ~.*\bBERSERKER\b~              ~0x4001 BERSERKER~
  REPLACE_TEXTUALLY ~.*\bWIZARDSLAYER\b~           ~0x4002 WIZARDSLAYER~
  REPLACE_TEXTUALLY ~.*\bKENSAI\b~                 ~0x4003 KENSAI~
  REPLACE_TEXTUALLY ~.*\bCAVALIER\b~               ~0x4004 CAVALIER~
  REPLACE_TEXTUALLY ~.*\bINQUISITOR\b~             ~0x4005 INQUISITOR~
  REPLACE_TEXTUALLY ~.*\bUNDEADHUNTER\b~           ~0x4006 UNDEADHUNTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ABJURER\b~     ~0x0040 MAGESCHOOL_ABJURER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_CONJURER\b~    ~0x0080 MAGESCHOOL_CONJURER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_DIVINER\b~     ~0x0100 MAGESCHOOL_DIVINER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ENCHANTER\b~   ~0x0200 MAGESCHOOL_ENCHANTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ILLUSIONIST\b~ ~0x0400 MAGESCHOOL_ILLUSIONIST~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_INVOKER\b~     ~0x0800 MAGESCHOOL_INVOKER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_NECROMANCER\b~ ~0x1000 MAGESCHOOL_NECROMANCER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_TRANSMUTER\b~  ~0x2000 MAGESCHOOL_TRANSMUTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_GENERALIST\b~  ~0x4000 MAGESCHOOL_GENERALIST~
  REPLACE_TEXTUALLY ~.*\bFERALAN\b~                ~0x4007 FERALAN~
  REPLACE_TEXTUALLY ~.*\bSTALKER\b~                ~0x4008 STALKER~
  REPLACE_TEXTUALLY ~.*\bBEASTMASTER\b~            ~0x4009 BEASTMASTER~
  REPLACE_TEXTUALLY ~.*\bASSASIN\b~                ~0x400A ASSASIN~
  REPLACE_TEXTUALLY ~.*\bBOUNTYHUNTER\b~           ~0x400B BOUNTYHUNTER~
  REPLACE_TEXTUALLY ~.*\bSWASHBUCKLER\b~           ~0x400C SWASHBUCKLER~
  REPLACE_TEXTUALLY ~.*\bBLADE\b~                  ~0x400D BLADE~
  REPLACE_TEXTUALLY ~.*\bJESTER\b~                 ~0x400E JESTER~
  REPLACE_TEXTUALLY ~.*\bSKALD\b~                  ~0x400F SKALD~
  REPLACE_TEXTUALLY ~.*\bGODTALOS\b~               ~0x4013 GODTALOS~
  REPLACE_TEXTUALLY ~.*\bGODHELM\b~                ~0x4014 GODHELM~
  REPLACE_TEXTUALLY ~.*\bGODLATHANDER\b~           ~0x4015 GODLATHANDER~
  REPLACE_TEXTUALLY ~.*\bTOTEMIC\b~                ~0x4010 TOTEMIC~
  REPLACE_TEXTUALLY ~.*\bSHAPESHIFTER\b~           ~0x4011 SHAPESHIFTER~
  REPLACE_TEXTUALLY ~.*\bBEASTFRIEND\b~            ~0x4012 BEASTFRIEND~
  //REPLACE_TEXTUALLY ~.*\bBARBARIAN\b~              ~0x0000 BARBARIAN~ //Avoid changing the values, what with ToBEx and all (Wisp)
  //REPLACE_TEXTUALLY ~.*\bWILDMAGE\b~               ~0x0000 WILDMAGE~
  BUT_ONLY_IF_IT_CHANGES

APPEND ~kit.ids~ ~0x4000 TRUECLASS~
  UNLESS ~\bTRUECLASS\b~
APPEND ~kit.ids~ ~0x0000 BARBARIAN~
  UNLESS ~\bBARBARIAN\b~
APPEND ~kit.ids~ ~0x0000 WILDMAGE~
  UNLESS ~\bWILDMAGE\b~

// projectl.ids changes; projectiles need to be added early to make variablea available for spell/item patching
// new projectile to correct detect evil range; see cddetevl.spl for additional changes
ADD_PROJECTILE ~bg2fixpack/pro/CDDETEVL.pro~

// clone beholder ray and assign it to beholder lightning bolt spells
// this allows it to be reflected by cloak of reflection without also reflecting all beholder projectiles
COPY_EXISTING ~spbehbla.pro~ ~override/cdbehbla.pro~
ADD_PROJECTILE ~override/cdbehbla.pro~

// eliminates duplicate SHADOW entries
COPY_EXISTING ~race.ids~ ~override~
  REPLACE_TEXTUALLY ~^149 +SHADOW\b~ ~149 STATUE~
  BUT_ONLY_IF_IT_CHANGES

// add ettin racial entry; needed to give Crom ability to insta-kill ettins
APPEND ~race.ids~ ~199 ETTIN~ UNLESS ~199 ETTIN~

// added snares for scripting purposes, fix broken entry
COPY_EXISTING ~spell.ids~ ~override~
  REPLACE_TEXTUALLY ~3544 PSIONIC _SUPERIOR_INVISIBILITY~ ~3544 PSIONIC_SUPERIOR_INVISIBILITY~
APPEND ~spell.ids~ ~1718 CLERIC_SYMBOL_STUN~      UNLESS ~^1718 CLERIC_SYMBOL_STUN~
APPEND ~spell.ids~ ~1719 CLERIC_SYMBOL_DEATH~     UNLESS ~^1719 CLERIC_SYMBOL_DEATH~
APPEND ~spell.ids~ ~4321 BERSERKER_ENRAGE~        UNLESS ~^4321 BERSERKER_ENRAGE~
APPEND ~spell.ids~ ~4412 THIEF_SET_SNARE~         UNLESS ~^4412 THIEF_SET_SNARE~
APPEND ~spell.ids~ ~4414 THIEF_SET_SPECIAL_SNARE~ UNLESS ~^4414 THIEF_SET_SPECIAL_SNARE~

// new state needed to fix Dead() triggers that don't use DVs
APPEND ~state.ids~ ~0x00000FC0 STATE_REALLY_DEAD~ UNLESS ~0x00000FC0 STATE_REALLY_DEAD~

// force WeiDU to reload altered IDS files
CLEAR_IDS_MAP

/////                                                  \\\\\
///// misc 2da fixes                                   \\\\\
/////                                                  \\\\\

// chicken sound fixes
COPY_EXISTING achk.2da override
  SET_2DA_ENTRY 12 1 1 0
  SET_2DA_ENTRY 14 1 1 0
BUT_ONLY

// sound fix
COPY_EXISTING achk.2da ~override/mshr.2da~ // It's easier to just build these from the ground up
  SET_2DA_ENTRY_LATER ~mshr~  0 0 ~MSHR /shrieker/~
  SET_2DA_ENTRY_LATER ~mshr~  3 1 ~SHRIE04B NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~  4 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 11 1 ~SHRIE07A SHRIE07B~
  SET_2DA_ENTRY_LATER ~mshr~ 12 1 ~0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 13 1 ~SHRIE09A SHRIE09B~
  SET_2DA_ENTRY_LATER ~mshr~ 14 1 ~0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 25 1 ~SHRIE03A NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 26 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 27 1 ~SHRIE03B NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 28 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 29 1 ~SHRIE04A NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 30 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 39 1 ~***~ // Doesn't really need a battle cry, since it doesn't ever attack
  SET_2DA_ENTRIES_NOW ~mshr~ 1

// allows multi-class thieves to be LN and LE
COPY_EXISTING ~ALIGNMNT.2da~ ~override~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 13 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 13 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 14 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 14 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 15 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 15 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 17 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 17 3 ~1~
  SET_2DA_ENTRIES_NOW ~ALIGNMNT~ 1
  BUT_ONLY_IF_IT_CHANGES
  
// blade pp fix
COPY_EXISTING ~clabba02.2da~ ~override~
  SET_2DA_ENTRY_LATER ~blade~ 8 1 ~AP_CDBLPP1~
  FOR (col = 2 ; col < 18 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP3~
  END
  FOR (col = 3 ; col < 18 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP2~
  END
  FOR (col = 17 ; col < 37 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP4~
  END
  FOR (col = 18 ; col < 37 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP5~
  END
  SET_2DA_ENTRIES_NOW ~blade~ 1
  BUT_ONLY_IF_IT_CHANGES

//Fix Skald's lack of thac0 bonus
COPY_EXISTING ~CLABBA04.2DA~ ~override~
  REPLACE_TEXTUALLY ~AP_SPCL541~ ~AP_SPCL141~ // Replaces Skald's +1 damage with Swashbuckler's +1 thac0/damage.
  UNLESS ~AP_SPCL141~
  BUT_ONLY_IF_IT_CHANGES

// in SoA, two swashbuckler ability columns run together
COPY_EXISTING ~clabth04.2da~ ~override~
 REPLACE_TEXTUALLY ~\(AP_SPCL[14]41\)\(\*+\|GA_SPCL412\)~ ~\1 \2~
 BUT_ONLY_IF_IT_CHANGES

// fallen paladin/ranger missing a column in their ABILITY1 line
COPY_EXISTING ~clabfi05.2da~ ~override~
 REPLACE_TEXTUALLY ~^\(ABILITY1 +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+ +[^ %tab%]+\).*$~ ~\1~
 BUT_ONLY_IF_IT_CHANGES

// in ToB archers and stalkers not allowed to dual-class; adding restriction to SoA games as well
COPY_EXISTING ~dualclas.2da~ ~override~
  SET_2DA_ENTRY 32 2 7 ~0~ // archer (feralan)
  SET_2DA_ENTRY 33 2 7 ~0~ // stalker
  BUT_ONLY_IF_IT_CHANGES

// Imoen gets her groove back. And her banter file.
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~interdia.2da~ ~override~
    SET_2DA_ENTRY 17 1 2 ~BIMOEN2~ // fixes ToB version
    BUT_ONLY_IF_IT_CHANGES

END ELSE BEGIN

  APPEND ~interdia.2da~ ~IMOEN       BIMOEN2~ // fixes SoA version
    UNLESS ~BIMOEN2~

END
  
// maze not lasting as long as specified in descript; patching intmod.2da for int < 9
COPY_EXISTING ~intmod.2da~ ~override~
  SET "dice" = 20
  FOR (index = 3 ; index < 12 ; index = index + 1) BEGIN
    SET_2DA_ENTRY_LATER ~intmod~ "%index%" 4 "%dice%"
    PATCH_IF ("%index%" = 5) BEGIN
      SET "dice" = 10
    END ELSE
    PATCH_IF ("%index%" = 8) BEGIN
      SET "dice" = 5
    END
  END
  SET_2DA_ENTRIES_NOW ~intmod~ 1
  BUT_ONLY_IF_IT_CHANGES

// removes incorrect NWN reference in load hints
COPY_EXISTING ~loadhint.2da~ ~override~
  REPLACE_TEXTUALLY ~40954~ ~34572~
  BUT_ONLY_IF_IT_CHANGES

// sound fixes for monsters
COPY_EXISTING mair.2da ~override/mwwe.2da~
  REPLACE_TEXTUALLY ~Mair/air elemental~ ~%DEST_RES% /water weird~

COPY_EXISTING mcar.2da ~override/mcwl.2da~
  REPLACE_TEXTUALLY ~Mcar/carrion crawler~ ~%DEST_RES% /Carrion Crawler/~

COPY_EXISTING mdji.2da ~override/mdjl.2da~
  REPLACE_TEXTUALLY ~Mdji/Djinni~ ~%DEST_RES% /djinni w legs/~

COPY_EXISTING mgo1.2da ~override/mgo3.2da~
  REPLACE_TEXTUALLY ~MGO1 /goblin w axe/~ ~%DEST_RES% /goblin elite w axe/~

COPY_EXISTING mgo2.2da ~override/mgo4.2da~
  REPLACE_TEXTUALLY ~MGO2 /goblin w bow/~ ~%DEST_RES% /goblin elite w bow/~

COPY_EXISTING mli2.2da ~override/mli3.2da~
  REPLACE_TEXTUALLY ~MLI2 /lizard man 1 hand/~ ~%DEST_RES% /lizard man caster 3/~

COPY_EXISTING mmyc.2da ~override/mmy2.2da~
  REPLACE_TEXTUALLY ~MMYC /myconid,red/~ ~%DEST_RES% /myconid,blue/~

COPY_EXISTING mor2.2da override
  REPLACE_TEXTUALLY "orcbw07" "orcbw07a"
  REPLACE_TEXTUALLY "orcbw08" "orcbw07b"
BUT_ONLY

COPY_EXISTING mor2.2da ~override/mor4.2da~
  REPLACE_TEXTUALLY ~MOR2 /orc w bow/~  ~%DEST_RES% /orc ranged 4/~

COPY_EXISTING msal.2da ~override/msa2.2da~
  REPLACE_TEXTUALLY ~MSAL /salamander/~ ~%DEST_RES% /salamander,frost/~

COPY_EXISTING mska.2da ~override/mskt.2da~
  REPLACE_TEXTUALLY ~MSKA /skeleton,armored/~ ~%DEST_RES% /skeleton armored no helmet/~

// small spider soundset fixes
COPY_EXISTING msps.2da override
  REPLACE_TEXTUALLY ~^Selection +smspid03~ ~Selection                       smspid01~
  REPLACE_TEXTUALLY ~\bsmspid03 +smspid04~ ~smspid01 smspid02~
  REPLACE_TEXTUALLY ~\bsmspid08~ ~smspid06~
  REPLACE_TEXTUALLY ~\bsmspid09~ ~smspid07~
BUT_ONLY

/* does nothing :(
COPY_EXISTING mtro.2da override
  REPLACE_TEXTUALLY ~TROLL08a~ ~troll07a troll07b~
  REPLACE_TEXTUALLY ~TROLL08b~ ~troll08a troll08b~
  SET_2DA_ENTRY 4 2 3 ~0 0 0~
BUT_ONLY
*/

// small troll sounds
COPY_EXISTING mtrs.2da override
  REPLACE_TEXTUALLY ~ICETR~ ~troll~
BUT_ONLY

COPY_EXISTING mwfm.2da override
  REPLACE_TEXTUALLY ~pseudo0~ ~pseud0~
BUT_ONLY

COPY_EXISTING myu2.2da override
  REPLACE_TEXTUALLY ~yanel\(7\|8\)~ ~yanel0\1~
BUT_ONLY

// gives bards a fourth level 6 spell at high levels, SoA-only
ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~MXSPLBRD.2da~ ~override~
    COUNT_2DA_ROWS ~1~ "rowcount"
    FOR (row = rowcount ; row > (rowcount - 19) ; row = row - 1) BEGIN
      SET_2DA_ENTRY_LATER ~MXSPLBRD~ "%row%" 6 ~4~
    END
    SET_2DA_ENTRIES_NOW ~MXSPLBRD~ 1
    BUT_ONLY_IF_IT_CHANGES

END

// NPCs joining level 25+ PCs in SoA would be at their minimum level, not max
COPY_EXISTING ~npclevel.2da~ ~override~
  REPLACE_TEXTUALLY ~^\([A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+[%tab% ]+[A-Za-z0-9*]+\)\([%tab% ]+[A-Za-z0-9*]+\)~
    ~\1\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2~ // extends individual lines
  REPLACE_TEXTUALLY ~\(2[%tab% ]+3[%tab% ]+4[%tab% ]+5[%tab% ]+6[%tab% ]+7[%tab% ]+8[%tab% ]+9[%tab% ]+10[%tab% ]+11[%tab% ]+12[%tab% ]+13[%tab% ]+14[%tab% ]+15[%tab% ]+16[%tab% ]+17[%tab% ]+18[%tab% ]+19[%tab% ]+20[%tab% ]+21[%tab% ]+22[%tab% ]+23\)\([%tab% ]+\)24~
    ~\1\224\225\226\227\228\229\230\231\232\233\234\235\236\237\238\239\240~ // extends header row
  UNLESS ~25[%tab% ]+26[%tab% ]+27[%tab% ]+28[%tab% ]+29[%tab% ]+30[%tab% ]+31[%tab% ]+32[%tab% ]+33[%tab% ]+34[%tab% ]+35[%tab% ]+36[%tab% ]+37[%tab% ]+38[%tab% ]+39[%tab% ]+40~
  BUT_ONLY_IF_IT_CHANGES

// consistent raise dead prices
COPY_EXISTING ~RAISDEAD.2DA~ ~override~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 31 1 ~12500~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 32 1 ~13000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 34 1 ~14000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 36 1 ~15000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 38 1 ~16000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 40 1 ~17000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 42 1 ~18000~
  SET_2DA_ENTRIES_NOW ~RAISDEAD~ 1
  BUT_ONLY_IF_IT_CHANGES

// fixes to high level rogue saves
COPY_EXISTING ~SAVEROG.2da~ ~override~
  FOR (col = 21 ; col < 41 ; col = col + 1) BEGIN
    SET_2DA_ENTRY_LATER ~SAVEROG~ 3 "%col%" ~8~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 4 "%col%" ~4~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 5 "%col%" ~7~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 6 "%col%" ~11~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 7 "%col%" ~5~
  END
  SET_2DA_ENTRIES_NOW ~SAVEROG~ 1
  BUT_ONLY_IF_IT_CHANGES

// fixes to high level mage saves
COPY_EXISTING ~SAVEWIZ.2da~ ~override~
  FOR (col = 21 ; col < 41 ; col = col + 1) BEGIN
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 3 "%col%" ~8~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 4 "%col%" ~3~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 5 "%col%" ~5~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 6 "%col%" ~7~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 7 "%col%" ~4~
  END
  SET_2DA_ENTRIES_NOW ~SAVEWIZ~ 1
  BUT_ONLY_IF_IT_CHANGES

//build skilldex down to 1
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^9\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~8\1
9\1~
  UNLESS ~^8\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^8\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~7\1
8\1~
  UNLESS ~^7\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^7\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~6\1
7\1~
  UNLESS ~^6\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^6\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~5\1
6\1~
  UNLESS ~^5\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^5\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~4\1
5\1~
  UNLESS ~^4\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^4\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~3\1
4\1~
  UNLESS ~^3\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^3\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~2\1
3\1~
  UNLESS ~^2\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^2\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~1\1
2\1~
  UNLESS ~^1\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES

// echo-y Promenade fix
COPY_EXISTING ~sndresrf.2da~ ~override~
  REPLACE_TEXTUALLY ~AR0700 +STONE0~ ~*       *~
  BUT_ONLY_IF_IT_CHANGES

// spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap
// see also states.bam, states2.bam, spwi606.spl
COPY_EXISTING ~statdesc.2da~ ~override~
  REPLACE_TEXTUALLY ~^\(73[%tab% ]+\)[0-9]+~ ~\126228~
  REPLACE_TEXTUALLY ~^\(123[%tab% ]+\)[0-9]+~ ~\18286~
  BUT_ONLY_IF_IT_CHANGES

APPEND ~tooltip.2da~ // adds dupe rod of lordly might
  ~RODS02A           6337         6352        6350~

COPY_EXISTING ~THAC0.2DA~ ~override~
  SET_2DA_ENTRY  6 21 1 ~10~
  SET_2DA_ENTRY  7 21 1 ~10~
  SET_2DA_ENTRY 15 21 1 ~10~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~WEAPPROF.2da~ ~override~
  SET_2DA_ENTRY_LATER ~weapprof~ 16 41 ~2~ // 1 > 2 stars for swashbucklers in katanas
  SET_2DA_ENTRY_LATER ~weapprof~ 16 51 ~1~ // 0 > 1 star for monk in katanas
  SET_2DA_ENTRY_LATER ~weapprof~ 20 20 ~2~ // 3 > 2 stars for f/m/c in clubs
  SET_2DA_ENTRY_LATER ~weapprof~ 20 21 ~2~ // 3 > 2 stars for c/r in clubs
  SET_2DA_ENTRY_LATER ~weapprof~ 26 41 ~1~ // 2 > 1 star for swashbucklers in xbows
  SET_2DA_ENTRY_LATER ~weapprof~ 28 41 ~1~ // 2 > 1 star for swashbucklers in shortbows
  SET_2DA_ENTRY_LATER ~weapprof~ 29 32 ~0~ // 5 > 0 stars for kensai in darts
  SET_2DA_ENTRY_LATER ~weapprof~ 29 33 ~0~ // 2 > 0 stars for cavalier in darts
  SET_2DA_ENTRY_LATER ~weapprof~ 30 41 ~1~ // 2 > 1 star for swashbucklers in slings
  SET_2DA_ENTRY_LATER ~weapprof~ 31 19 ~2~ // 1 > 2 stars for f/d in 2 handed
  SET_2DA_ENTRY_LATER ~weapprof~ 31 20 ~2~ // 1 > 2 stars for f/m/c in 2 handed
  SET_2DA_ENTRY_LATER ~weapprof~ 31 21 ~2~ // 1 > 2 stars for c/r in 2 handed
//  SET_2DA_ENTRY_LATER ~weapprof~ 34  9 ~2~ // 3 > 2 stars for paladin in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 19 ~3~ // 1 > 3 stars for f/d in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 20 ~3~ // 2 > 3 stars for f/m/c in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 21 ~3~ // 2 > 3 stars for c/r in 2 wpn style
  COUNT_2DA_ROWS ~1~ "rowcount"
  FOR (row = rowcount ; row > (rowcount - 20) ; row = row - 1) BEGIN // covers last 19 rows (n/a as actual profs)
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  5 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  8 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  9 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 11 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 12 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 14 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 15 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 20 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 21 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 30 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 31 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 32 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 33 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 34 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 35 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 36 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 37 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 38 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 42 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 43 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 44 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 52 ~0~
  END
  SET_2DA_ENTRIES_NOW ~weapprof~ 1
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // invalid resource ref used for bard kits
  COPY_EXISTING ~25STWEAP.2da~ ~override~
    REPLACE_TEXTUALLY ~LEATH14~ ~LEAT14 ~
    
  // part of the multi-holy symbol exploit fix. Also needed: CDHLYSYM.spl, CDHLYSY2.spl, CDHLYSYM.itm, and holysym.baf.
  COPY_EXISTING ~clabpr01.2da~ ~override~
                ~clabpr02.2da~ ~override~
                ~clabpr03.2da~ ~override~
                ~clabpr04.2da~ ~override~
    REPLACE_TEXTUALLY ~AP_SPCl93[1234] ~ ~AP_CDHLYSYM~
    BUT_ONLY_IF_IT_CHANGES

  // adds load hints for ToB
  APPEND ~LOADH25.2DA~ ~79          34572~
               UNLESS ~^79 ~
  APPEND ~LOADHINT.2DA~ ~75          34572~
                UNLESS ~^75 ~
  APPEND ~LOADHINT.2DA~ ~76          72818~
                UNLESS ~^76 ~

  // removes incorrect NWN reference in load hints
  COPY_EXISTING ~loadh25.2da~ ~override~
    REPLACE_TEXTUALLY ~ 40954~ ~34572~
    BUT_ONLY_IF_IT_CHANGES

  // gives f/m/c and f/m/t unique HLAs; tables created below
  COPY_EXISTING ~LUABBR.2DA~ ~override~
    SET_2DA_ENTRY 14 1 1 ~FMT~
    SET_2DA_ENTRY 19 1 1 ~FMC~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 1
  COPY_EXISTING ~luba1.2da~ ~override~
                ~luba2.2da~ ~override~
                ~luba3.2da~ ~override~
                ~luth2.2da~ ~override~
                ~luth3.2da~ ~override~
    SET_2DA_ENTRY 9 7 1 ~*~
    SET_2DA_ENTRY 9 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 2
  COPY_EXISTING ~LUCT0.2DA~ ~override~
                ~LUMT0.2DA~ ~override~
    SET_2DA_ENTRY 9 7 1 ~*~
    SET_2DA_ENTRY 9 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 3
  COPY_EXISTING ~LUFT0.2DA~ ~override~
    SET_2DA_ENTRY 19 7 1 ~*~
    SET_2DA_ENTRY 19 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // creates f/m/c HLA table
  COPY_EXISTING ~LUFC0.2DA~ ~override/LUFMC.2DA~
    FOR (ROW = 22; ROW < 25; ROW = ROW + 1) BEGIN
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 4 ~1~
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 5 ~99~
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 6 ~1~
    END
    SET_2DA_ENTRY_LATER ~LUFMC~ 22 1 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMC~ 23 1 ~AP_SPCL929~
    SET_2DA_ENTRY_LATER ~LUFMC~ 23 7 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMC~ 24 1 ~AP_SPCL930~
    SET_2DA_ENTRY_LATER ~LUFMC~ 24 7 ~AP_SPCL929~
    SET_2DA_ENTRIES_NOW ~LUFMC~ 1
    BUT_ONLY_IF_IT_CHANGES
 
  // creates f/m/t HLA table
  COPY_EXISTING ~LUFT0.2DA~ ~override/LUFMT.2DA~
    FOR (ROW = 23; ROW < 26; ROW = ROW + 1) BEGIN
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 4 ~1~
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 5 ~99~
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 6 ~1~
    END
    SET_2DA_ENTRY_LATER ~LUFMT~ 23 1 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMT~ 24 1 ~AP_SPCL929~
    SET_2DA_ENTRY_LATER ~LUFMT~ 24 7 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMT~ 25 1 ~AP_SPCL930~
    SET_2DA_ENTRY_LATER ~LUFMT~ 25 7 ~AP_SPCL929~
    SET_2DA_ENTRIES_NOW ~LUFMT~ 1
    BUT_ONLY_IF_IT_CHANGES

  //fixes Gromnir XP bug
  COPY_EXISTING ~XPLIST.2DA~ ~override~
    SET_2DA_ENTRY 67 38 39 ~-1 -1 -1 -1~
    BUT_ONLY_IF_IT_CHANGES
END

/////                                                  \\\\\
///// mass compile/copy actions actions                \\\\\
/////                                                  \\\\\

COMPILE ~bg2fixpack/compile/soa-dlg.d~    // all dialogue fixes
        ~bg2fixpack/compile/ar0512.baf~   // blanks area script for helm temple in bridge ditrict; had been using old durlag tower script
        ~bg2fixpack/compile/bhcrypt.baf~  // crypt king horror
        ~bg2fixpack/compile/cdkpdog.baf~  // keep dogs non-hostile
        ~bg2fixpack/compile/cut41i.baf~   // spellhold cutscene loop
        ~bg2fixpack/compile/cut41j.baf~   // spellhold cutscene loop
        ~bg2fixpack/compile/druidad.baf~  // druid messenger
        ~bg2fixpack/compile/rdog.baf~     // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rdwarf.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/retter.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rgibbler.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhalflin.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhobgoba.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhobgobf.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rkobold.baf~  // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rogre.baf~    // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rsiren.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rsirine.baf~  // corrupted scrpt; compile new one with uncorrupted bits
COPY_EXISTING ~ar0512.bcs~ ~override/ar1800.bcs~ // north forest also using old BG script

COPY ~bg2fixpack/copy/amb_e09b.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/amb_m09a.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/amb_m09b.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/ar0512.mos~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512.tis~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512.wed~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512ht.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512lm.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512sr.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar1404.mos~   ~override~ // temple ruins daytime map
     ~bg2fixpack/copy/cdblpp1.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp2.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp3.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp4.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp5.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdcmelem.eff~ ~override~ // ring of foo control charm fix (see ring27, ring28, ring29)
     ~bg2fixpack/copy/cdelfcm0.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm1.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm2.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm3.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm4.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm5.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm6.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl0.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl1.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl2.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl3.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl4.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdlv3na.spl~  ~override~ // removes 3rd level holy/unholy cleric spells per alignment
     ~bg2fixpack/copy/cdlv7na.spl~  ~override~ // removes 7th level holy/unholy cleric spells per alignment
     ~bg2fixpack/copy/cdrmv313.eff~ ~override~ // removes holy smite
     ~bg2fixpack/copy/cdrmv314.eff~ ~override~ // removes unholy blight
     ~bg2fixpack/copy/cdrmv710.eff~ ~override~ // removes holy word
     ~bg2fixpack/copy/cdrmv715.eff~ ~override~ // removes unholy word
     ~bg2fixpack/copy/cdspja00.eff~ ~override~ // str attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja01.eff~ ~override~ // dex attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja02.eff~ ~override~ // con attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja03.eff~ ~override~ // int attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja04.eff~ ~override~ // wis attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja05.eff~ ~override~ // chr attribute penalies for harper's call
     ~bg2fixpack/copy/cdwi917a.spl~ ~override~ // imprisoned summon fix: see gender.ids, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
     ~bg2fixpack/copy/cdwi910.eff~  ~override~ // imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
     ~bg2fixpack/copy/famcat01.wav~ ~override~ // cat familiar sounds from ToB to SoA
     ~bg2fixpack/copy/cdfampsd.itm~ ~override~ // SoA pseudo-gragon attack item
     ~bg2fixpack/copy/iscrl5a.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5b.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5c.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5d.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5e.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5f.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5g.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5h.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5i.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5j.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5k.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5l.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5m.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5n.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5o.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5p.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5q.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/mdog_mo.bmp~  ~override~ // fixed moon dog avatar
     ~bg2fixpack/copy/misc_01b.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_01c.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_03a.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_04a.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_06b.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/pre_p06.wav~  ~override~ // missing sound files
     ~bg2fixpack/copy/sppr203d.spl~ ~override~ // shell spell for chant
     ~bg2fixpack/copy/sppr203e.spl~ ~override~ // shell spell for chant   
     ~bg2fixpack/copy/spwi413a.spl~ ~override~ // otiluke spell shell; see also spcl415.spl, spcl415a.spl, spwi413.spl
     ~bg2fixpack/copy/states.bam~   ~override~ // spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap - see also statdesc.2da, spwi606.spl
     ~bg2fixpack/copy/states2.bam~  ~override~ // spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap - see also statdesc.2da, spwi606.spl
     ~bg2fixpack/copy/worldmap.wmp~ ~override~ // fixed soa worldmap
COPY_EXISTING ~cdwi910.eff~ ~override/cdwi917a.eff~ // imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
  WRITE_LONG 0x1c 6 //summoned

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // additional copy & compile for ToB

  COMPILE ~bg2fixpack/compile-tob/tob-dlg.d~            // all ToB dialogue fixes
  COMPILE ~bg2fixpack/compile-tob/wk-ntrjex.d~          // add WK interjections to SoA
  COPY    ~bg2fixpack/copy-tob/cdhlysy2.spl~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/cdhlysym.spl~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/cdhlysym.itm~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/worldmap.wmp~ ~override~ // fixed soa worldmap; tob version is better due to cleaner drizzt fixes

END

ACTION_IF ("%LANGUAGE%" STRING_EQUAL_CASE "english") THEN BEGIN // these are English-only sounds (spoken lines)
  COPY ~bg2fixpack/copy/shael_07.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_08.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_09.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_10.wav~ ~override~ // missing sound files
END

/////                                                  \\\\\
///// dialogue fixes                                   \\\\\
/////                                                  \\\\\

// makes Delcia's guard's dialogue pause the game to prevent Delcia's interruption
COPY_EXISTING ~kpsold01.dlg~ ~override~
  WRITE_LONG 0x30 0
  BUT_ONLY_IF_IT_CHANGES

// these three show as corrupted by NI if done via d patch... believe it's empty DO ~~ actions. recompile fixes all issues.
COPY_EXISTING ~glanma.dlg~ ~override~
              ~ramazi.dlg~ ~override~
              ~thalan.dlg~ ~override~
  DECOMPILE_DLG_TO_D
  COMPILE_D_TO_DLG
  
/////                                                  \\\\\
///// scripting fixes                                  \\\\\
/////                                                  \\\\\

// player AI script fixes
// check to see if outside is broken
COPY ~scripts/cleric3.bs~ ~scripts/cleric3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AreaCheck("UTDOOR)")~ ~AreaType(OUTDOOR)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// check to see if outside is broken
COPY ~scripts/fighter4.bs~ ~scripts/fighter4.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!Dead("astAttackerOf(LastSeenBy(Myself)))")~ ~!StateCheck(LastAttackerOf(LastSeenBy(Myself)),STATE_REALLY_DEAD)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// actual compile errors first
// override corrupt biffed scripts with blanks
EXTEND_BOTTOM ~ar2812.bcs~   ~bg2fixpack/compile/ar0512.baf~

// fix compile error
COPY_EXISTING ~IDIOT01.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(31)~ ~OR(30)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fix compile errors with bad numbers in OR blocks
COPY_EXISTING ~VICG.BCS~  ~override~
              ~VICG1.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(4)~ ~OR(2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// big, major script patch
COPY_EXISTING ~ABAZDRAG.BCS~ ~override~
              ~AERIEX.BCS~   ~override~
              ~AESGAR.BCS~   ~override~
              ~ALARM25.BCS~  ~override~
              ~AMLICH01.BCS~ ~override~
              ~AMLICH02.BCS~ ~override~
//              ~ANOMEN.BCS~   ~override~
              ~ANOMX.BCS~    ~override~
              ~APPRENTI.BCS~ ~override~
              ~AR0329.BCS~   ~override~
              ~AR1202.BCS~   ~override~
              ~AR2500.BCS~   ~override~
//              ~AR3021.BCS~   ~override~
//              ~AR3351.BCS~   ~override~
              ~AR4000.BCS~   ~override~
//              ~AREATEST.BCS~ ~override~
              ~ASYLUM.BCS~   ~override~
              ~BALMONK.BCS~  ~override~
              ~BEHELD01.BCS~ ~override~ 
              ~CARCH20B.BCS~ ~override~
              ~CARCH30B.BCS~ ~override~
              ~CASSA20B.BCS~ ~override~
              ~CASSA20C.BCS~ ~override~
              ~CAULDRON.BCS~ ~override~
              ~CBARB20B.BCS~ ~override~
              ~CBARD12A.BCS~ ~override~
              ~CBERS20B.BCS~ ~override~
              ~CESPEN.BCS~   ~override~
              ~CFIGH20A.BCS~ ~override~
              ~CFIGH20B.BCS~ ~override~
              ~CFIGH30B.BCS~ ~override~
              ~CFMAG20B.BCS~ ~override~
              ~CHALDIE.BCS~  ~override~
              ~CHALPC01.BCS~ ~override~
              ~CKENS20B.BCS~ ~override~
              ~CKENS30B.BCS~ ~override~
              ~CKMAG20A.BCS~ ~override~
              ~CKMAG20B.BCS~ ~override~
              ~CKTHI20B.BCS~ ~override~
              ~CMACL20A.BCS~ ~override~
              ~CMAGE20A.BCS~ ~override~
              ~CMAGE20B.BCS~ ~override~
              ~CMONK20B.BCS~ ~override~
              ~CTHIE20A.BCS~ ~override~
              ~CTHIE20B.BCS~ ~override~
//              ~CUT.BCS~      ~override~
              ~CUT01.BCS~    ~override~
              ~CUT215A.BCS~  ~override~
              ~CUT216A.BCS~  ~override~
              ~CUT35B.BCS~   ~override~
              ~CUT49E.BCS~   ~override~
              ~CUT57C.BCS~   ~override~
              ~CUTD1.BCS~    ~override~
              ~DADROW5.BCS~  ~override~
              ~DAQDROW.BCS~  ~override~
//              ~DCRITTER.BCS~ ~override~
              ~DDGUARD7.BCS~ ~override~ 
              ~DECK622.BCS~  ~override~
              ~DEGARD.BCS~   ~override~
              ~DEGARD2.BCS~  ~override~
//              ~DMONSTER.BCS~ ~override~
//              ~DNPC.BCS~     ~override~
              ~DRACONIS.BCS~ ~override~
              ~DRAGBROW.BCS~ ~override~
              ~DRAGGRE2.BCS~ ~override~
              ~DRAGGREE.BCS~ ~override~
              ~DRAGSILV.BCS~ ~override~
              ~DRUIDX.BCS~   ~override~
//              ~DUMMY.BCS~    ~override~
              ~DWVITH.BCS~   ~override~
              ~EDWIN.BCS~    ~override~
              ~ELTAN.BCS~    ~override~
              ~ENFORAM.BCS~  ~override~
//              ~EWMOVE.BCS~   ~override~
              ~FINSOL04.BCS~ ~override~
              ~FIRLCH01.BCS~ ~override~
              ~FORCEF.BCS~   ~override~
              ~FSWHEEL.BCS~  ~override~
//              ~FTOWNA3.BCS~  ~override~
//              ~GANIMAL.BCS~  ~override~
//              ~GHUMANIO.BCS~ ~override~
//              ~GMONSTER.BCS~ ~override~
              ~GORCAMB2.BCS~ ~override~
              ~GORCAMB3.BCS~ ~override~
              ~GORCAMB4.BCS~ ~override~
              ~GORCAMB5.BCS~ ~override~
              ~GORCAMB6.BCS~ ~override~
              ~GORDECKF.BCS~ ~override~
              ~GORGOLI.BCS~  ~override~
              ~GORLIC01.BCS~ ~override~
              ~GORSAL.BCS~   ~override~
              ~GORSTAM.BCS~  ~override~
              ~GP115.BCS~    ~override~
              ~GP116.BCS~    ~override~
              ~GPARCHER.BCS~ ~override~
              ~GPHEALER.BCS~ ~override~
              ~GPKENSAI.BCS~ ~override~
              ~GPMAGE1.BCS~  ~override~
              ~GPMAGE2.BCS~  ~override~
              ~GPMERC.BCS~   ~override~
              ~GPSHOUT.BCS~  ~override~
              ~GPTHIEF.BCS~  ~override~
              ~GRPSHT01.BCS~ ~override~
//              ~GUNDEAD.BCS~  ~override~
              ~HELLGEN.BCS~  ~override~
              ~HELLSLAY.BCS~ ~override~
              ~ILLASERA.BCS~ ~override~
              ~ILYICH.BCS~   ~override~
              ~ITGLOBES.BCS~ ~override~
              ~JATERMIN.BCS~ ~override~
              ~KAYSMG03.BCS~ ~override~
              ~KAYSMG04.BCS~ ~override~
              ~KELDORNX.BCS~ ~override~
              ~KEYSCRIP.BCS~ ~override~
//              ~KOBOLD.BCS~   ~override~
              ~KPFIGHT.BCS~  ~override~
              ~KPROEN02.BCS~ ~override~
              ~KUOARC20.BCS~ ~override~
              ~KUOWAR20.BCS~ ~override~
              ~LEHTINAN.BCS~ ~override~
//              ~LGAREA.BCS~   ~override~
              ~MAGE10A.BCS~  ~override~
              ~MAGE10D.BCS~  ~override~
              ~MAGE12B.BCS~  ~override~
              ~MAGE12D.BCS~  ~override~
              ~MAGE12E.BCS~  ~override~
              ~MAGE14A.BCS~  ~override~
              ~MAGE14B.BCS~  ~override~
              ~MAGE14C.BCS~  ~override~
              ~MAGE14D.BCS~  ~override~
              ~MAGE14M.BCS~  ~override~
              ~MAGE14T.BCS~  ~override~
              ~MAGE16A.BCS~  ~override~
              ~MAGE16B.BCS~  ~override~
              ~MAGE16C.BCS~  ~override~
              ~MAGE16M.BCS~  ~override~
              ~MAGE18A.BCS~  ~override~
              ~MAGE18B.BCS~  ~override~
              ~MAGE18C.BCS~  ~override~
              ~MAGE18D.BCS~  ~override~
              ~MAGE18E.BCS~  ~override~
              ~MAGE18Y.BCS~  ~override~
              ~MAGE20A.BCS~  ~override~
              ~MAGE20B.BCS~  ~override~
              ~MAGE20C.BCS~  ~override~
              ~MAGEHIGH.BCS~ ~override~
              ~MAZZY.BCS~    ~override~
//              ~MDAREA.BCS~   ~override~
              ~MINDAL01.BCS~ ~override~
//              ~MINSC.BCS~    ~override~
              ~MINSCX.BCS~   ~override~
              ~MINVSED.BCS~  ~override~
//              ~MONSTER.BCS~  ~override~
              ~MOVIE03A.BCS~ ~override~
              ~MOVIE03B.BCS~ ~override~
//              ~NALIA.BCS~    ~override~
//              ~NEMOVE.BCS~   ~override~
              ~NEVA.BCS~     ~override~
              ~NPC.BCS~      ~override~
              ~NPCDRU1.BCS~  ~override~
//              ~NSMOVE.BCS~   ~override~
//              ~NWMOVE.BCS~   ~override~
//              ~PIPE04.BCS~   ~override~
              ~PPCRUS1.BCS~  ~override~
              ~PPSHAD01.BCS~ ~override~
              ~PPSHAD02.BCS~ ~override~
              ~PPSHAD03.BCS~ ~override~
              ~PPSHAD04.BCS~ ~override~
              ~PPSHAD05.BCS~ ~override~
              ~PPSHAD06.BCS~ ~override~ 
              ~PWARDEN.BCS~  ~override~
//              ~RANDFLY.BCS~  ~override~
//              ~RANDWALK.BCS~ ~override~
//              ~RBEAR.BCS~    ~override~
//              ~RCHICKEN.BCS~ ~override~
//              ~RCOW.BCS~     ~override~
//              ~RELF.BCS~     ~override~
//              ~RGNOLL.BCS~   ~override~
//              ~RHORSE.BCS~   ~override~
//              ~RHUMAN.BCS~   ~override~
//              ~RSPIDER.BCS~  ~override~
//              ~RWOLF.BCS~    ~override~
              ~SARBUL01.BCS~ ~override~
              ~SARBUL02.BCS~ ~override~
              ~SARBUL03.BCS~ ~override~
              ~SARDW01.BCS~  ~override~
              ~SARDW02.BCS~  ~override~
              ~SARDW03.BCS~  ~override~
              ~SENDARK.BCS~  ~override~
              ~SENGUA04.BCS~ ~override~
              ~SENGUA05.BCS~ ~override~
              ~SHADEL.BCS~   ~override~
//              ~SMAREA.BCS~   ~override~
//              ~SPSHADOM.BCS~ ~override~
//              ~SPSHADOW.BCS~ ~override~
              ~spwnrak.BCS~  ~override~
              ~SUMTAN01.BCS~ ~override~
              ~TELTIEF3.BCS~ ~override~
              ~TELWRAI.BCS~  ~override~
              ~TEMPV01.BCS~  ~override~
              ~TEMSUP.BCS~   ~override~
              ~TIEF3.BCS~    ~override~
              ~UDMASTER.BCS~ ~override~
              ~UDTRAIN.BCS~  ~override~
              ~UND5509.BCS~  ~override~
              ~USEITEM.BCS~  ~override~
              ~VALVSED.BCS~  ~override~
              ~VALYGX.BCS~   ~override~
              ~VICX.BCS~     ~override~
//              ~VWENCH.BCS~   ~override~
//              ~WAIT.BCS~     ~override~
              ~XEIWIN.BCS~   ~override~
//              ~XR2600.BCS~   ~override~
              ~YAGALT.BCS~   ~override~
              ~YAGART.BCS~   ~override~
              ~YOCHLOL.BCS~  ~override~
//              ~YOSHIMO.BCS~  ~override~
              ~YSCARA.BCS~   ~override~
              ~YSGP01.BCS~   ~override~
              ~YSGP02.BCS~   ~override~
              ~YSGP03.BCS~   ~override~
              ~YSGP04.BCS~   ~override~
              ~YSGRUNT.BCS~  ~override~
              ~ZILMAG01.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY %Dead("yself)")% %StateCheck(Myself,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astSeenBy(\(Myself\)?))")% %StateCheck(LastSeenBy(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astHeardBy(\(Myself\)?))")% %StateCheck(LastHeardBy(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astTrigger)")% %StateCheck(LastTrigger,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astAttackerOf(")% %StateCheck(LastAttackerOf(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("PC\])")% %StateCheck([PC],STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("layer\([1-6]\))")% %StateCheck(Player\1,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %ApplySpell("runrun",0)% %ApplySpellRES("runrun",Myself)%
    REPLACE_TEXTUALLY %AreaCheck("UTDOOR)")% %AreaType(OUTDOOR)%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("yself","SPFLESHS")% %CreateVisualEffectObject("SPFLESHS",Myself)%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT05C")% %AddXP2DA("PLOT5C")%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT05B")% %AddXP2DA("PLOT5B")%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT06E")% %AddXP2DA("PLOT6E")%
    REPLACE_TEXTUALLY %TakeItemReplace("DWDUST","DWCSW1H01"% %TakeItemReplace("DWDUST","DWSW1H01"%
    REPLACE_TEXTUALLY %"EFF_38"% %"EFF_M38"%
    REPLACE_TEXTUALLY %"ISC_03A"% %"MISC_03A"%
    REPLACE_TEXTUALLY %"ISC_15A"% %"MISC_15A"%
    REPLACE_TEXTUALLY %"ISC_15B"% %"MISC_15B"%
    REPLACE_TEXTUALLY %"MISC_02A"% %"MISC_02A"%
    REPLACE_TEXTUALLY %PlaySound("MONTR10")% %%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("DEMOSUM1","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("DEMOSUM1","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("DEMSUC01","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("DEMSUC01","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("TELALU1","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("TELALU1","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("ANCALL",Myself)% %CreateVisualEffectObject("AMCALL",Myself)%
    REPLACE_TEXTUALLY %MoveBetweenAreasEffect("AR3015","SPDOOR"% %MoveBetweenAreasEffect("AR3015","SPDIMNDR"%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("SPOWWRD",Player1)% %CreateVisualEffectObject("SPPOWWRD",Player1)%
    REPLACE_TEXTUALLY %CreateVisualEffect("SPMAGICH"% %CreateVisualEffect("ICMAGICH"%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("ppireni1","SPDIMNDR")% %CreateVisualEffectObject("SPDIMNDR","ppireni1")%
    REPLACE_TEXTUALLY %ActionOverride("Imoen",SetDialog\(ue\)?("None"))% %ActionOverride("Imoen",SetDialog(""))%
    REPLACE_TEXTUALLY %Dead("firkraag")% %Dead("firkra02")%
    REPLACE_TEXTUALLY %Dead("aran02")% %Dead("aran")%
    REPLACE_TEXTUALLY %MoveToObject("ammonk")% %MoveToObject("ammonk01")%
    REPLACE_TEXTUALLY %"Jaheria"% %"Jaheira"%
//    REPLACE_TEXTUALLY %CreateVisualEffectObject("SPSTRENH","OilDoor")% %CreateVisualEffectObject("SPSTRENH","Door07")%
    REPLACE_TEXTUALLY %See("Player1")% %See(Player1)%
    REPLACE_TEXTUALLY %ActionOverride("Player\([2-6]\)",Rest())% %ActionOverride(Player\1,Rest())%
    REPLACE_TEXTUALLY %StateCheck("Player1",STATE_SLEEPING)% %StateCheck(Player1,STATE_SLEEPING)%
    REPLACE_TEXTUALLY %CreateCreature("dogre01",\[-1\.-1\],0)% %CreateCreature("ogre01",[-1.-1],0)%
    REPLACE_TEXTUALLY %CreateVisualEffect("SPGFLSH"% %CreateVisualEffect("SPGFLSH1"%
    REPLACE_TEXTUALLY %Spell(Myself,WIZARD_LIGHTNING_BOLT)% %Spell(NearestEnemyOf(Myself),WIZARD_LIGHTNING_BOLT)%
    REPLACE_TEXTUALLY %Global("R0406PitFight","",3)% %Global("PitFight","AR0406",3)%
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// eou romance fixes                                \\\\\
/////                                                  \\\\\

//COMPILE     ~ease/romhap/rom/JAGALVAR.D~      now in soa-dlg.d
COPY_EXISTING ~aerie.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AreaType(0)~ ~AreaType(OUTDOOR)~
  COMPILE_BAF_TO_BCS


COPY_EXISTING ~anomen.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("AnomenIsNotKnight","GLOBAL",1)~
      ~SetGlobal("AnomenIsNotKnight","GLOBAL",1)
      ChangeAlignment("Anomen",CHAOTIC_NEUTRAL)~
    REPLACE_TEXTUALLY ~"TALKEDTOCOR","GLOBAL"~ ~"TALKEDCOR","GLOBAL"~
  COMPILE_BAF_TO_BCS
EXTEND_TOP ~anomen.bcs~ ~bg2fixpack/baf/anomen.baf~

COPY_EXISTING ~jaheira.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GlobalLT("DerminSpawn","GLOBAL",5)~
      ~  GlobalLT("DerminSpawn","GLOBAL",5)
        !InParty(Myself)
      THEN
        RESPONSE #100
          RealSetGlobalTimer("JaheiraRomance","GLOBAL",3600)
          SetGlobal("DerminSpawn","GLOBAL",5)
          SetGlobalTimer("DerminAppear","GLOBAL",17280)
          StartDialogueNoSet([PC])
      END

      IF
        False()~
    REPLACE_TEXTUALLY ~\bSetGlobalTimer("TerminselAppear","GLOBAL",FIVE_DAYS)~
                      ~RealSetGlobalTimer("TerminselAppear","GLOBAL",3600)~ // originally 36000 seems to be more than random.
  COMPILE_BAF_TO_BCS

COPY_EXISTING ~viconia.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("LoveTalk","LOCALS",71)~ ~False()~
  COMPILE_BAF_TO_BCS

// If ToB installed, patch ToB BCS files:
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~anom25.BCS~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~Global("AnomenSummoned","GLOBAL",1)~
      ~Global("AnomenSummoned","GLOBAL",1)
      !Global("AnomenIsKnight","GLOBAL",1)~
    COMPILE_BAF_TO_BCS
  EXTEND_TOP ~anom25.bcs~ ~bg2fixpack/baf/anom25.baf~

  COPY_EXISTING ~jahe25.BCS~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~OR(2)~ ~!Global("JaheiraRomanceActive","GLOBAL",0) !Global("JaheiraRomanceActive","GLOBAL",3) OR(2)~
    COMPILE_BAF_TO_BCS

END

/////                                                  \\\\\
///// missing IDS entries                              \\\\\
/////                                                  \\\\\

// notes
// unused in BG2: andris, ch1cut01, ch1cut02, daitel, deathkni, hgwiz01, pheoarch, semaj
// SpellCast(0) is needed for CW summoning in ar0020, ar0300, ar0400, ar0500, ar0700, ar0900, ar1000
// SpellCastOnMe([ANYONE],0) is needed for nishru01; nishruus heal themselves when magic is used against them
// cdtamoko error is from cloning gpkensai
// specifics errors safe to ignore (?)
// SpellCast([PC],0) for ttxan is appropriate for tutorial


// many dispel magic actions have two missing CheckStatGT triggers in an OR() block
COPY_EXISTING ~abazdrag.bcs~ ~override~
              ~amlich02.bcs~ ~override~
              ~dragbrow.bcs~ ~override~
              ~finsol04.bcs~ ~override~
              ~gorgua02.bcs~ ~override~
              ~meliss01.bcs~ ~override~
              ~meliss02.bcs~ ~override~
              ~meliss03.bcs~ ~override~
              ~planet.bcs~   ~override~
              ~senbattl.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~CheckStatGT(LastSeenBy(Myself),0,0)[%tab% %lnl%%mnl%%wnl%]+CheckStatGT(LastSeenBy(Myself),0,0)~
                     ~CheckStatGT(LastSeenBy(Myself),0,IMPROVEDHASTE) CheckStatGT(LastSeenBy(Myself),0,STONESKINS)~
                     // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// many priest scripts have a failed CLERIC_HEAL call
COPY_EXISTING ~aeriex.bcs~   ~override~
              ~anomx.bcs~    ~override~
              ~anvskel.bcs~  ~override~
              ~pries18a.bcs~ ~override~
              ~pries18b.bcs~ ~override~
              ~pries18c.bcs~ ~override~
              ~pries18d.bcs~ ~override~
              ~saerkx.bcs~   ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// alter missing areatype check to match banter trigger
COPY_EXISTING ~aerie.bcs~   ~override~
              ~anomen.bcs~  ~override~
              ~minsc.bcs~   ~override~
              ~nalia.bcs~   ~override~
              ~yoshimo.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~AreaType(0)~ ~AreaType(OUTDOOR)~ // for Minsc Umar Hills reminder, Nalia-Edwina banter
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// aerie's very straightforward--both missing Spell calls check for a spell in memory in the trigger
COPY_EXISTING ~aeriex.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// recurring issue--going to enemy, but checks that allegiance is either neutral, goodbutblue, or ?
COPY_EXISTING ~amduel1.bcs~  ~override~
              ~amduel2.bcs~  ~override~
              ~balmonk.bcs~  ~override~
              ~chalpc01.bcs~ ~override~
              ~gorbat.bcs~   ~override~
              ~gorbat1.bcs~  ~override~
              ~gortan.bcs~   ~override~
              ~gortan1.bcs~  ~override~
              ~gparcher.bcs~ ~override~
              ~gphealer.bcs~ ~override~
              ~gpkensai.bcs~ ~override~
              ~gpmage1.bcs~  ~override~
              ~gpmage2.bcs~  ~override~
              ~gpshout.bcs~  ~override~
              ~grpsht01.bcs~ ~override~
              ~sarbul01.bcs~ ~override~
              ~sarbul02.bcs~ ~override~
              ~sarbul03.bcs~ ~override~
              ~sardw01.bcs~  ~override~
              ~sardw02.bcs~  ~override~
              ~sardw03.bcs~  ~override~
              ~sarrein.bcs~  ~override~
              ~teltief3.bcs~ ~override~
              ~trgrd02.bcs~  ~override~
              ~trgrd03.bcs~  ~override~
              ~trgrdr01.bcs~ ~override~
              ~trgrdr02.bcs~ ~override~
              ~trgrdr03.bcs~ ~override~
              ~trgrdr04.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,EVILBUTBLUE)~ // third allegiance check?
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amlich02.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ForceSpell(Myself,0)~ ~ForceSpell(Myself,WIZARD_STONE_SKIN)~ // trigger, locals checks for stoneskins
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// anomen's very straightforward--missing Spell calls check for a spell in memory in the trigger
COPY_EXISTING ~anomx.bcs~   ~override~
              ~anvskel.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)[%tab% %lnl%%mnl%%wnl%]+AttackOneRound(LastSeenBy(Myself))~
                     ~Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING) AttackOneRound(LastSeenBy(Myself))~ // trigger checks for this spell
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)[%tab% %lnl%%mnl%%wnl%]+Continue()~ 
                     ~Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3) Continue()~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// pairing MI with trigger
COPY_EXISTING ~clone1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY 
      ~HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+Spell(Myself,WIZARD_MIRROR_IMAGE)\)~
      ~HaveSpell(WIZARD_MIRROR_IMAGE)\1~ // Spell action associated with this block casts WIZARD_MIRROR_IMAGE
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// end of CI Escape cutscene, everyone leaving
COPY_EXISTING ~cut01g.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ForceSpell(Myself,0)~
      ~ForceSpell(Myself,DRYAD_TELEPORT)~   // cast by CSCowl6 and 8
    REPLACE_TEXTUALLY 
      ~ForceSpell("CSImoen",DRYAD_TELEPORT)~ 
      ~ForceSpell("CSImoen",DRYAD_TELEPORT) ForceSpell(Myself,DRYAD_TELEPORT)~   // cast by CSCowl4 on Imoen, added to causes effects for self as well
    REPLACE_TEXTUALLY
      ~ForceSpell("CSIren",0)~ 
      ~ForceSpell("CSIren",DRYAD_TELEPORT) ForceSpell(Myself,DRYAD_TELEPORT)~ // cast by CSCowl7 on Irenicus, also makes CSCowl7 go away
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// all other cres are hasted with identical blocks to this one
COPY_EXISTING ~cut207c.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,CUTSCENE_HASTE)~ // all other creatures hasted in similar blocks
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// displays 'protection from energy' string without, uh, casting it
COPY_EXISTING ~dlich01.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,WIZARD_PROTECTION_FROM_ENERGY)~ // action immediately above is displaystring 'protection from energy'
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// saladrex's dispel block is missing a stat check and valid stat.ids refs
COPY_EXISTING ~gorsal.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~OR(8)\([%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_INVISIBLE)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_IMPROVEDINVISIBILITY)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_HASTED)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_BLESS)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_DRAWUPONHOLYMIGHT)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_BLUR)[%tab% %lnl%%mnl%%wnl%]+StateCheck(LastSeenBy(Myself),STATE_MIRRORIMAGE)[%tab% %lnl%%mnl%%wnl%]+\)CheckStatGT(LastSeenBy(Myself),0,0)\([%tab% %lnl%%mnl%%wnl%]+THEN\)~
                     ~OR(9) \1 CheckStatGT(LastSeenBy(Myself),0,IMPROVEDHASTE) CheckStatGT(LastSeenBy(Myself),0,STONESKINS) \2~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// gphealer should run away and heal themselves, but missing actual casting; two more unknown issues
COPY_EXISTING ~gphealer.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY 
     ~HaveSpell(\([A-Z_]+\))\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+RunAwayFrom(NearestEnemyOf(Myself),30)[%tab% %lnl%%mnl%%wnl%]+\)Spell(Myself,0)~ 
     ~HaveSpell(\1) \2 Spell(Myself,\1)~ //
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing a priest spell in their resist fear trigger
COPY_EXISTING ~gpmage1.bcs~  ~override~
              ~magehigh.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~SpellCastPriest(\[GOODCUTOFF\],0)~ ~SpellCastPriest([GOODCUTOFF],CLERIC_CLOAK_OF_FEAR)~ // only missing divine 'fear' spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// should attack Jon's minions until minions dead, then turn on party
COPY_EXISTING ~ishthf01.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,GOODBUTBLUE)~ // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell is preceded by stringhead
COPY_EXISTING ~jatermin.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,WIZARD_PROTECTION_FROM_NORMAL_MISSILES)~ // preceded by string
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// action dictates trigger
COPY_EXISTING ~jatermin.bcs~ ~override~
              ~mage20a.bcs~  ~override~
              ~mage20c.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_MAZE)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// should attack Jon's minions until minions dead, then turn on party
COPY_EXISTING ~jonthief.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,GOODBUTBLUE)~ // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// mage10d checks for buffing spells; remove fear appears to fit the gap between bless and sanctuary
COPY_EXISTING ~mage10d.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~SpellCastPriest(\[PC\],0)~ ~SpellCastPriest([PC],CLERIC_REMOVE_FEAR)~ // triggers are for party buffs
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell trigger is followed by casting spell
COPY_EXISTING ~mage16m.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_STONE_SKIN)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell is preceded by stringhead
COPY_EXISTING ~mage8d.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_CHROMATIC_ORB)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// trigger defines spell
COPY_EXISTING ~senbattl.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,WIZARD_STONE_SKIN)~ // associated trigger checks this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw2.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(IncrementGlobal("Fight","LOCALS",1)[%tab% %lnl%%mnl%%wnl%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // from surakw4
    REPLACE_TEXTUALLY ~\(StateCheck(Myself,STATE_SILENCED)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_VOCALIZE)~ // if silenced - vocalize?
    REPLACE_TEXTUALLY ~\(!See(LastSeenBy(Myself))[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_TRUE_SIGHT)~ // if can detect but not see - true sight?
    REPLACE_TEXTUALLY
      ~ApplySpell(Myself,0)\([%tab% %lnl%%mnl%%wnl%]+DisplayString(Myself,39968)[%tab% %lnl%%mnl%%wnl%]+\)ApplySpell(Myself,0)~
      ~ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \1 ApplySpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // two spell spell trigger
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw3.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)\([%tab% %lnl%%mnl%%wnl%]+DisplayString(Myself,39968)[%tab% %lnl%%mnl%%wnl%]+\)ApplySpell(Myself,0)\([%tab% %lnl%%mnl%%wnl%]+\)ApplySpell(Myself,0)~
       ~ApplySpell(Myself,WIZARD_STONE_SKIN) \1 ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \2 ApplySpell(Myself,WIZARD_MISLEAD)~ // from surakw4
   REPLACE_TEXTUALLY ~\(IncrementGlobal("Fight","LOCALS",1)[%tab% %lnl%%mnl%%wnl%]+\)ForceSpell(Myself,0)~
       ~\1 ForceSpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // from surakw4
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw4.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)\([%tab% %lnl%%mnl%%wnl%]+DisplayString(Myself,39968)[%tab% %lnl%%mnl%%wnl%]+\)ApplySpell(Myself,0)\([%tab% %lnl%%mnl%%wnl%]+\)ApplySpell(Myself,0)~
       ~ApplySpell(Myself,WIZARD_STONE_SKIN) \1 ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \2 ApplySpell(Myself,WIZARD_MISLEAD)~ // three spell spell trigger
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// viccy's combat script for keldorn fight
COPY_EXISTING ~vicvskel.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~
   REPLACE_TEXTUALLY ~\(HPGT("Keldorn",20)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING)~
   REPLACE_TEXTUALLY ~\(HaveSpell(CLERIC_ANIMAL_SUMMONING_3)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// viccy's generic combat script
COPY_EXISTING ~vicx.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~
   REPLACE_TEXTUALLY ~\(HPGT(NearestEnemyOf(Myself),20)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING)~
   REPLACE_TEXTUALLY ~\(HaveSpell(CLERIC_ANIMAL_SUMMONING_3)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// other scripting fixes                            \\\\\
/////                                                  \\\\\

// norh rep trap uses same name for timer and variable; see fixes to knight.dlg
COPY_EXISTING ~amntrp01.bcs~ ~override~
              ~amntrp02.bcs~ ~override~
              ~amntrp03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!GlobalTimerNotExpired("MostNobleOrder","GLOBAL")~ ~!GlobalTimerNotExpired("CDMostNobleOrder","GLOBAL")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Puts the variable setting in front of the dialogue triggering so that Anomen's complaint about delaying Garren kid's quest gets triggered
// also add triggers to stop infinite whining if anomen is !good
COPY_EXISTING ~anomen.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(StartDialogu?e?NoSet(Player1)[%tab% %lnl%%mnl%%wnl%]+\)\(SetGlobal("ddAnomenWhine","LOCALS",1)\)~
      ~\2 \1~
    REPLACE_TEXTUALLY ~Global("ddAnomenWhine","LOCALS",0)~ ~Global("ddAnomenWhine","LOCALS",0) !Dead("garkid01") !Dead("garkid02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// flydian shouldn't hang around asking folks to save trademeet after it's already been saved
EXTEND_BOTTOM ~ar0020.bcs~ ~bg2fixpack/baf/ar0020.baf~

// UE not appearing bug
COPY_EXISTING ~ar0202.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UnseeingEye","GLOBAL",1)~ ~Global("UnseeingEye","GLOBAL",1) Global("CDSpawnTheEyeOnlyOnce","GLOBAL",0)~
    REPLACE_TEXTUALLY ~CreateCreature("BHEYE",\[2429\.1914\],0)~ ~CreateCreature("BHEYE",[2429.1914],0) SetGlobal("CDSpawnTheEyeOnlyOnce","GLOBAL",1)~
  COMPILE_BAF_TO_BCS

// instead of a wait, change to timer for new block
COPY_EXISTING ~ar0205.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("BHEYE",\[2528\.1897\],12)~ ~~
    REPLACE_TEXTUALLY ~Wait(~ ~SetGlobalTimer("CDUnseeingEyeAppears","AR0205",~
  COMPILE_BAF_TO_BCS
EXTEND_BOTTOM ~ar0205.bcs~ ~bg2fixpack/baf/ar0205.baf~

// fixing transition calls
COPY_EXISTING ~ar0300.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(TriggerActivation("Tran0329\)\(",[A-Z]+)\)~ ~\1a\2 \1b\2~
    REPLACE_TEXTUALLY ~Tran0303a~ ~Tran0303~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Arledrian goes hostile but stands there due to area script bug
COPY_EXISTING ~ar0312.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("ArledHostile","GLOBAL",1)~ ~SetGlobal("ArledHostile","AR0312",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// allows resting in thieves guild stronghold
EXTEND_BOTTOM ~ar0321.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0322.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0323.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0324.bcs~ ~bg2fixpack/baf/ar032x.baf~

// welther can spawn infinitely, Shagbag's always-true block disables half the area script
COPY_EXISTING ~ar0400.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("ElgeaGone","GLOBAL",0)~
                      ~Global("ElgeaGone","GLOBAL",0)
                       Global("ElgeaFree","GLOBAL",0)~
    REPLACE_TEXTUALLY ~[^!]GlobalTimerExpired("FindShagbag","GLOBAL")~
                      ~False()~
  COMPILE_BAF_TO_BCS
EXTEND_BOTTOM ~ar0400.bcs~ ~bg2fixpack/baf/ar0400.baf~

// stops Yoshimo's block from interrupting everything else in the area
COPY_EXISTING ~ar0406.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Global("WorkingForBodhi","GLOBAL",1)~ ~Global("WorkingForBodhi","GLOBAL",1) Exists("Yoshimo")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Teos/Planar Sphere fix
EXTEND_TOP ~ar0411.bcs~ ~bg2fixpack/baf/ar0411.baf~

// Tyrianna fix, part 1 (second is plgirl01.cre patch)
EXTEND_TOP ~ar0415.bcs~ ~bg2fixpack/baf/ar0415.baf~

// saerk's doors should lock and unlock together
COPY_EXISTING ~ar0500.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Unlock("DOOR0504")~ ~Unlock("DOOR0504") Unlock("DOOR0505b")~
    REPLACE_TEXTUALLY ~\bLock("DOOR0504")~ ~CloseDoor("DOOR0504") CloseDoor("DOOR0505b") Lock("DOOR0504") Lock("DOOR0505b")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// area objects can't have LOCALS variables
COPY_EXISTING ~ar0522.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SamuelAttacks","LOCALS"~ ~"SamuelAttacks","AR0522"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ar0701 shouldn't be able to trigger in ar0205, but it does
COPY_EXISTING ~ar0701.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~PartyHasItem("MISC5Z")~ 
      ~PartyHasItem("MISC5Z") InMyArea(Player1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// death of mekrath not clearing journal entries; see mekrat.dlg
EXTEND_BOTTOM ~ar0705.bcs~ ~bg2fixpack/baf/ar0705.baf~

// random Garrick stuff can prevent Bodhi's appearance
COPY_EXISTING ~ar0800.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("GarrickSpeak","GLOBAL",1)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  EXTEND_BOTTOM ~ar0800.bcs~ ~bg2fixpack/baf/ar0800.baf~

// bodhi broken if saved during her wait()-laden spawn; unstakable vampire fix
COPY_EXISTING ~ar0801.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("LassalVampires","GLOBAL",3)~ ~~
    REPLACE_TEXTUALLY ~CreateCreatureDoor("bodhi2",\[480\.1338\],14)~
      ~SetGlobal("LassalVampires","GLOBAL",3) CreateCreatureDoor("bodhi2",[480.1338],14)~
    APPEND_FILE ~bg2fixpack/baf/ar0801.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// allow cleric-rangers to acquire temple stronghold; see bharval.dlg, borinall.dlg, scsain.dlg, travin.dlg
COPY_EXISTING ~ar0900.bcs~ ~override~
              ~ar0902.bcs~ ~override~
              ~arval.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(5)\([%tab% %lnl%%mnl%%wnl%]+Class(Player1,CLERIC)[%tab% %lnl%%mnl%%wnl%]+Class(Player1,FIGHTER_CLERIC)[%tab% %lnl%%mnl%%wnl%]+Class(Player1,CLERIC_MAGE)[%tab% %lnl%%mnl%%wnl%]+Class(Player1,CLERIC_THIEF)[%tab% %lnl%%mnl%%wnl%]+Class(Player1,FIGHTER_MAGE_CLERIC)[%tab% %lnl%%mnl%%wnl%]+\)\(Alignment(Player1,MASK_GOOD)\)~
                      ~OR(6) \1 Class(Player1,CLERIC_RANGER) \2~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// telwyn HoG exploit fix, pt 2/2 (see sctelwyn.d)
EXTEND_BOTTOM ~ar0901.bcs~ ~bg2fixpack/baf/ar0901.baf~

// allows resting in paladin stronghold
EXTEND_BOTTOM ~ar0903.bcs~ ~bg2fixpack/baf/ar0903.baf~

// ar1002 should check tolgerias' alternate DV
COPY_EXISTING ~ar1002.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Dead("TOLGER")~
                      ~OR(2) Dead("TOLGER") Dead("TOLGER2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// terrece should only spawn if you speak to corneil, not just enter his area
COPY_EXISTING ~ar1000.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("TerreceSpawn","GLOBAL",1)~
                      ~Global("TerreceSpawn","GLOBAL",1) Global("TalkedToCorneil","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Ketlaar Argrim and his bodyguards go away from the Council building if he's imprisoned
EXTEND_BOTTOM ~ar1002.bcs~ ~bg2fixpack/baf/ar1002.baf~

// no escape from TR
EXTEND_BOTTOM ~ar1008.bcs~ ~bg2fixpack/baf/ar1008.baf~

// monster invincible items updated, need to update script to same
COPY_EXISTING ~ar1300.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("trolgi0\([12]\)",DestroyItem("MINHP1"))~
                      ~ActionOverride("trolgi0\1",DestroyItem("MINHP1")) ActionOverride("trolgi0\1",DestroyItem("MONHP1"))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// can't lure dead umber hulks; assigned kpumb01 DVs to make this work
COPY_EXISTING ~ar1301.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UmberHungry","AR1301",0)~ ~Global("UmberHungry","AR1301",0) NumDeadLT("KPUMB01",5)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fixes Glacias charm issue
COPY_EXISTING ~ar1303.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~[^,]ApplySpell("kpglai01",WIZARD_TRUE_DISPEL_MAGIC)~
                      ~ActionOverride("kpglai01",ApplySpell("kpglai01",FORCE_DISPEL_MAGIC))~
    REPLACE_TEXTUALLY ~[^,]ChangeEnemyAlly("kpglai01",NEUTRAL)~
                      ~ActionOverride("kpglai01",ChangeEnemyAlly(Myself,NEUTRAL))~
  COMPILE_BAF_TO_BCS

// spirit doesn't escape area due to bad DV call
COPY_EXISTING ~ar1400.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("rspirit1"~ ~ActionOverride("rspirit01"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// enables container in shade lord dungeon; see shaava01.dlg
COPY_EXISTING ~ar1401.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetGlobal("Deactivate","AR1401",1)~
    ~SetGlobal("Deactivate","AR1401",1)
     ContainerEnable("CONTAINER2",FALSE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// more shadow fiends don't spawn due to DV typo
COPY_EXISTING ~ar1404.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"shdafi01"~ ~"shadfi01"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// asylum script bugs
COPY_EXISTING ~ar1515.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("ppattackedJon","GLOBAL",1)~
                      ~Global("ppattackedJon","GLOBAL",1)
                       Global("WackoArmy","GLOBAL",0)~
    REPLACE_TEXTUALLY ~Global("PPdeshSend","GLOBAL",0)~
                      ~OR(2)
                         Global("PPdeshSend","GLOBAL",0)
                         Global("PirateRefused","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
UNLESS ~PirateRefused~

// Brynnlaw initial vamp fight should check for non-existence not dead (revised by Ardanis)
COPY_EXISTING ~ar1600.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
	REPLACE_TEXTUALLY ~Dead("ppvalen")
  Dead("ppparis")
  Dead("ppdel")~
 ~Global("ThiefGroup","global",1) // only trigger if the party has sided with the Shadow Thieves
  !Exists("ppvalen")
  !Exists("ppparis")
  !Exists("ppdel")~
  COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES

// multiple rerdes due to bad var scope
COPY_EXISTING ~ar1613.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SpawnCaptain","AR1613"~ ~"SpawnCaptain","GLOBAL"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Jenia will wait until PC officially hero of trademmet
COPY_EXISTING ~ar2000.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Global("JeniaSpawn","AR2000",0)~
    ~Global("JeniaSpawn","AR2000",0)
     Global("loganjob2","GLOBAL",2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// no-repeat Drizzt
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB, much easier thanks to new action

  COPY_EXISTING ~ar2601.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~"DrizztEncounter","AR2601"~ ~"DrizztEncounter","GLOBAL"~
      REPLACE_TEXTUALLY ~Explore()~ ~Explore()
SetEncounterProbability("AR2500","AR0020",0)
SetEncounterProbability("AR2500","AR1300",0)
SetEncounterProbability("AR2500","AR1304",0)
SetEncounterProbability("AR2500","AR1700",0)~
    COMPILE_BAF_TO_BCS
    BUT_ONLY_IF_IT_CHANGES
  
END ELSE BEGIN // SoA

  COPY_EXISTING ~ar2601.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
    COMPILE_BAF_TO_BCS
    BUT_ONLY_IF_IT_CHANGES
  COPY_EXISTING ~ar0043.bcs~ ~override~
  EXTEND_BOTTOM ~ar2601.bcs~ ~override/ar0043.bcs~

END

// alignment change if evil path in hell trials; other fixes in teardoor.bcs
EXTEND_BOTTOM ~ar2900.bcs~ ~bg2fixpack/baf/ar2900.baf~

// script changes to ensure paladins/rangers fall in Hell tests; also closing selfish exploits
EXTEND_BOTTOM ~ar2901.bcs~ ~bg2fixpack/baf/ar2901.baf~
EXTEND_BOTTOM ~ar2902.bcs~ ~bg2fixpack/baf/ar2902.baf~
EXTEND_BOTTOM ~ar2903.bcs~ ~bg2fixpack/baf/ar2903.baf~
COPY_EXISTING ~ar2904.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("PaladinGone","AR2904"~ ~Global("AbyssPaladinGone","GLOBAL"~
    REPLACE_TEXTUALLY ~Global("RangerGone","AR2904"~  ~Global("AbyssRangerGone","GLOBAL"~
    REPLACE_TEXTUALLY ~Class(Player1,RANGER_ALL)~  ~Class(Player1,RANGER_ALL) !Class(Player1,CLERIC_RANGER)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR03",TRUE)\)~ ~\1 Global("OpenedDoor1","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR04",TRUE)\)~ ~\1 Global("OpenedDoor2","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR05",TRUE)\)~ ~\1 Global("OpenedDoor3","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR06",TRUE)\)~ ~\1 Global("OpenedDoor4","AR2904",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_BOTTOM ~ar2905.bcs~ ~bg2fixpack/baf/ar2905.baf~

// tries to remove override scripts for knights before killing them
COPY_EXISTING ~ar3020.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAIScript("one",OVERRIDE))~ ~ChangeAIScript("",OVERRIDE))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removing call to nonexistent trigger
COPY_EXISTING ~ar3021.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TriggerActivation("OilDoor",FALSE)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Viccy can romance half-orcs; multi-brus fixes
COPY_EXISTING ~baldur.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Race(Player1,0)~ ~Race(Player1,HALFORC)~
    REPLACE_TEXTUALLY ~Global("SpawnBrus","GLOBAL",1)~ 
      ~Global("SpawnBrus","GLOBAL",1) Global("CHAPTER","GLOBAL",2) !AreaCheck("AR0800") !AreaCheck("AR2000") CombatCounter(0)~
    REPLACE_TEXTUALLY ~CreateCreatureObjectOffScreen("BRUS3",Player1,0,0,0)~
      ~CreateCreatureObjectOffScreen("BRUS3",Player1,0,0,0) SetGlobal("SPAWNBRUS","GLOBAL",2)~
  COMPILE_BAF_TO_BCS

// drow item exploits closed
EXTEND_BOTTOM ~baldur.bcs~ ~bg2fixpack/baf/baldur.baf~

// cespy's handing out undercharged items
COPY_EXISTING ~botsmith.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GiveItemCreate("clck31",Player1,0,0,0)~ ~GiveItemCreate("clck31",Player1,1,1,0)~
    REPLACE_TEXTUALLY ~GiveItemCreate("sw1h69",Player1,0,0,0)~ ~GiveItemCreate("sw1h69",Player1,0,1,1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~BRANNEL.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("LathanPlot1","GLOBAL",1)~ ~Global("LathanPlot","GLOBAL",1)~
    REPLACE_TEXTUALLY ~Global("LathanPlot2","GLOBAL",1)~ ~Global("LathanPlot","GLOBAL",2)~
    REPLACE_TEXTUALLY ~StartDialog\(ue\)?NoSet(Myself)~  ~StartDialogueNoSet(Player1)~
  COMPILE_BAF_TO_BCS

// valen's premature death prevents Del changing from bat form and attacking
COPY_EXISTING ~c6valen.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpellDead(Myself,VALEN_MIST_FORM_CHANGE)~
      ~SetGlobal("ValenFight","AR0808",1) ReallyForceSpellDead(Myself,VALEN_MIST_FORM_CHANGE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// remove minhp1 for a moment to allow bodhi's str decrease to take effect
COPY_EXISTING ~c6bweak.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ApplySpell(Myself,C6BODHI_WEAKNESS)~
                      ~TakeItemReplace("monhp1","minhp1",Myself) ApplySpell(Myself,C6BODHI_WEAKNESS) TakeItemReplace("minhp1","monhp1",Myself)~
    REPLACE_TEXTUALLY ~DestroyItem("VAMPREG3")~ ~DestroyItem("VAMPREG2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cadril's script using wrong DVs for Cyrando and Irlana
COPY_EXISTING ~cadril.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"tcyrando"~ ~"cyrando"~
    REPLACE_TEXTUALLY ~"tirlana"~ ~"irlana"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Cernd goes hostile if Grove poisoned
EXTEND_BOTTOM ~cernd.bcs~ ~bg2fixpack/baf/cernd.baf~

// trolls giving double XP if slain by instant-death spell
COPY_EXISTING ~chaltrol.bcs~ ~override~ // giant troll, challenge
              ~dgtrol01.bcs~ ~override~ // troll, druid grove
              ~firamb03.bcs~ ~override~ // fire troll
              ~hgtrl01.bcs~  ~override~ // fire troll
              ~rogtro01.bcs~ ~override~ // roger's sea troll
              ~trolde01.bcs~ ~override~ // desert troll
              ~trolfr01.bcs~ ~override~ // freshwater troll
              ~trolgi01.bcs~ ~override~ // giant troll
              ~trolic01.bcs~ ~override~ // ice troll
              ~trolic03.bcs~ ~override~ // blizzard troll
              ~troll01.bcs~  ~override~ // generic troll
              ~trolsi01.bcs~ ~override~ // spirit troll
              ~trollsm2.bcs~ ~override~ // small troll - lacking timers and such
              ~trolsn01.bcs~ ~override~ // snow troll
              ~trolsp01.bcs~ ~override~ // spectral troll
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HPLT(Myself,\([0-9]+\))~ ~!StateCheck(Myself,STATE_REALLY_DEAD) HPLT(Myself,\1)~
    PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "trolfr01" = 0) BEGIN // extra fix for freshwater troll
      REPLACE_TEXTUALLY ~"TROLGI02"~ ~"trolfr02"~ // freshwater trolls becoming giant trolls when knocked down
    END
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cromwell cutscene; removes multi-forged item bug
COPY_EXISTING ~cromwell.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId("wsmith01")~ ~CutSceneId("wsmith01") ClearAllActions()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~ctaltar.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"PortalOpen","GLOBAL"~ ~"PortalOpen","AR3001"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removes call to nonexistent cre file
COPY_EXISTING ~cut31q.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("bdcoun04",\[592\.825\],10)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fix cutscene for departing Amn
COPY_EXISTING ~cut41d.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("pparan2",DestroySelf())~
                      ~ActionOverride("aran",DestroySelf())~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES


// rest commands not executed due to DayNight flakiness
COPY_EXISTING ~cut41c.bcs~ ~override~
              ~cut41d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~[^,]Rest()~
                      ~Wait(1)
                      Rest()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// part of desharik's xp exploit fix, see ppdesh in the d file
COPY_EXISTING ~cut41f.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetGlobal("EnteredArea1500","GLOBAL",1)~
    ~SetGlobal("EnteredArea1500","GLOBAL",1)
     AddXPObject(Player1,38500)
     AddXPObject(Player2,38500)
     AddXPObject(Player3,38500)
     AddXPObject(Player4,38500)
     AddXPObject(Player5,38500)
     AddXPObject(Player6,38500)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// familiars and summons should be pushed back when hell door opens
COPY_EXISTING ~Cut85A.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~ActionOverride("HELLSPY4",ApplySpell(Player[1-6],HELL_BUFFET))~ ~~
  REPLACE_TEXTUALLY ~ActionOverride("hellspy4",ApplySpell(\[FAMILIAR\],HELL_BUFFET))~ ~ActionOverride("HELLSPY4",ForceSpell(Player1,HELL_BUFFET))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ust natha scenery cutscene can occur offscreen, meaning player stands in dark for no apparent reason
COPY_EXISTING ~dadrow20.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~StartCutSceneMode()~
      ~StartCutSceneMode() CreateCreature("cutspy",[3864.273],0) MoveViewPoint([3864.273],INSTANT)~
    REPLACE_TEXTUALLY ~EscapeArea()~
      ~EscapeArea() ActionOverride("cutspy",DestroySelf()) MoveViewObject(Player1,INSTANT)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// delon's script using wrong variable for talking to Lloyd; had EscapeArea() issues
COPY_EXISTING ~delon.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TalkedToMayor~ ~TalkedToLloyd~
    REPLACE_TEXTUALLY ~OR(4)[%tab% %lnl%%mnl%%wnl%]+Global("Acceptance","GLOBAL",1)~ ~OR(3)~
    REPLACE_TEXTUALLY ~AreaCheck("AR1000")~ ~~
    REPLACE_TEXTUALLY ~GlobalTimerExpired("MinscDelon","GLOBAL")~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/delon.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// restore Nith's attack script, pt 1: false() out stuff that'll break
COPY_EXISTING ~drshnl01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HPLT(Myself,10)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// new troll scripts to transform to dead versions at low HP
COPY_EXISTING ~troll01.bcs~ ~override/drshnl11.bcs~
              ~troll01.bcs~ ~override/eletro03.bcs~
              ~troll01.bcs~ ~override/kptrol23.bcs~
              ~troll01.bcs~ ~override/pptroll2.bcs~
              ~troll01.bcs~ ~override/sutroll2.bcs~
              ~troll01.bcs~ ~override/torgal2.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLL02")~ ~ChangeAnimationNoEffect("%DEST_RES%")~
  COMPILE_BAF_TO_BCS

// duplicates functionality, but needed for ub compatibility
EXTEND_TOP ~drshnl01.bcs~ ~override/drshnl11.bcs~

// new troll scripts to transform from dead to alive after time expires
COPY_EXISTING ~troll02.bcs~ ~override/drshnl21.bcs~
              ~troll02.bcs~ ~override/eletro01.bcs~
              ~troll02.bcs~ ~override/kptrol13.bcs~
              ~troll02.bcs~ ~override/pptroll1.bcs~
              ~troll02.bcs~ ~override/sutroll.bcs~
              ~troll02.bcs~ ~override/torgal3.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_CHANGE)~ ~ReallyForceSpellRES("%DEST_RES%",Myself)~
  COMPILE_BAF_TO_BCS

// edwin soundset issues for transformation
COPY_EXISTING ~edwin.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30716,SELECT_ACTION4)~ ~SetPlayerSound(Myself,30715,SELECT_ACTION4)~
  REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30717,SELECT_ACTION5)~ ~SetPlayerSound(Myself,3984,SELECT_ACTION5)~
  REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30718,SELECT_ACTION6)~ ~SetPlayerSound(Myself,3985,SELECT_ACTION6)~
  REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30719,SELECT_ACTION7)~ ~SetPlayerSound(Myself,3986,SELECT_ACTION7)~
  COMPILE_BAF_TO_BCS

// containers can summon guards days after they're open
COPY_EXISTING ~enforam.bcs~ ~override~
              ~tempv01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)[%tab% %lnl%%mnl%%wnl%]+!See(\[NOTGOOD\])[%tab% %lnl%%mnl%%wnl%]+Global("warn","LOCALS",1)~ 
      ~GlobalTimerExpired("CDGoAway","LOCALS")~
    REPLACE_TEXTUALLY ~Global("warn","LOCALS",0)~ ~Global("warn","LOCALS",0) GlobalTimerNotExpired("CDGoAway","LOCALS")~
    REPLACE_TEXTUALLY ~Wait(5)~ ~~
    REPLACE_TEXTUALLY ~See(\[NEUTRAL\])~ ~See([NEUTRAL.HUMANOID])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~enforam.bcs~ ~bg2fixpack/baf/enforam.baf~
EXTEND_TOP ~tempv01.bcs~ ~bg2fixpack/baf/enforam.baf~

// add slight delay so Anomen can comment on dead Windspear knights before Garren
COPY_EXISTING ~garren.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(GlobalLT("DomainPaladinBattle","GLOBAL",4)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100\)[%tab% %lnl%%mnl%%wnl%]+\(StartDialogu?e?NoSet(Player1)\)~
      ~\1 Wait(1) \2~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// double Garren Windspears
EXTEND_TOP ~garren.bcs~ ~bg2fixpack/baf/garren.baf~

// animals shold not run away from druids, elves, and rangers
COPY_EXISTING ~genshy.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(3)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// other gladiators should do something when Hendak does
COPY_EXISTING ~glad2782.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Dead("Hendak")~
  ~OR(2)
   Dead("Hendak")
   Allegiance("Hendak",255)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_BOTTOM ~glad2782.bcs~ ~bg2fixpack/baf/glad2782.baf~

// gorf the squisher fixes
COPY_EXISTING ~gorf.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetGlobal("GoKillEm","LOCALS",2)~
                    ~SetGlobal("GoKillEm","LOCALS",2)
                    SetGlobal("GorfBystander","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevents Tamoko from running away and making PP challenge unfinishable, see chtaz02.cre for other half
COPY_EXISTING ~gpkensai.bcs~ ~override/cdtamoko.bcs~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~!HasItem("POTN55",Myself)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// move grae's minhp1 destruction to dialogue options where she dies; see soa-dlg.d for rest of changes
COPY_EXISTING ~grae.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~DestroyItem("minhp1")~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// lesser clay golems in CI can be killed twice
COPY_EXISTING ~igolfle1.bcs~ ~override~
              ~igolfle2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("Ellsime","AR0602",1)~ ~Global("Ellsime","AR0602",1) !StateCheck(Myself,STATE_REALLY_DEAD)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// ilyich actually wears his imported armor
EXTEND_BOTTOM ~ilyich.bcs~ ~bg2fixpack/baf/ilyich.baf~

// sahugin spectre should only kill one party member and then escape
COPY_EXISTING ~impches3.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!Global("ImpRiddle","GLOBAL",3)~ ~!Global("ImpRiddle","GLOBAL",3) Global("CDImpChest","AR2300",0)~
    REPLACE_TEXTUALLY ~Kill(LastTrigger)~ ~Kill(LastTrigger) SetGlobal("CDImpChest","AR2300",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Arkanis Gath should not spawn and kill the PC post-Bynnlaw
EXTEND_TOP ~killpc.bcs~ ~bg2fixpack/baf/killpc.baf~

// should be able to steal at Lathander temple if invisible
COPY_EXISTING ~LATHALRM.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// lavok dying too early because of this cheese script
// False()d rather than unassigned in case someone wants to use this for lavok02-specific scripting
COPY_EXISTING ~lavok02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!HasItem("MINHP1",Myself)~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/lavok02.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// madeen should go away if Tolgerias dead--check for other DV
EXTEND_TOP ~madeen.bcs~ ~bg2fixpack/baf/madeen.baf~

// mazzy only goes hostile if Valygar is hostile and not charmed
COPY_EXISTING ~mazzy.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance("Valygar",ENEMY)~
                      ~Allegiance("Valygar",ENEMY)
                      !StateCheck("Valygar",STATE_CHARMED)~
    REPLACE_TEXTUALLY ~OR(2)[ %lnl%%mnl%%wnl%]+Dead("gorf")[ %lnl%%mnl%%wnl%]+Dead("gorf03")~ ~Dead("gorf")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// disables Gath spawn from mvally
COPY_EXISTING ~mvally.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~mvally.bcs~ ~bg2fixpack/baf/mvally.baf~

// disables Gath spawn from mvally2
COPY_EXISTING ~mvally2.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AttackedBy(\[GOODCUTOFF\],DEFAULT)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~mvally2.bcs~ ~bg2fixpack/baf/mvally2.baf~

// asylum crushing trap hitting wrong folks
COPY_EXISTING ~ppcrus1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!StateCheck(LastTrigger,STATE_REALLY_DEAD)~ ~False()~
    REPLACE_TEXTUALLY ~StateCheck(LastTrigger,STATE_REALLY_DEAD)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// emphatic manifestation can be killed by resting outside
EXTEND_TOP ~riftcr04.bcs~ ~bg2fixpack/baf/riftcr04.baf~

// fixes breaking bridge in UE quest
COPY_EXISTING ~riftg01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~!Dead("Riftcr0[23]")~ ~False()~
  REPLACE_TEXTUALLY ~!Dead("Riftcr01")~ ~Dead("Riftcr01")~
  REPLACE_TEXTUALLY ~!Exists("Riftcr01")~
  ~CombatCounter(0)
  OR(2)
     !Exists("Riftcr03")
     Dead("Riftcr03")
  OR(2)
     !Exists("Riftcr02")
     Dead("Riftcr02")
   OR(2)
     !Exists("Riftcr01")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// amalas' buddies should leave together if you kill him
COPY_EXISTING ~rufpal.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global(\("itFight","R0406P"\|"R0406PitFight",""\),3)~ ~Global("PitFight","AR0406",3)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sardw01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SaradushAmbientInsults","GLOBAL"~ ~"SaradushAmbientInsults","AR5000"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ring of djinni summoning should destroy ring if djinni dies
EXTEND_TOP ~sumdj01.bcs~ ~bg2fixpack/baf/sumdj01.baf~

// avatar of rilifane xp exploit fix
COPY_EXISTING ~sustatue.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Contains("MISCB3",Myself)~
      ~Contains("MISCB3",Myself) Global("CDNoRepeat","AR2803",0)~
    REPLACE_TEXTUALLY ~TriggerActivation("Tran2800",FALSE)~
      ~SetGlobal("CDNoRepeat","AR2803",1) TriggerActivation("Tran2800",FALSE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// alignment change if evil path in hell trials; other fixes in ar2900.bcs
EXTEND_TOP ~teardoor.bcs~ ~bg2fixpack/baf/teardoor.baf~

// stops Terrece from initiating dialogue from outside
COPY_EXISTING ~terrece.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Global("TerreceSpawn","GLOBAL",2)~ ~Global("TerreceSpawn","GLOBAL",2) See([PC])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// multiple ring of the ram exploit fixes
EXTEND_TOP ~tolger.bcs~ ~bg2fixpack/baf/tolger.baf~

// summoned juggernaut golem shouldn't die instantly if summoned by clone
COPY_EXISTING ~tomegol4.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!CheckStatGT(Player1,0,STONESKINSGOLEM)~ ~!CheckStatGT(LastSummonerOf(Myself),0,STONESKINSGOLEM) !CheckStatGT(Player1,0,STONESKINSGOLEM)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removes bug of losing rogue stone if reloaded
COPY_EXISTING ~tran1008.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TakePartyItem("MISC45")~ ~~
    REPLACE_TEXTUALLY ~ActionOverride(Player1,LeaveAreaLUAPanic("AR1008","",\[495\.755\],10))~
                      ~ActionOverride(Player1,LeaveAreaLUAPanic("AR1008","",[495.755],10))
                      TakePartyItem("MISC45")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
 
// trrakxx should have dialogue when attacked
COPY_EXISTING ~TrRak01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~AttackedBy(\[ANYONE\],DEFAULT)~ ~Global("attacked","LOCALS",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

EXTEND_TOP ~TrRak01.bcs~ ~bg2fixpack/baf/TrRak01.baf~

// endless Ust Natha tavern combat music
COPY_EXISTING ~ucounter.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF 
    REPLACE_TEXTUALLY ~SetGlobal("HaltMusicWithLesaonar","GLOBAL",0)~ ~SetGlobal("HaltMusicWithLesaonar","GLOBAL",2)~
    REPLACE_TEXTUALLY ~\(CombatCounterLT(50)[%tab% %lnl%%mnl%%wnl%]+Global("HaltMusicWithLesaonar","GLOBAL",\)0)~ ~\12)~
    APPEND_FILE ~bg2fixpack/baf/ucounter.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevent journal entry for already-openeed UD illithid doors
COPY_EXISTING ~uddoor2.bcs~ ~override~
              ~uddoor3.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("thrallDoorMes","AR2400",0)~  ~Global("thrallDoorMes","AR2400",0)  Global("thrallDoorOpen","AR2400",0)~
    REPLACE_TEXTUALLY ~Global("thrallDoorMes2","AR2400",0)~ ~Global("thrallDoorMes2","AR2400",0) Global("thrallDoorOpen2","AR2400",0)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Ust Natha egg guards no longer see invisible folks
COPY_EXISTING ~udeggs.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GlobalTimerExpired("eggGuardDoesWarn","GLOBAL")~
                      ~GlobalTimerExpired("eggGuardDoesWarn","GLOBAL")
                      See([PC])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Killing war elves while escaping Underdark lets you kill the surface elves
COPY_EXISTING  ~c6elf.bcs~ ~override~
			 ~c6elhan.bcs~ ~override~
			 ~c6extra.bcs~ ~override~
			 ~c6gener.bcs~ ~override~
			 ~warsage.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Global("GoodElfKill","GLOBAL",0)~ ~GlobalLT("GoodElfKill","GLOBAL",2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// uhleave5 and 6 should be moving between areas, opening doors, etc.
COPY_EXISTING ~uhleave5.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~MoveToPointNoInterrupt(\[805\.407\])~ ~MoveToPointNoInterrupt([805.407]) Unlock("DOOR02") OpenDoor("DOOR02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~uhleave5.bcs~ ~BG2Fixpack/baf/uhleave5.baf~

COPY_EXISTING ~uhleave6.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~MoveToPointNoInterrupt(\[709\.301\])~ ~MoveToPointNoInterrupt([709.301]) Unlock("DOOR02") OpenDoor("DOOR02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~uhleave6.bcs~ ~BG2Fixpack/baf/uhleave6.baf~

// trap triggers can't check LOCALS variables; display different string if umber hulks already dead
EXTEND_TOP    ~umbpoly.bcs~ ~bg2fixpack/baf/umbpoly.baf~
COPY_EXISTING ~umbpoly.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UmbPoly","LOCALS",0)~ ~Global("UmbPoly","AR1301",0) NumDeadLT("KPUMB01",5)~
    REPLACE_TEXTUALLY ~"LOCALS"~ ~"AR1301"~
  COMPILE_BAF_TO_BCS
  REPLACE ~98765~ @142
  BUT_ONLY_IF_IT_CHANGES

// Valygar only goes hostile if mazzy is hostile and not charmed
// valygar goes hostile if something happens to hervo, but should leave the party first
COPY_EXISTING ~valygar.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance("Mazzy",ENEMY)~
                      ~Allegiance("Mazzy",ENEMY)
                      !StateCheck("Mazzy",STATE_CHARMED)~
    REPLACE_TEXTUALLY ~SetGlobal("vgAttackTheParty","LOCALS",1)~ ~SetGlobal("vgAttackTheParty","LOCALS",1) LeaveParty()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// Valygar leaving party in Slums can cause cutscene hang
COPY_EXISTING ~valyorb.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~IsOverMe("Valygar")~
      ~IsOverMe("Valygar") InParty("Valygar") IsValidForPartyDialogue("Valygar") !StateCheck("Valygar",STATE_SLEEPING)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevents viekang's double dialogue
COPY_EXISTING ~viekang.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("Attacked","LOCALS",0)~ ~Global("Attacked","LOCALS",0) !Global("ViekangSeesPC","LOCALS",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// closes Yoshimo exploit of resurrecting him after Spellhold
COPY_EXISTING ~yoshimo.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Kill(Myself)~
                      ~Kill(Myself)
                      LeaveParty()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB check

  // part of the multi-holy symbol exploit fix. Also needed: CDHLYSYM.spl, CDHLYSY2.spl, CDHLYSYM.itm, and clabpr02-04 changes.
  EXTEND_TOP ~baldur.bcs~   ~bg2fixpack/baf/holysym.baf~
  EXTEND_TOP ~baldur25.bcs~ ~bg2fixpack/baf/holysym.baf~

  // if killed directly via spell, fire trolls should do groovy death animations
  EXTEND_TOP ~hgtrl01.bcs~ ~bg2fixpack/baf/hgtrl01.baf~

  // moves LOCALS var set to local script instead of ar4500
  EXTEND_TOP ~keld25.bcs~ ~bg2fixpack/baf/keld25.baf~

  // sarevok soundset fixes
  EXTEND_BOTTOM ~sarev25.bcs~ ~bg2fixpack/baf/sarev25.baf~

END

/////                                                  \\\\\
///// area fixes                                       \\\\\
/////                                                  \\\\\

// adds new entrance points to wmp areas that don't have one already (second half of wmp fixes)
COPY_EXISTING ~ar1700.are~ ~override~
              ~ar1800.are~ ~override~
              ~ar2500.are~ ~override~
              ~ar2600.are~ ~override~
  READ_LONG 0x54 "actor_off"
  READ_LONG 0x5c "info_off"
  READ_LONG 0x60 "spawn_off"
  READ_LONG 0x68 "ent_off"
  READ_LONG 0x6c "ent_num"
  READ_LONG 0x70 "cont_off"
  READ_LONG 0x78 "item_off"
  READ_LONG 0x7c "vert_off"
  READ_LONG 0x84 "amb_off"
  READ_LONG 0x88 "var_off"
  READ_LONG 0xa0 "bmp_off"
  READ_LONG 0xa8 "door_off"
  READ_LONG 0xb0 "anim_off"
  READ_LONG 0xb8 "tiled_off"
  READ_LONG 0xbc "song_off"
  READ_LONG 0xc0 "rest_off"
  READ_LONG 0xc4 "note_off"
  PATCH_IF ("ar1700" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 3375
    SET "y_coord" = 142
  END ELSE
  PATCH_IF ("ar1800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 1325
    SET "y_coord" = 56
  END ELSE
  PATCH_IF ("ar2500" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 404
    SET "y_coord" = 125
  END ELSE
  PATCH_IF ("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 3856
    SET "y_coord" = 115
  END
  WRITE_LONG 0x6c ("%ent_num%" + 1)
  INSERT_BYTES "%ent_off%" 0x68
    WRITE_ASCII "%ent_off%" ~CDExit~ // entrance name
    WRITE_SHORT ("%ent_off%" + 0x20) "%x_coord%"
    WRITE_SHORT ("%ent_off%" + 0x22) "%y_coord%"
  PATCH_IF NOT ("%actor_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x54 ("%actor_off%" + 0x68)
  END
  PATCH_IF NOT ("%info_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x5c ("info_off" + 0x68)
  END
  PATCH_IF NOT ("%spawn_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x60 ("spawn_off" + 0x68)
  END
  PATCH_IF NOT ("%cont_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x70 ("cont_off" + 0x68)
  END
  PATCH_IF NOT ("%item_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x78 ("item_off" + 0x68)
  END
  PATCH_IF NOT ("%vert_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x7c ("vert_off" + 0x68)
  END
  PATCH_IF NOT ("%amb_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x84 ("amb_off" + 0x68)
  END
  PATCH_IF NOT ("%var_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x88 ("var_off" + 0x68)
  END
  PATCH_IF NOT ("%bmp_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xa0 ("bmp_off" + 0x68)
  END
  PATCH_IF NOT ("%door_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xa8 ("door_off" + 0x68)
  END
  PATCH_IF NOT ("%anim_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xb0 ("anim_off" + 0x68)
  END
  PATCH_IF NOT ("%tiled_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xb8 ("tiled_off" + 0x68)
  END
  PATCH_IF NOT ("%song_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xbc ("song_off" + 0x68)
  END
  PATCH_IF NOT ("%rest_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xc0 ("rest_off" + 0x68)
  END
  PATCH_IF NOT ("%note_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xc4 ("note_off" + 0x68)
  END
  BUT_ONLY_IF_IT_CHANGES

// some areas have scripts that are not assigned to them
COPY_EXISTING ~ar0321.are~ ~override~
              ~ar0323.are~ ~override~
              ~ar0324.are~ ~override~
              ~ar0327.are~ ~override~
              ~ar0401.are~ ~override~
              ~ar1005.are~ ~override~
              ~ar1009.are~ ~override~ // has wrong script assigned; could cause cutscene hangs
              ~ar1904.are~ ~override~
              ~ar5004.are~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x11b) THEN BEGIN // protects against invalid files
    READ_ASCII 0x94 "script"
    PATCH_IF ("" STRING_COMPARE_CASE "%script%" = 0) BEGIN
      WRITE_EVALUATED_ASCII 0x94 ~%SOURCE_RES%~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds outdoor flag
COPY_EXISTING ~ar0041.are~ ~override~
              ~ar0042.are~ ~override~
              ~ar0044.are~ ~override~
              ~ar0045.are~ ~override~
              ~ar1607.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b00000001)
  BUT_ONLY_IF_IT_CHANGES

// removes outdoor flag
COPY_EXISTING ~ar0321.are~ ~override~
              ~ar0322.are~ ~override~
              ~ar0323.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BAND 0b11111110)
  BUT_ONLY_IF_IT_CHANGES

// removes city flag
COPY_EXISTING ~ar0303.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0307.are~ ~override~
              ~ar0308.are~ ~override~
              ~ar0309.are~ ~override~
              ~ar0311.are~ ~override~
              ~ar0312.are~ ~override~
              ~ar0315.are~ ~override~
              ~ar0316.are~ ~override~
              ~ar0317.are~ ~override~
              ~ar0406.are~ ~override~ //Copper Coronet
              ~ar0501.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0505.are~ ~override~
              ~ar0506.are~ ~override~
              ~ar0507.are~ ~override~
              ~ar0508.are~ ~override~
//              ~ar0509.are~ ~override~ //Five Flagons, ground floor
//              ~ar0510.are~ ~override~ //Five Flagons, theater
//              ~ar0511.are~ ~override~ //Five Flagons, second floor
//              ~ar0512.are~ ~override~
              ~ar0513.are~ ~override~ //Calbor's Inn, first floor
              ~ar0514.are~ ~override~ //Calbor's Inn, second floor
              ~ar0515.are~ ~override~ //Calbor's Inn, third floor
//              ~ar0522.are~ ~override~ //Five Flagons, ground floor (stronghold)
//              ~ar0523.are~ ~override~ //Five Flagons, theater (stronghold)
              ~ar0706.are~ ~override~
              ~ar0901.are~ ~override~ //Temple District, Helm temple
              ~ar0902.are~ ~override~ //Temple District, Lathander temple
              ~ar0904.are~ ~override~ //Temple District, Talos temple
              ~ar0905.are~ ~override~ //Temple District, Pimlico's Estate
              ~ar0906.are~ ~override~ //Temple District, guarded compound ground floor
              ~ar0907.are~ ~override~ //Temple District, guarded compound second floor
              ~ar5507.are~ ~override~ //Saradush, basement entrance to Gromnir's castle
  PATCH_IF (SOURCE_SIZE > 0x11b) THEN BEGIN // protects against invalid files
    READ_BYTE  0x48 "flags"
    WRITE_BYTE 0x48 ("%flags%" BAND 0b11110111)
  END
  BUT_ONLY_IF_IT_CHANGES

// adds dungeon flag
COPY_EXISTING ~ar0310.are~ ~override~
              ~ar0331.are~ ~override~
              ~ar0418.are~ ~override~
              ~ar0521.are~ ~override~
              ~ar0526.are~ ~override~
              ~ar0601.are~ ~override~
              ~ar0606.are~ ~override~
              ~ar0804.are~ ~override~
              ~ar1106.are~ ~override~
              ~ar1203.are~ ~override~
              ~ar1402.are~ ~override~
              ~ar1501.are~ ~override~
              ~ar1608.are~ ~override~
              ~ar1610.are~ ~override~
              ~ar2901.are~ ~override~
              ~ar2902.are~ ~override~
              ~ar2903.are~ ~override~
              ~ar2905.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b00100000)
  BUT_ONLY_IF_IT_CHANGES

// removes dungeon flag
COPY_EXISTING ~ar1101.are~ ~override~
              ~ar2603.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BAND 0b11011111)
  BUT_ONLY_IF_IT_CHANGES

// adds 'can rest' flag
COPY_EXISTING ~ar0522.are~ ~override~ // five flagons theater, stronghold version
              ~ar0905.are~ ~override~ // pimlico's estate
              ~ar0906.are~ ~override~ // guarded compound ground floor
              ~ar0907.are~ ~override~ // guarded compound second floor
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b10000000)
  BUT_ONLY_IF_IT_CHANGES

// transitions which need 'party required' flags
COPY_EXISTING ~ar0300.are~ ~override~
              ~ar0400.are~ ~override~
              ~ar0415.are~ ~override~
              ~ar0500.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0505.are~ ~override~
              ~ar2000.are~ ~override~
              ~ar2207.are~ ~override~
              ~ar2600.are~ ~override~
              ~ar2902.are~ ~override~
  READ_SHORT 0x5A "info_num"
  READ_LONG  0x5C "info_off"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%index%")) "area"
    PATCH_IF ((("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0328" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0402" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0415" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0500" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0505" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0504" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0505" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2207" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2603" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2902" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2900" STRING_COMPARE_CASE "%area%" = 0))) BEGIN
      READ_BYTE  ("%info_off%" + 0x60 + (0xC4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x60 + (0xC4 * "%index%")) ("%flags%" BOR 0b00000100)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// transitions which need 'can not be passed by NPC' flags
COPY_EXISTING ~ar0015.are~ ~override~
              ~ar0021.are~ ~override~
              ~ar0022.are~ ~override~
              ~ar0082.are~ ~override~
              ~ar0300.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0306.are~ ~override~
              ~ar0307.are~ ~override~
              ~ar0308.are~ ~override~
              ~ar0400.are~ ~override~
              ~ar0407.are~ ~override~
              ~ar0410.are~ ~override~
              ~ar0413.are~ ~override~
              ~ar0414.are~ ~override~
              ~ar0415.are~ ~override~
              ~ar0601.are~ ~override~
              ~ar0605.are~ ~override~
              ~ar0800.are~ ~override~
              ~ar0801.are~ ~override~
              ~ar1100.are~ ~override~
              ~ar1106.are~ ~override~
              ~ar1200.are~ ~override~
              ~ar1202.are~ ~override~
              ~ar1300.are~ ~override~
              ~ar1302.are~ ~override~
              ~ar1400.are~ ~override~
              ~ar1512.are~ ~override~
              ~ar1514.are~ ~override~
              ~ar1515.are~ ~override~
              ~ar1900.are~ ~override~
              ~ar2000.are~ ~override~
              ~ar2008.are~ ~override~
              ~ar2200.are~ ~override~
              ~ar2206.are~ ~override~
              ~ar2207.are~ ~override~
              ~ar2210.are~ ~override~
              ~ar2600.are~ ~override~
              ~ar2800.are~ ~override~
              ~ar5000.are~ ~override~
              ~ar5001.are~ ~override~
              ~ar5007.are~ ~override~
              ~ar5013.are~ ~override~
              ~ar5015.are~ ~override~
              ~ar5200.are~ ~override~
              ~ar5503.are~ ~override~
              ~ar5504.are~ ~override~
              ~ar5507.are~ ~override~
              ~ar6101.are~ ~override~
              ~ar6107.are~ ~override~
  READ_SHORT 0x5A "info_num" ELSE 0
  READ_LONG  0x5C "info_off" ELSE 0
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%index%")) "area"
    PATCH_IF ((("ar0015" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0018" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0021" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0020" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0021" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0082" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0022" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0021" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0082" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0021" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0301" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0302" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0303" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0304" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0308" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0309" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0305" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0306" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0307" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0308" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0308" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0309" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0311" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0407" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0410" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0411" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0413" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0412" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0414" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0411" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0415" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0601" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0602" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0605" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0606" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0801" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0801" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0800" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0801" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0802" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1100" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1104" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1106" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1100" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1202" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1302" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1302" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1401" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1402" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1403" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1512" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1513" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1512" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1514" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1514" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1507" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1515" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1900" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1902" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2008" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2013" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2008" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2206" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2207" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2210" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2206" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2207" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2210" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2603" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2807" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5001" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5001" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5007" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5006" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5013" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5015" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5016" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5503" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5504" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5507" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar6101" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar6100" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar6107" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar6108" STRING_COMPARE_CASE "%area%" = 0))) BEGIN
      READ_BYTE  ("%info_off%" + 0x61 + (0xC4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x61 + (0xC4 * "%index%")) ("%flags%" BOR 0b00000010)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect orientation when entering areas
COPY_EXISTING ~ar0201.are~ ~override~ // ghoul village, UE quest
              ~ar0202.are~ ~override~ // UE quest, cult hideout
              ~ar0204.are~ ~override~ // UE quest, temple city
              ~ar0300.are~ ~override~ // docks
              ~ar0302.are~ ~override~ // mae'var's guild entrance
              ~ar0304.are~ ~override~ // mae'var's guild third floor
              ~ar0312.are~ ~override~ // sleeping room
              ~ar0322.are~ ~override~ // mae'var's guild entrance (pc controlled)
              ~ar0324.are~ ~override~ // mae'var's guild third floor (pc controlled)
              ~ar0400.are~ ~override~ // slums
              ~ar0402.are~ ~override~ // jansen ground floor
              ~ar0404.are~ ~override~ // sewers under CC
              ~ar0405.are~ ~override~ // slaver's ship
              ~ar0406.are~ ~override~ // copper coronet
              ~ar0409.are~ ~override~ // ployer's home
              ~ar0500.are~ ~override~ // bridge district
              ~ar0509.are~ ~override~ // first floor five flagons
              ~ar0513.are~ ~override~ // calbor's inn
              ~ar0531.are~ ~override~ // commoner house
              ~ar0700.are~ ~override~ // promenade
              ~ar0703.are~ ~override~ // temple of ilmater (promenade)
              ~ar0707.are~ ~override~ // enge's shop
              ~ar0801.are~ ~override~ // bodhi's area
              ~ar0903.are~ ~override~ // norh
              ~ar0905.are~ ~override~ // pimlico's home
              ~ar1001.are~ ~override~ // delryn's home
              ~ar1003.are~ ~override~ // keldorn's home
              ~ar1004.are~ ~override~ // deril's home
              ~ar1005.are~ ~override~ // prison
              ~ar1009.are~ ~override~ // roenall's home
              ~ar1200.are~ ~override~ // windspear hills
              ~ar1300.are~ ~override~ // de'arnise keep exterior
              ~ar1304.are~ ~override~ // de'arnise keep exterior (pc)
              ~ar2101.are~ ~override~ // underdark beholder lair
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0709" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))    // den of seven vales to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 1 // south-southwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0506a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))    // noble home to bridge
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 2 // southwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0402" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))    // jansen home to slums
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 5 // west-northwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0303" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0304" = 0))  OR // 2nd to 3rd floor, mae'var
               (("%name%" STRING_COMPARE_CASE "exit0323" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0324" = 0))  OR // 2nd to 3rd floor, mae'var (pc)
               (("%name%" STRING_COMPARE_CASE "exit0405" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0404" = 0))  OR // slaver ship to sewers
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0409" = 0))  OR // slums to ployer's home
               (("%name%" STRING_COMPARE_CASE "exit0705" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // mekrath's lair to bridge
               (("%name%" STRING_COMPARE_CASE "exit0500" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0509" = 0))  OR // bridge to five flagons
               (("%name%" STRING_COMPARE_CASE "exit0500" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0531" = 0))  OR // bridge to commoner home
               (("%name%" STRING_COMPARE_CASE "exit0700" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0707" = 0))  OR // promenade to enge's shop
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0))  OR // temple district to norh
               (("%name%" STRING_COMPARE_CASE "exit0900b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0)) OR // temple district to norh
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0905" = 0))  OR // temple district to pimlico's
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1001" = 0))  OR // gov't to delryn's home
               (("%name%" STRING_COMPARE_CASE "exit1000b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1001" = 0)) OR // gov't to delryn's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1003" = 0))  OR // gov't to keldorn's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1004" = 0))  OR // gov't to deril's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1005" = 0))  OR // gov't to prison
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1009" = 0))  OR // gov't to roenall's home
               (("%name%" STRING_COMPARE_CASE "exitse" = 0)   AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1300" = 0))  OR // de'arnise keep from wmp
               (("%name%" STRING_COMPARE_CASE "exitse" = 0)   AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1304" = 0))     // de'arnise keep (pc) from wmp
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 6 // northwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0514a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // inn at bridge district to bridge
               (("%name%" STRING_COMPARE_CASE "exit0514b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // inn at bridge district to bridge
               (("%name%" STRING_COMPARE_CASE "exit800d" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0801" = 0))     // graveyard to bohdi's lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 7 // north-northwest
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "Exit2100" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar2101" = 0))    // underdark to beholder lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 8 // north
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0202" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0204" = 0))    // graveyard to bohdi's lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 9 // north-northeast
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0311" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0312" = 0)) OR // gaelan downstairs to upstairs
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0405" = 0)) OR // slums to slaver ship
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0406" = 0)) OR // slums to CC
               (("%name%" STRING_COMPARE_CASE "exi0400b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0406" = 0)) OR // slums to CC
               (("%name%" STRING_COMPARE_CASE "exit0700" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0703" = 0)) OR // ilmater temple from promenade
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0)) OR // norh from temple district
               (("%name%" STRING_COMPARE_CASE "exit1000b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1005" = 0))   // prison from gov't district
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 10 // northeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0301" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0302" = 0)) OR // basement to entrance, mae'var
               (("%name%" STRING_COMPARE_CASE "exi00321" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0322" = 0)) OR // basement to entrance, mae'var (pc)
               (("%name%" STRING_COMPARE_CASE "exitw" = 0)    AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1200" = 0))    // windspear hills from wmp
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 12 // east
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0308" = 0)  AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0300" = 0))   // harper hq to docks
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 13 // east-southeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0405" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // slaver ship to slums
               (("%name%" STRING_COMPARE_CASE "exit0406" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // CC to slums
               (("%name%" STRING_COMPARE_CASE "exi0406b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // CC to slums
               (("%name%" STRING_COMPARE_CASE "exit0406" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0404" = 0))  OR // CC to sewers
               (("%name%" STRING_COMPARE_CASE "exit0506b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // noble house to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0513" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // calbor's inn to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0515" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // inn to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0706" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // fletcher to promenade
               (("%name%" STRING_COMPARE_CASE "exit0707" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // enge's shop to promenade
               (("%name%" STRING_COMPARE_CASE "exit0708" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // cernd's home to promenade
               (("%name%" STRING_COMPARE_CASE "exit0710" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))    // fennecia's home to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 14 // southeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0206a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0201" = 0)) OR   // ghouls under temple from halfling village
               (("%name%" STRING_COMPARE_CASE "exit0206b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0201" = 0)) OR   // ghouls under temple from halfling village
               (("%name%" STRING_COMPARE_CASE "exit0202" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0205" = 0))  OR   // beholder hideout from cult hideout (UE)
               (("%name%" STRING_COMPARE_CASE "exit0514" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0513" = 0))  OR   // calbor's inn, second floor to first
               (("%name%" STRING_COMPARE_CASE "exit0704" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))       // mithrest to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 15 // southeast
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes several areas with detected traps
COPY_EXISTING ~AR0062.ARE~ ~override~
              ~AR0063.ARE~ ~override~
              ~AR0064.ARE~ ~override~
              ~AR0065.ARE~ ~override~
              ~AR0328.ARE~ ~override~
              ~AR0406.ARE~ ~override~
              ~AR0413.ARE~ ~override~
              ~AR0801.ARE~ ~override~
              ~AR0803.ARE~ ~override~
              ~AR0808.ARE~ ~override~
              ~AR1006.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    READ_SHORT ("%cont_off%" + 0x32 + ("%cont_num%" * 0xc0)) "detected"
    PATCH_IF (("%trapped%" = 1) AND ("%detected%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x32 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes two chests openable
COPY_EXISTING ~ar0327.are~ ~override~
              ~ar1006.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x26 + ("%cont_num%" * 0xc0)) "diff"
    READ_SHORT ("%cont_off%" + 0x28 + ("%cont_num%" * 0xc0)) "locked"
    READ_ASCII ("%cont_off%" + 0x78 + ("%cont_num%" * 0xc0)) "key"
    PATCH_IF (("%diff%" > 90) AND ("%locked%" BOR 0b11111110 = 0b11111111) AND ("%key%" STRING_COMPARE_CASE "" = 0)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x26 + ("%cont_num%" * 0xc0)) 90
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes traps in tut area
COPY_EXISTING ~AR0016.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) "diff"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%diff%" > 99) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0201.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1310) AND ("%y_coord%" = 1611)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 10 // body
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes sewer key to be used up in sewer door, moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~AR0202.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1993) AND ("%y_coord%" = 2236)) BEGIN // move to avoid actor collision
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 2037
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 2242
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 6     // correct icon to shelf
      SET "index" = "%cont_num%" // kills loop
    END
  END
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "SWERDOOR" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors, container icon fixes
COPY_EXISTING ~ar0204.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1260) AND ("%y_coord%" = 2623)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END ELSE
    PATCH_IF (("%x_coord%" = 3755) AND ("%y_coord%" = 2522)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 3738
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 2515
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0206.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 577) AND ("%y_coord%" = 522)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering/flags
COPY_EXISTING ~ar0307.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307tt1" = 0) BEGIN // spiky wheel in torturer's room
      READ_BYTE   ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) ("%flags%" BOR 0b00000001) // adds draw as background flag
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xff7e // height
    END ELSE
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307ur1" = 0) BEGIN // spiky wheel you run across
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0 // height
    END ELSE
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307ur3" = 0) BEGIN // another spiky wheel you run across
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffcc // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar0312.are~ ~override~
              ~ar0335.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) "x_coord"
    READ_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) "y_coord"
    PATCH_IF ((("%x_coord%" = 180) AND ("%y_coord%" = 304)) OR
              (("%x_coord%" = 170) AND ("%y_coord%" = 310)) OR
              (("%x_coord%" = 552) AND ("%y_coord%" = 107)) OR
              (("%x_coord%" = 573) AND ("%y_coord%" = 114)))  BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x31 // height
    END ELSE
    PATCH_IF (("%x_coord%" = 438) AND ("%y_coord%" = 121)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x34 // height
    END ELSE
    PATCH_IF (("%x_coord%" = 670) AND ("%y_coord%" = 188)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x2e // height
    END ELSE
    PATCH_IF (("%x_coord%" = 426) AND ("%y_coord%" = 129)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x3a // height
    END ELSE
    PATCH_IF (("%x_coord%" = 680) AND ("%y_coord%" = 194)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x38 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0312.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 492) AND ("%y_coord%" = 275)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 2 // chest
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad flags
COPY_EXISTING ~ar0313.are~ ~override~
              ~ar0529.are~ ~override~
              ~ar0713.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am003xa" = 0) BEGIN // oven
      WRITE_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) 334 // x coord, only wrong in ar0713
      WRITE_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) 377 // y coord, only wrong in ar0713
      READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BOR  0b01000000) // adds not covered by wall flag
      READ_BYTE   ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) ("%flags%" BOR 0b00000001) // adds draw as background flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0319.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 477) AND ("%y_coord%" = 357)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 5 // table
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes doors actually require keys that they are listed as requiring
COPY_EXISTING ~AR0329.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF ((("%doorname%" STRING_COMPARE_CASE "DOOR07" = 0) OR ("%doorname%" STRING_COMPARE_CASE "DOOR08" = 0))
                AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ar0333.are entry/exit points are reversed; undoing the Escher architecture
COPY_EXISTING ~ar0333.are~ ~override~
  READ_SHORT 0x5a "info_num"
  READ_LONG  0x5c "info_off"
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN // swap transition (exit) points
    READ_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "area"
    PATCH_IF ("ar0300" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      WRITE_ASCII ("%info_off%" +        (0xc4 * "%index%")) "Tran0332" #32 // transition point name
      WRITE_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "ar0332" #8    // destination area
      WRITE_ASCII ("%info_off%" + 0x40 + (0xc4 * "%index%")) "Exit0333" #8  //  exit point
    END ELSE
    PATCH_IF ("ar0332" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      WRITE_ASCII ("%info_off%" +        (0xc4 * "%index%")) "Tran0300" #32 // transition point name
      WRITE_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "ar0300" #8    // destination area
      WRITE_ASCII ("%info_off%" + 0x40 + (0xc4 * "%index%")) "Exit0333" #8  //  exit point
    END
  END
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN // swap entry points
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Exit0300" = 0) BEGIN
      WRITE_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "Exit0332"
    END ELSE
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Exit0332" = 0) BEGIN
      WRITE_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "Exit0300"
    END 
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar0334.are~ ~override~
              ~ar0406.are~ ~override~
              ~ar0706.are~ ~override~
              ~ar1603.are~ ~override~
              ~ar2001.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "fpit1s" = 0) BEGIN // forges
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors, container icon fixes
COPY_EXISTING ~ar0400.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1000) AND ("%y_coord%" = 835)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 1000
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 840
    END ELSE
    PATCH_IF (("%x_coord%" = 2953) AND ("%y_coord%" = 2102)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 5 // table
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// areas with identified items in containers
COPY_EXISTING ~ar0405.are~ ~override~
              ~ar0602.are~ ~override~
              ~ar1101.are~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  FOR (index = 0 ; index < item_num ; index = index + 1) BEGIN
    READ_ASCII ("%item_off%" +        (0x14 * "%index%")) "item"
    READ_BYTE  ("%item_off%" + 0x10 + (0x14 * "%index%")) "flag"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow02" = 0) OR
              ("%item%" STRING_COMPARE_CASE "arow08" = 0) OR
              ("%item%" STRING_COMPARE_CASE "sper02" = 0) OR
              ("%item%" STRING_COMPARE_CASE "sw1h05" = 0)) BEGIN
      WRITE_BYTE  ("%item_off%" + 0x10 + (0x14 * "%index%")) ("%flag%" BAND 0b11111110)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0406.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1412) AND ("%y_coord%" = 1558)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 2 // chest
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// trapped container doesn't actually do anything
COPY_EXISTING ~ar0407.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_ASCII ("%cont_off%" +        ("%index%" * 0xc0)) "name"
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Container 2" = 0) BEGIN
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%index%" * 0xc0)) ~ctmm~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0411.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 2443) AND ("%y_coord%" = 642)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0))  10 // body
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes demon eye animation
COPY_EXISTING ~AR0414.ARE~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  WHILE ("%anim_num%" > 0) BEGIN
    SET "anim_num" = ("%anim_num%" - 1)
    READ_ASCII ("%anim_off%" +        ("%anim_num%" * 0x4c)) "animname"
    PATCH_IF ("%animname%" STRING_COMPARE_CASE "AM414EY2" = 0) BEGIN
      WRITE_SHORT ("%anim_off%" + 0x22 + ("%anim_num%" * 0x4c)) 2794
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes trap script
COPY_EXISTING ~AR0415.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    PATCH_IF ("%script%" STRING_COMPARE_CASE "ACT02" = 0) BEGIN
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) ~CTALARM~ #8 // correct trap script reference
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes multiple Stanets
COPY_EXISTING ~AR0500.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  SET "stanets" = 0
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "BMTOWN4" = 0) BEGIN
      PATCH_IF ("%stanets%" = 0) BEGIN
        SET "stanets" = 1
      END ELSE BEGIN
        WRITE_ASCII ("%actor_off%" +        ("%actor_num%" * 0x110)) ~Commoner~ #32
        WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~BMTOWN2~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0501.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 667) AND ("%y_coord%" = 176)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 11 // barrel
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0506.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 550) AND ("%y_coord%" = 172)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 7 // altar
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes portal animation
COPY_EXISTING ~AR0510.ARE~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  WHILE ("%anim_num%" > 0) BEGIN
    SET "anim_num" = ("%anim_num%" - 1)
    READ_ASCII ("%anim_off%" +        ("%anim_num%" * 0x4c)) "animname"
    PATCH_IF ("%animname%" STRING_COMPARE_CASE "AM0510A" = 0) BEGIN
      WRITE_SHORT ("%anim_off%" + 0x20 + ("%anim_num%" * 0x4c)) 839 // adjusts x coordinate
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~ar0513.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 908) AND ("%y_coord%" = 385)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 886
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 471
      SET "index" = "%cont_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon, makes Neb's trap disarmable
COPY_EXISTING ~ar0529.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    READ_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) "removal"
    READ_SHORT ("%cont_off%" + 0x30 + ("%index%" * 0xc0)) "trapped"
    PATCH_IF (("%x_coord%" = 326) AND ("%y_coord%" = 363)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
    PATCH_IF (("%removal%" > 90) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) 90
      READ_SHORT  ("%cont_off%" + 0x2C + ("%index%" * 0xc0)) "detection"
      PATCH_IF ("%detection%" < 50) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2C + ("%index%" * 0xc0)) 50
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// ice mephit has wrong script
COPY_EXISTING ~ar0603.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "mepice01" = 0) BEGIN // ice mephit
      WRITE_ASCII ("%actor_off%" + 0x50 + ("%index%" * 0x110)) ~waitpc2~ #8 // override script
      SET "index" = "%actor_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes guard reference in ar0700 to not be the rubble-guarder type, moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~AR0700.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "AMNG1" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~AMNG2~ #8
    END
  END
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 3323) AND ("%y_coord%" = 308)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 3249
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 300
    END ELSE
    PATCH_IF (("%x_coord%" = 606) AND ("%y_coord%" = 1136)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 572
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 1163
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mind flayer door uses up key
COPY_EXISTING ~AR0701.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "Door02" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// wrong creature reference in Waukeen Ilmater temple; see soa-dlg.d for changes to wilmat.dlg
COPY_EXISTING ~ar0703.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "slilmat" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) ~wilmat~ #8
      SET "index" = "%actor_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0705.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 582) AND ("%y_coord%" = 848)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 6 // shelf
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// indoor actor has outdoor script
COPY_EXISTING ~ar0713.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "mtown3" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x50 + ("%index%" * 0x110)) ~runenemy~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes VVMADMAN only exist at night so he won't EscapeArea()
COPY_EXISTING ~AR0900.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "VVMADMAN" = 0) BEGIN
      WRITE_LONG ("%actor_off%" + 0x40 + ("%actor_num%" * 0x110)) 0xfff8001f
    END
  END
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 3066) AND ("%y_coord%" = 1647)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// changes Festule's potion to minor healing
COPY_EXISTING ~AR0901.ARE~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + ("%item_num%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "POTN53" = 0) BEGIN
      WRITE_ASCII ("%item_off%" + ("%item_num%" * 0x14)) ~POTN08~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0902.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1325) AND ("%y_coord%" = 1510)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes guard references in ar1000 to not be the rubble-guarder type, enables one ambient, fixes multiple gftown02
COPY_EXISTING ~AR1000.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_SHORT 0x82 "amb_num"
  READ_LONG  0x84 "amb_off"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "AMNG1" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~AMNG2~ #8
    END ELSE
    PATCH_IF (("%cre_file%" STRING_COMPARE_CASE "victown1" = 0) OR
              ("%cre_file%" STRING_COMPARE_CASE "victown4" = 0)) BEGIN
      WRITE_LONG ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
    END ELSE
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "gftown02" = 0) BEGIN
      READ_SHORT ("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) "x_coord"
      READ_SHORT ("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" != 2265) AND ("%y_coord%" != 692)) BEGIN
        WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~gftown01~ #8
      END
    END
  END
  WHILE ("%amb_num%" > 0) BEGIN
    SET "amb_num" = ("%amb_num%" - 1)
    READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
    PATCH_IF ("%x_coord%" = 907) BEGIN
      WRITE_LONG ("%amb_off%" + 0x8C + ("%amb_num%" * 0xd4)) 0x001fffc0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// part of making Ketlaar's guards disappear if Ketlaar is killed
COPY_EXISTING ~AR1002.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  SET "toggle" = 0
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "BODYG2" = 0) BEGIN
      WRITE_BYTE ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
      PATCH_IF ("%toggle%" = 0) BEGIN
        WRITE_ASCII ("%actor_off%" + ("%actor_num%" * 0x110)) ~MGKETBG1~ #32
        SET "toggle" = 1
      END ELSE BEGIN
        WRITE_ASCII ("%actor_off%" + ("%actor_num%" * 0x110)) ~MGKETBG2~ #32
        SET "toggle" = 0
      END
    END ELSE
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "argrim" = 0) BEGIN
      WRITE_BYTE  ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
      WRITE_ASCII ("%actor_off%" +        ("%actor_num%" * 0x110)) ~argrim~ #32
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// forces two doors to use keys and by setting lock difficulties of 100 and setting a bit
COPY_EXISTING ~AR1202.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "Door24" = 0) OR
              ("%doorname%" STRING_COMPARE_CASE "Door29" = 0)) BEGIN
      READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
      WRITE_BYTE ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
      WRITE_LONG ("%door_off%" + 0x8c + ("%door_num%" * 0xc8)) 100 // lock difficulty
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes bad item reference in Nalia's keep
COPY_EXISTING ~AR1303.ARE~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + ("%item_num%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "" = 0) BEGIN
      WRITE_ASCII ("%item_off%" + ("%item_num%" * 0x14)) ~arow08~ 
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// door from ground floor of stronghold de'Arnise Keep is off, not attached to door
COPY_EXISTING ~ar1306.are~ ~override~
  READ_SHORT 0x5a "info_num"
  READ_LONG  0x5c "info_off"
  READ_LONG  0x7c "vert_off"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" +        ("%index%" * 0xc4)) "info_name" (9)
    PATCH_IF ("%info_name%" STRING_COMPARE_CASE "Tran1304a" = 0) BEGIN
      // bounding box
      WRITE_SHORT ("%info_off%" + 0x22 + ("%index%" * 0xc4)) 442  // bounding: left
      WRITE_SHORT ("%info_off%" + 0x24 + ("%index%" * 0xc4)) 1799 // bounding: top
      WRITE_SHORT ("%info_off%" + 0x26 + ("%index%" * 0xc4)) 520  // bounding: right
      WRITE_SHORT ("%info_off%" + 0x28 + ("%index%" * 0xc4)) 1935 // bounding: bottom
      // vertices
      READ_SHORT  ("%info_off%" + 0x2c + ("%index%" * 0xc4)) "vert_idx"
      WRITE_SHORT ("%vert_off%" +        (0x04 * "%vert_idx%")) 442
      WRITE_SHORT ("%vert_off%" + 0x02 + (0x04 * "%vert_idx%")) 1799
      WRITE_SHORT ("%vert_off%" + 0x04 + (0x04 * "%vert_idx%")) 442
      WRITE_SHORT ("%vert_off%" + 0x06 + (0x04 * "%vert_idx%")) 1891
      WRITE_SHORT ("%vert_off%" + 0x08 + (0x04 * "%vert_idx%")) 520
      WRITE_SHORT ("%vert_off%" + 0x0a + (0x04 * "%vert_idx%")) 1935
      WRITE_SHORT ("%vert_off%" + 0x0c + (0x04 * "%vert_idx%")) 520
      WRITE_SHORT ("%vert_off%" + 0x0e + (0x04 * "%vert_idx%")) 1845
      // add attached to door flag (also next loop)
      READ_BYTE  ("%info_off%" + 0x61 + (0xc4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x61 + (0xc4 * "%index%")) ("%flags%" BOR 0b00001000)
      SET "index" = "%info_num%" // kills loop
    END
  END
  FOR (index = 0 ; index < door_num ; index = index + 1) BEGIN
    READ_ASCII ("%door_off%" +        ("%index%" * 0xc8)) "door_name"
    PATCH_IF ("%door_name%" STRING_COMPARE_CASE "secret07" = 0) BEGIN
      WRITE_ASCII ("%door_off%" + 0x9c + ("%index%" * 0xc8)) "Tran1304a" #16
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//moves imp to passable ground
COPY_EXISTING ~ar1513.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "imp01" = 0) BEGIN
      READ_SHORT("%actor_off%" + 0x20 + ("%index%" * 0x110)) "x_coord"
      READ_SHORT("%actor_off%" + 0x22 + ("%index%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" = 1639) AND ("%y_coord%" = 1140)) BEGIN
        WRITE_SHORT("%actor_off%" + 0x20 + ("%index%" * 0x110)) 1724
        WRITE_SHORT("%actor_off%" + 0x22 + ("%index%" * 0x110)) 1164
        WRITE_SHORT("%actor_off%" + 0x24 + ("%index%" * 0x110)) 1724
        WRITE_SHORT("%actor_off%" + 0x26 + ("%index%" * 0x110)) 1164
        SET "index" = "%actor_num%" // kill loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad flag
COPY_EXISTING ~ar1601.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "smoke" = 0) BEGIN // oven smoke plume
      READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BAND  0b01111111) // remove show in fog of war flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// overlay fix
COPY_EXISTING ~AR1603.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  READ_LONG  0x7c "vert_off"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x20 + ("%cont_num%" * 0xc0)) "x_coord"
    PATCH_IF ("%x_coord%" = 270) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x38 + ("%cont_num%" * 0xc0)) 243
      WRITE_SHORT ("%cont_off%" + 0x3a + ("%cont_num%" * 0xc0)) 414
      WRITE_SHORT ("%cont_off%" + 0x3c + ("%cont_num%" * 0xc0)) 292
      READ_SHORT  ("%cont_off%" + 0x50 + ("%cont_num%" * 0xc0)) "vert_idx"
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 0) * 0x04)) 292
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 0) * 0x04)) 442
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 1) * 0x04)) 286
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 414
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 2) * 0x04)) 243
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 458
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 252
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 489
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes another door to use its key
COPY_EXISTING ~AR1608.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "DOOR05" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes another door to use its key
COPY_EXISTING ~AR1611.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    READ_ASCII ("%door_off%" + 0x78 + ("%door_num%" * 0xc8)) "keyname"
    PATCH_IF (("%keyname%" STRING_COMPARE_CASE "KEY27" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//moves troll to passable ground
COPY_EXISTING ~AR1904.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "TROLL01" = 0) BEGIN
      READ_SHORT("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) "x_coord"
      READ_SHORT("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" = 1492) AND ("%y_coord%" = 1172)) BEGIN
        WRITE_SHORT("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) 1273
        WRITE_SHORT("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) 1180
        WRITE_SHORT("%actor_off%" + 0x24 + ("%actor_num%" * 0x110)) 1273
        WRITE_SHORT("%actor_off%" + 0x26 + ("%actor_num%" * 0x110)) 1180
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes ambient sound, trademeet tomb uses key
COPY_EXISTING ~AR2000.ARE~ ~override~
  READ_SHORT 0x82 "amb_num"
  READ_LONG  0x84 "amb_off"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  WHILE ("%amb_num%" > 0) BEGIN
    SET "amb_num" = ("%amb_num%" - 1)
    READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
    READ_SHORT ("%amb_off%" + 0x22 + ("%amb_num%" * 0xd4)) "y_coord"
    PATCH_IF (("%x_coord%" = 35) AND ("%y_coord%" = 59)) BEGIN
      WRITE_LONG ("%amb_off%" + 0x8C + ("%amb_num%" * 0xd4)) 0x001fffc0
    END
  END
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "DOOR01" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// removes spurious trap flag
COPY_EXISTING ~AR2002.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%script%" STRING_COMPARE_CASE "" = 0) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x2E + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// corrects music in underdark
COPY_EXISTING ~AR2100.ARE~ ~override~
  READ_LONG 0xbc "song_off"
  WRITE_LONG ("%song_off%" + 0x04) 31
  BUT_ONLY_IF_IT_CHANGES

// trap fixes
COPY_EXISTING ~AR2207.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%trapped%" = 0) AND ("%script%" STRING_COMPARE_CASE "GSPEAR" = 0)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 1
    END
    PATCH_IF ("%script%" STRING_COMPARE_CASE "GT007" = 0) BEGIN
      READ_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) "detect"
      READ_SHORT ("%cont_off%" + 0x2e + ("%cont_num%" * 0xc0)) "remove"
      PATCH_IF ("%detect%" = 0) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 50
      END
      PATCH_IF ("%remove%" > 90) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2e + ("%cont_num%" * 0xc0)) 90
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar2300.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) "x_coord"
    READ_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) "y_coord"
    PATCH_IF (("%x_coord%" = 3590) AND ("%y_coord%" = 2171)) BEGIN // water spout
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffef // height
    END ELSE
    PATCH_IF (("%x_coord%" = 4116) AND ("%y_coord%" = 1641)) BEGIN // water spout
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffd3 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cleans up junk in the rest spawn block
COPY_EXISTING ~AR2400.ARE~ ~override~
  READ_LONG 0xc0 "rest_off"
  SAY         ("%rest_off%" + 0x40) #10134
  WRITE_LONG  ("%rest_off%" + 0x70) 0
  WRITE_LONG  ("%rest_off%" + 0x78) 0
  WRITE_LONG  ("%rest_off%" + 0x80) 0
  WRITE_LONG  ("%rest_off%" + 0x88) 0
  WRITE_LONG  ("%rest_off%" + 0x90) 0
  BUT_ONLY_IF_IT_CHANGES
  
// war elves in ar2401 go hostile with drow shouts
COPY_EXISTING ~ar2401.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_REGEXP "udelf0[1-5]" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x60 + ("%actor_num%" * 0x110)) ~waitpc~ #8
      PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "udelf02" = 0) BEGIN
        WRITE_ASCII ("%actor_off%" + 0x58 + ("%actor_num%" * 0x110)) ~wtarsgt~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// removes party-required flag from AR2600 transition
COPY_EXISTING ~ar2603.are~ ~override~
  READ_SHORT 0x5A "info_num"
  READ_LONG  0x5C "info_off"
  WHILE ("%info_num%" > 0) BEGIN
    SET "info_num" = ("%info_num%" - 1)
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%info_num%")) "area"
    PATCH_IF ("AR2600" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      READ_BYTE  ("%info_off%" + 0x60 + (0xC4 * "%info_num%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x60 + (0xC4 * "%info_num%")) ("%flags%" BAND 0b11111011)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // fixes coordinates
  COPY_EXISTING ~AR3000.ARE~ ~override~
    READ_SHORT 0x5A "info_num"
    READ_LONG  0x5C "info_off"
    READ_LONG  0x7c "vert_off"
    READ_LONG  0xa4 "door_num"
    READ_LONG  0xa8 "door_off"
    WHILE ("%info_num%" > 0) BEGIN
      SET "info_num" = ("%info_num%" - 1)
      READ_ASCII ("%info_off%" + 0x7c + (0xC4 * "%info_num%")) "script"
      PATCH_IF ("TP3001A" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 406  // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 1040 // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 406  // vertex
      END ELSE
      PATCH_IF ("TP3017B" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 1774 // vertex
      END ELSE
      PATCH_IF ("TP3019B" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 1596 // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 1569 // vertex
      END ELSE
      PATCH_IF ("TP3020" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x22 + (0xC4 * "%info_num%")) 429  // bounding box
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 1899 // bounding box
        WRITE_SHORT ("%info_off%" + 0x26 + (0xC4 * "%info_num%")) 489  // bounding box
        WRITE_SHORT ("%info_off%" + 0x28 + (0xC4 * "%info_num%")) 2039 // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%"    ) * 0x04)) 429  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%"    ) * 0x04)) 2003 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 1) * 0x04)) 448  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 1899 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 2) * 0x04)) 489  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 1931 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 483  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 2039 // vertex
      END
    END
    WHILE ("%door_num%" > 0) BEGIN
      SET "door_num" = ("%door_num%" - 1)
      READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
      READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
      PATCH_IF ("%doorname%" STRING_COMPARE_CASE "DOOR02" = 0) BEGIN
        WRITE_SHORT ("%door_off%" + 0x44 + ("%door_num%" * 0xc8)) 508 // bounding box
        READ_LONG   ("%door_off%" + 0x34 + ("%door_num%" * 0xc8)) "cl_vert_idx" // closed vertex index
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 1) * 0x04)) 445  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%cl_vert_idx%" + 1) * 0x04)) 1896 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 2) * 0x04)) 508  // vertex
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 3) * 0x04)) 495  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%cl_vert_idx%" + 3) * 0x04)) 2048 // vertex
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // corrects ambients, animation glitches due to bad flag
  COPY_EXISTING ~ar3001.are~ ~override~
    READ_SHORT 0x82 "amb_num"  ELSE 0
    READ_LONG  0x84 "amb_off"  ELSE 0
    READ_LONG  0xac "anim_num" ELSE 0
    READ_LONG  0xb0 "anim_off" ELSE 0
    WHILE ("%amb_num%" > 0) BEGIN
      SET "amb_num" = ("%amb_num%" - 1)
      READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
      PATCH_IF ("%x_coord%" = 1406) BEGIN
        WRITE_SHORT ("%amb_off%" + 0x80 + ("%amb_num%" * 0xd4)) 10
      END
    END
    FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
      READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
      PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am3001f" = 0) BEGIN // glowing globes
        READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
        WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BOR  0b10000000) // add show in fog of war flag
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // changes rest spawn demon from summoned to regular one
  COPY_EXISTING ~AR3004.ARE~ ~override~
    READ_LONG 0xc0 "rest_off"
    WRITE_ASCII ("%rest_off%" + 0x60) ~DGLAB01~ #8
    BUT_ONLY_IF_IT_CHANGES

  // fixes rest spawn demon cre reference
  COPY_EXISTING ~AR3010.ARE~ ~override~
    READ_LONG 0xc0 "rest_off"
    WRITE_ASCII ("%rest_off%" + 0x58) ~DERINY01~
    BUT_ONLY_IF_IT_CHANGES

  // makes trigger names unique
  COPY_EXISTING ~AR5006.ARE~ ~override~
    READ_SHORT 0x5A "info_num"
    READ_LONG  0x5C "info_off"
    FOR (index = 0; index < info_num ; index = index + 1) BEGIN
      READ_SHORT ("%info_off%" + 0x24 + (0xC4 * "%index%" )) "bound_top"
      PATCH_IF ("%bound_top%" = 603) BEGIN
        WRITE_ASCII ("%info_off%" + (0xC4 * "%index%" )) "SpiritAppear2" #32
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // non-secret door shouldn't be flagged as secret
  COPY_EXISTING ~ar5015.are~ ~override~
    READ_LONG 0xa4 "door_num" ELSE 0
    READ_LONG 0xa8 "door_off" ELSE 0
    FOR (index = 0 ; index < door_num ; index = index + 1) BEGIN
      READ_ASCII ("%door_off%" + 0x9c + ("%index%" * 0xc8)) "trans_name"
      PATCH_IF ("%trans_name%" STRING_COMPARE_CASE "tran5016" = 0) BEGIN
        READ_BYTE  ("%door_off%" + 0x28 + ("%index%" * 0xc8)) "secret"
        WRITE_BYTE ("%door_off%" + 0x28 + ("%index%" * 0xc8)) ("%secret%" BAND 0b01111111) // removes secret flag
      END
    END
    BUT_ONLY_IF_IT_CHANGES

END

// checking areas for overcharged items
COPY_EXISTING ~ar0305.are~ ~override~ // dagg01 (num 10) has assigned 3 to stack 1 charges 0 in header 1
              ~ar0334.are~ ~override~ // bow01 (num 5) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0505.are~ ~override~ // bow01 (num 19) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0530.are~ ~override~ // sw2h01 (num 3) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0801.are~ ~override~ // misc6w (num 0) has assigned 3 to stack 1 charges 0 in header 1
              ~ar0903.are~ ~override~ // dagg01 (num 15) has assigned 4 to stack 1 charges 0 in header 1
              ~ar1202.are~ ~override~ // key07 (num 4) has assigned 4 to stack 1 charges 0 in header 1
              ~ar2400.are~ ~override~ // misc3o (num 4) has assigned 3 to max 0 in header 2
              ~ar3016.are~ ~override~ // wand18 (num 44) has assigned 6 to max 5 in header 2
              ~ar3021.are~ ~override~ // wand19 (num 2) has assigned 1 to max 0 in header 2
              ~ar3022.are~ ~override~ // wand18 (num 10) has assigned 6 to max 5 in header 2
              ~ar5502.are~ ~override~ // sw1h05 (num 5) has assigned 2 to stack 1 charges 0 in header 1
              ~ar6300.are~ ~override~ // plot16a (num 6) has assigned 2 to stack 1 charges 0 in header 1
  READ_SHORT 0x76 "itm_num" ELSE 0
  READ_LONG  0x78 "itm_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        ("%index%" * 0x14)) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow01" = 0) OR      // composite long bow
              ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR      // long bow
              ("%item%" STRING_COMPARE_CASE "bow05" = 0) OR      // short bow
              ("%item%" STRING_COMPARE_CASE "dagg01" = 0) OR     // dagger
              ("%item%" STRING_COMPARE_CASE "key07" = 0) OR      // chapel key
              ("%item%" STRING_COMPARE_CASE "misc6w" = 0) OR     // wooden stake
              ("%item%" STRING_COMPARE_CASE "plot16a" = 0) OR    // bounty notice
              ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) OR     // bastard sword
              ("%item%" STRING_COMPARE_CASE "sw1h05" = 0) OR     // long sword +1
              ("%item%" STRING_COMPARE_CASE "sw2h01" = 0)) BEGIN // 2h sword
      WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 0 // unchargable/unstackable items
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0
      WRITE_SHORT ("%itm_off%" + 0x0e + ("%index%" * 0x14)) 0
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "misc3o" = 0) BEGIN // methlid's harp
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0 // no secondary charges
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand18" = 0) BEGIN // wand of spell striking
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" > 5) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 5 // max 5 secondary charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand19" = 0) BEGIN // wand of cursing
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0 // no secondary charges
      WRITE_SHORT ("%itm_off%" + 0x0e + ("%index%" * 0x14)) 0 // no tertiary charges
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes zero charge items
COPY_EXISTING ~ar0018.are~ ~override~ // ttwand (num 5) has assigned 0 to stack 1 charges 100 in header 1
              ~ar0311.are~ ~override~ // ax1h04 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~ar0317.are~ ~override~ // wand05 (num 3) has assigned 0 to stack 1 charges 50 in header 1
              ~ar0329.are~ ~override~ // ring26 (num 7) has assigned 0 to stack 1 charges 1 in header 1
              ~ar0405.are~ ~override~ // bolt01 (num 36) has assigned 0 to stack 40 charges 1 in header 1
              ~ar0527.are~ ~override~ // wand03 (num 0) has assigned 0 to stack 1 charges 100 in header 1
              ~ar0706.are~ ~override~ // ax1h04 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~ar1202.are~ ~override~ // misc3h (num 20) has assigned 0 to stack 1 charges 1 in header 1
              ~ar1302.are~ ~override~ // dart03 (num 74) has assigned 0 to stack 40 charges 1 in header 1
              ~ar1514.are~ ~override~ // arow05 (num 53) has assigned 0 to stack 40 charges 1 in header 1
  READ_SHORT 0x76 "itm_num" ELSE 0
  READ_LONG  0x78 "itm_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        ("%index%" * 0x14)) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ax1h04" = 0) OR     // throwing axes
              ("%item%" STRING_COMPARE_CASE "wand03" = 0)) BEGIN // wand of magic missiles, never has >10 charges anywhere else
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow05" = 0) OR     // arrows of biting
              ("%item%" STRING_COMPARE_CASE "bolt01" = 0) OR     // bolts
              ("%item%" STRING_COMPARE_CASE "bolt04" = 0)) BEGIN // bolts of biting
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 40
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow10" = 0) OR      // heartseeker +3
              ("%item%" STRING_COMPARE_CASE "sw1h32" = 0)) BEGIN // dragonslayer
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "dart03" = 0) BEGIN // darts of stunning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // never appears in stacks > 20
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "misc3h" = 0) OR     // horn of blasting
              ("%item%" STRING_COMPARE_CASE "ring26" = 0)) BEGIN // ring of djinni summoning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ttwand" = 0) BEGIN // wand of the heavens (tutorial version)
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 8 // non-tut version never appears with >8 charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand05" = 0) BEGIN // wand of fire
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10
      END
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 10
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// creature file fixes                              \\\\\
/////                                                  \\\\\

// why is a statue chaotic evil?
COPY_EXISTING ~shaava01.cre~ ~override~
  WRITE_BYTE 0x27b 0 // alignment: none
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~balth.cre~    ~override~ // Balthazar
              ~c6bran.cre~   ~override~ // Branet Al-Thon
              ~c6eric.cre~   ~override~ // Eric Vanstraaten
              ~c6eric3.cre~  ~override~ // Eric Vanstraaten
              ~c6nerit.cre~  ~override~ // Nerit
              ~c6will.cre~   ~override~ // William Reirrac
              ~cutbalth.cre~ ~override~ // Balthazar
              ~garren.cre~   ~override~ // Garren Windspear
              ~hdragsil.cre~ ~override~ // Dragon
              ~pwauk2.cre~   ~override~ // Haletlatess Jillian
              ~sarmag01.cre~ ~override~ // Errard
              ~sleepdw.cre~  ~override~ // Sleeping Dwarf
              ~suelle.cre~   ~override~ // Ellesime
              ~suelle2.cre~  ~override~ // Ellesime
              ~suelleap.cre~ ~override~ // Ellesime
              ~uhogre01.cre~ ~override~ // Madulf
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 17 // alignment: lawful good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~bamng01.cre~  ~override~ // Amnish Guard
              ~bamng02.cre~  ~override~ // Amnish Guard
              ~bdact05.cre~  ~override~ // Zaren
              ~bdhigg01.cre~ ~override~ // Higgold
              ~bdprst01.cre~ ~override~ // Shvanana
              ~bhelm.cre~    ~override~ // Guardian Vottnar
              ~civamng1.cre~ ~override~ // Amnish Soldier
              ~cowenf02.cre~ ~override~ // Cowled Enforcer
              ~cowenf1.cre~  ~override~ // Cowled Enforcer
              ~cowenf2.cre~  ~override~ // Cowled Enforcer
              ~cowenf3.cre~  ~override~ // Cowled Enforcer
              ~cowenf4.cre~  ~override~ // Cowled Enforcer
              ~cowld.cre~    ~override~ // Cowled Wizard
              ~cowled.cre~   ~override~ // Cowled Wizard
              ~cowled01.cre~ ~override~ // Cowled Wizard
              ~cscowl1.cre~  ~override~ // Cowled Wizard
              ~cscowl2.cre~  ~override~ // Cowled Wizard
              ~cscowl3.cre~  ~override~ // Cowled Wizard
              ~cscowl4.cre~  ~override~ // Cowled Wizard
              ~cscowl5.cre~  ~override~ // Cowled Wizard
              ~cscowl6.cre~  ~override~ // Cowled Wizard
              ~cscowl7.cre~  ~override~ // Cowled Wizard
              ~cscowl8.cre~  ~override~ // Cowled Wizard
              ~cscowl9.cre~  ~override~ // Cowled Wizard
              ~cucow1.cre~   ~override~ // Cowled Enforcer
              ~cucow2.cre~   ~override~ // Cowled Enforcer
              ~cucow3.cre~   ~override~ // Cowled Enforcer
              ~cuwiz1.cre~   ~override~ // Cowled Enforcer
              ~cuwiz2.cre~   ~override~ // Cowled Enforcer
              ~cuwiz3.cre~   ~override~ // Cowled Enforcer
              ~cuwiz4.cre~   ~override~ // Cowled Enforcer
              ~cuwiz5.cre~   ~override~ // Cowled Enforcer
              ~cuwiz6.cre~   ~override~ // Cowled Enforcer
              ~cuwizc.cre~   ~override~ // Cowled Enforcer
              ~cuwizsu.cre~  ~override~ // Cowled Enforcer
              ~fulord.cre~   ~override~ // Lord Milsire Donderbeg
              ~jugjer01.cre~ ~override~ // Jermien
              ~killmonk.cre~ ~override~ // Monk
              ~kpdomo01.cre~ ~override~ // Major Domo
              ~loutm02.cre~  ~override~ // Mercenary of Riatvin
              ~mage16c.cre~  ~override~ // Cowled Wizard
              ~mage18a.cre~  ~override~ // Cowled Wizard
              ~mage18z.cre~  ~override~ // Zallanora
              ~mgteos01.cre~ ~override~ // Teos
              ~noblem1.cre~  ~override~ // Nobleman
              ~noblem2.cre~  ~override~ // Nobleman
              ~noblem3.cre~  ~override~ // Lord Ophal
              ~pirsal01.cre~ ~override~ // Sailor
              ~pirsal02.cre~ ~override~ // Sailor
              ~plmetg01.cre~ ~override~ // Metrich Footman
              ~plmetg02.cre~ ~override~ // Metrich Yeoman
              ~ppcowled.cre~ ~override~ // Perth the Adept
              ~quint.cre~    ~override~ // Quint Roenal
              ~shth02.cre~   ~override~ // Goshan
              ~shthlt01.cre~ ~override~ // Jariel
              ~shthstor.cre~ ~override~ // Rattell
              ~trax.cre~     ~override~ // Trax
              ~uddear03.cre~ ~override~ // Finderlig
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 18 // alignment: lawful neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~anno1.cre~    ~override~ // Announcer
              ~aran.cre~     ~override~ // Aran Linvail
              ~aran02.cre~   ~override~ // Aran Linvail
              ~argrim.cre~   ~override~ // Lord Ketlaar Argrim
              ~army01.cre~   ~override~ // Orc
              ~behobs01.cre~ ~override~ // Beholder
              ~bhaal01.cre~  ~override~ // Bhaal
              ~booter.cre~   ~override~ // Booter
              ~booter02.cre~ ~override~ // Booter
              ~bounha02.cre~ ~override~ // Bounty Hunter
              ~bounha03.cre~ ~override~ // Bounty Hunter
              ~cederil.cre~  ~override~ // Deril
              ~cguard1.cre~  ~override~ // Cultist Guard
              ~cguard2.cre~  ~override~ // Cultist Guard
              ~chalslay.cre~ ~override~ // Slayer
              ~copamb02.cre~ ~override~ // Copper Coronet Guard
              ~copamb05.cre~ ~override~ // Copper Coronet Guard
              ~copgreet.cre~ ~override~ // Frankie
              ~corneil.cre~  ~override~ // Corneil
              ~daabol.cre~   ~override~ // Aboleth
              ~degard.cre~   ~override~ // Degardan
              ~dempit.cre~   ~override~ // Pit Fiend
              ~dempit01.cre~ ~override~ // Pit Fiend
              ~dempitsu.cre~ ~override~ // Pit Fiend
              ~docsol03.cre~ ~override~ // Guard Captain
              ~drslayer.cre~ ~override~ // Slayer
              ~duearc01.cre~ ~override~ // Duergar
              ~duecla01.cre~ ~override~ // Ilyich
              ~duegau01.cre~ ~override~ // Duergar
              ~duegau02.cre~ ~override~ // Duergar
              ~duemag01.cre~ ~override~ // Mage
              ~duemag02.cre~ ~override~ // Mage
              ~duergar.cre~  ~override~ // Duergar
              ~duergar1.cre~ ~override~ // Duergar
              ~duergar2.cre~ ~override~ // Duergar
              ~duergar3.cre~ ~override~ // Duergar
              ~elehob01.cre~ ~override~ // Goblin Commando
              ~gphil02.cre~  ~override~ // Philosopher
              ~guard2.cre~   ~override~ // Copper Coronet Guard
              ~guard3.cre~   ~override~ // Copper Coronet Guard
              ~hamek.cre~    ~override~ // Mekrath
              ~hgskl01.cre~  ~override~ // Skeleton Cleric
              ~hgskl02.cre~  ~override~ // Skeleton Assassin
              ~hgskl03.cre~  ~override~ // Skeleton Mage
              ~hgslv01.cre~  ~override~ // Slave Woman
              ~hlmafer.cre~  ~override~ // Maferan
              ~hlolaf.cre~   ~override~ // Olaf Rassmusen
              ~hlrevan.cre~  ~override~ // Revanek
              ~isaea.cre~    ~override~ // Isaea Roenal
              ~jaga1.cre~    ~override~ // Bessen
              ~korgoo01.cre~ ~override~ // Goon
              ~korgoo02.cre~ ~override~ // Goon
              ~korscroo.cre~ ~override~ // Scrooloose
              ~korshag.cre~  ~override~ // Shagbag
              ~lehtin.cre~   ~override~ // Lehtinan
              ~llynis.cre~   ~override~ // Llynis
              ~madam.cre~    ~override~ // Madam Nin
              ~mage8a.cre~   ~override~ // Zyntris
              ~mage8b.cre~   ~override~ // Zyntris
              ~mdrak.cre~    ~override~ // Maharajah
              ~mekimp01.cre~ ~override~ // Imp
              ~mgass01.cre~  ~override~ // Sergeant Natula
              ~mgass02.cre~  ~override~ // Tyrian
              ~mgass03.cre~  ~override~ // Vilhelm
              ~mgket01.cre~  ~override~ // Lord Ketlaar Argrim
              ~mgketg01.cre~ ~override~ // Man-at-Arms
              ~mgketg02.cre~ ~override~ // Archer
              ~mgkhol01.cre~ ~override~ // Khollynnus Paac
              ~mugger1.cre~  ~override~ // Shady Character
              ~mugger2.cre~  ~override~ // Shady Character
              ~mugger3.cre~  ~override~ // Shady Character
              ~mvguard1.cre~ ~override~ // Assassin
              ~naldirt.cre~  ~override~ // Officer Dirth
              ~obssah02.cre~ ~override~ // Sahuagin Priestess
              ~parfig16.cre~ ~override~ // Jalin Tix
              ~parmonk.cre~  ~override~ // Mahar
              ~pirmur03.cre~ ~override~ // Front
              ~pirmur04.cre~ ~override~ // Guard
              ~pirmur05.cre~ ~override~ // Guard Capt
              ~pirmur06.cre~ ~override~ // Guard Capt
              ~pirmur08.cre~ ~override~ // Guard
              ~pirmur11.cre~ ~override~ // Guard
              ~pirmur12.cre~ ~override~ // Guard
              ~pirmur13.cre~ ~override~ // Guard Capt
              ~pirpir06.cre~ ~override~ // Sailor
              ~plshhg01.cre~ ~override~ // Hobgoblin Slayer
              ~plshhg02.cre~ ~override~ // Hobgoblin Wizard
              ~ppaltk1.cre~  ~override~ // Kobold Shaman
              ~ppbhaal.cre~  ~override~ // Bhaal
              ~ppright.cre~  ~override~ // Dunbar
              ~rakmah01.cre~ ~override~ // Maharajah
              ~rakraj01.cre~ ~override~ // Rajah
              ~rakruh01.cre~ ~override~ // Ruhk
              ~raksha01.cre~ ~override~ // Rakshasa
              ~ralej.cre~    ~override~ // Rayic Gethras
              ~reband03.cre~ ~override~ // Bandit
              ~rerak01.cre~  ~override~ // Traveler
              ~rerak02.cre~  ~override~ // Traveler
              ~rerak03.cre~  ~override~ // Traveler
              ~rerak04.cre~  ~override~ // Traveler
              ~rerak05.cre~  ~override~ // Traveler
              ~rerak06.cre~  ~override~ // Traveler
              ~resuna.cre~   ~override~ // Suna Seni
              ~rethie02.cre~ ~override~ // Slaver
              ~rethie03.cre~ ~override~ // Slaver
              ~rethug01.cre~ ~override~ // Thug
              ~rethug02.cre~ ~override~ // Mage
              ~rethug03.cre~ ~override~ // Thug
              ~rethug04.cre~ ~override~ // Thug
              ~rigen01.cre~  ~override~ // Lord Igen Tombelthen
              ~rumar01.cre~  ~override~ // Umar
              ~sargrd05.cre~ ~override~ // Thief
              ~sargrd06.cre~ ~override~ // Mage
              ~sargrd09.cre~ ~override~ // Thief
              ~sevpat02.cre~ ~override~ // Sorcerous Amon
              ~sevpat03.cre~ ~override~ // Pooky
              ~sewarc01.cre~ ~override~ // Orc Archer
              ~sewarc02.cre~ ~override~ // Orc Archer
              ~sewrak01.cre~ ~override~ // Rakshasa
              ~sewyag02.cre~ ~override~ // Orc Archer
              ~shth05.cre~   ~override~ // Joster
              ~slayer.cre~   ~override~ // Slayer
              ~stolethf.cre~ ~override~ // Shadow Thief
              ~suadsaan.cre~ ~override~ // Adsaan
              ~surakmah.cre~ ~override~ // Maharajah
              ~surakraj.cre~ ~override~ // Rajah
              ~surakruh.cre~ ~override~ // Ruhk
              ~suraksha.cre~ ~override~ // Rakshasa
              ~surakw1.cre~  ~override~ // Rakshasa
              ~surakw2.cre~  ~override~ // Rakshasa
              ~surakw3.cre~  ~override~ // Rakshasa
              ~surakw4.cre~  ~override~ // Rakshasa
              ~surly.cre~    ~override~ // Surly
              ~suziyaad.cre~ ~override~ // Ziyaad
              ~tantug01.cre~ ~override~ // Thug
              ~tantug02.cre~ ~override~ // Thug
              ~tantug03.cre~ ~override~ // Thug
              ~telpit2.cre~  ~override~ // Pit Fiend
              ~thief7.cre~   ~override~ // Anishai
              ~tiana.cre~    ~override~ // Tiana
              ~tolmag01.cre~ ~override~ // Mage
              ~tolmag02.cre~ ~override~ // Mage
              ~trrak02.cre~  ~override~ // Saadat
              ~trrak03.cre~  ~override~ // Jalaal
              ~udmaster.cre~ ~override~ // The Master Brain
              ~vaelag.cre~   ~override~ // Vaelag
              ~yaga02.cre~   ~override~ // Lieutenant Mage
              ~yaga04.cre~   ~override~ // Lieutenant Cleric
              ~ysgrunt.cre~  ~override~ // Yaga-Shura Soldier
              ~ysguar02.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar03.cre~ ~override~ // Yaga-Shura Mage
              ~ysguar04.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar05.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar06.cre~ ~override~ // Yaga-Shura Officer
              ~ysmage01.cre~ ~override~ // Yaga-Shura Mage
              ~yssold01.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold02.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold03.cre~ ~override~ // Yaga-Shura Officer
              ~yssold13.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold14.cre~ ~override~ // Yaga-Shura Mage
              ~yssold15.cre~ ~override~ // Yaga-Shura Officer
              ~zilarc01.cre~ ~override~ // Black Reaver
              ~zilfgt01.cre~ ~override~ // Black Reaver
              ~zilfgt02.cre~ ~override~ // Black Reaver
              ~zilmag01.cre~ ~override~ // Black Reaver
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 19 // alignment: lawful evil
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte2.cre~ ~override~ // Dawnbringer Alvanna
              ~amcler01.cre~ ~override~ // Priest of Waukeen
              ~bharval.cre~  ~override~ // High Mornmaster Arval
              ~c6harp.cre~   ~override~ // Malchor Harpell
              ~cscleric.cre~ ~override~ // Dawnmaster Kreel
              ~ELEMchan.cre~ ~override~ // Chan
              ~latlara.cre~  ~override~ // Acolyte Lara
              ~mourner5.cre~ ~override~ // Mourner
              ~proplat.cre~  ~override~ // Morning Knight
              ~radeel.cre~   ~override~ // Radeel
              ~renfeld.cre~  ~override~ // Renfeld
              ~scsain.cre~   ~override~ // Dawnbringer Sain
              ~trskin01.cre~ ~override~ // Raissa
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 33 // alignment: neutral good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amcler02.cre~ ~override~ // Chyil
              ~amfsleep.cre~ ~override~ // Sleeping Woman
              ~bfishw1.cre~  ~override~ // Commoner
              ~cefgt02.cre~  ~override~ // Shadow Druid
              ~cefgt04.cre~  ~override~ // Shadow Druid
              ~cpchick1.cre~ ~override~ // Party's Dog
              ~cpchick2.cre~ ~override~ // Surly's Dog
              ~dgdru01.cre~  ~override~ // Druid
              ~dogwisu.cre~  ~override~ // Rabid Dog
              ~drshlo01.cre~ ~override~ // Loren
              ~drshlo02.cre~ ~override~ // Loren
              ~drshsp01.cre~ ~override~ // Spirit of the Grove
              ~drush.cre~    ~override~ // Drush
              ~ffbiff01.cre~ ~override~ // Biff The Understudy
              ~ffcook.cre~   ~override~ // Uda the Cook
              ~ffcrowd1.cre~ ~override~ // Nobleman
              ~ffcrowd5.cre~ ~override~ // Commoner
              ~figpit.cre~   ~override~ // Storekeep
              ~gdruid.cre~   ~override~ // Druid
              ~golem01.cre~  ~override~ // Clay Golem
              ~grhog01.cre~  ~override~ // Groundhog
              ~igolem02.cre~ ~override~ // Jailkeep Golem
              ~iotyugh.cre~  ~override~ // Otyugh
              ~jaguarsu.cre~ ~override~ // Jaguar
              ~jahaboam.cre~ ~override~ // Jahaboam
              ~kelzomb.cre~  ~override~ // Zombie
              ~merchant.cre~ ~override~ // Bel Dalemark
              ~moose.cre~    ~override~ // Moose
              ~obsgol01.cre~ ~override~ // Guardian Golem
              ~otyugh.cre~   ~override~ // Otyugh
              ~otyugh01.cre~ ~override~ // Otyugh
              ~pheas01.cre~  ~override~ // Pheasant
              ~postul6.cre~  ~override~ // Nobleman
              ~ppiron.cre~   ~override~ // Clay Golem
              ~rabbit.cre~   ~override~ // Rabbit
              ~sbutler.cre~  ~override~ // Commoner
              ~scjerlia.cre~ ~override~ // Jerlia the Ore Merchant
              ~scqar.cre~    ~override~ // Qar Jysstev
              ~sevdru01.cre~ ~override~ // Alatelo De Bonito
              ~shop01.cre~   ~override~ // Mira
              ~shop02.cre~   ~override~ // Arnolinus
              ~shop04.cre~   ~override~ // Enge
              ~shop05.cre~   ~override~ // Perter
              ~shop06.cre~   ~override~ // Hes
              ~shop07.cre~   ~override~ // Storekeep
              ~shop1.cre~    ~override~ // Storekeep
              ~shop2.cre~    ~override~ // Storekeep
              ~shop3.cre~    ~override~ // Storekeep
              ~shop4.cre~    ~override~ // Storekeep
              ~shop5.cre~    ~override~ // Perter
              ~shop6.cre~    ~override~ // Hes
              ~shop7.cre~    ~override~ // Storekeep
              ~shop8.cre~    ~override~ // Galoomp the Bookkeeper
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~sleepmh.cre~  ~override~ // Sleeping Man
              ~slshop01.cre~ ~override~ // Black Market Thief
              ~squirl.cre~   ~override~ // Squirrel
              ~squirr.cre~   ~override~ // Squirrel
              ~tdr10a.cre~   ~override~ // Kyland Lind
              ~tdr10b.cre~   ~override~ // Shadow Druid
              ~tdr6a.cre~    ~override~ // Shadow Druid
              ~tdr8a.cre~    ~override~ // Shadow Druid
              ~tdr8b.cre~    ~override~ // Shadow Druid
              ~trcar01.cre~  ~override~ // Raafee
              ~trcar04.cre~  ~override~ // Caravan Merchant
              ~trcut02.cre~  ~override~ // Nobleman
              ~trevil02.cre~ ~override~ // Guardian of the Source
              ~trevil03.cre~ ~override~ // Master Verthan
              ~trmer01.cre~  ~override~ // Peddler
              ~trmer02.cre~  ~override~ // Merchant
              ~trnobm01.cre~ ~override~ // Sir Parick
              ~trple04.cre~  ~override~ // Customer
              ~trskin02.cre~ ~override~ // Tiris
              ~trtavp05.cre~ ~override~ // Alenina
              ~ttser1.cre~   ~override~ // Jospil
              ~ttser2.cre~   ~override~ // Servant
              ~ttskel.cre~   ~override~ // Skeleton
              ~uddear02.cre~ ~override~ // Uder Mordin
              ~uddoor07.cre~ ~override~ // Skeleton
              ~udduer01.cre~ ~override~ // Carlig
              ~udgolem.cre~  ~override~ // Brain Golem
              ~udtrap02.cre~ ~override~ // Raevilin Strathi
              ~uhogre03.cre~ ~override~ // Minotaur
              ~wauksqu.cre~  ~override~ // Squirrel
              ~welther.cre~  ~override~ // Welther
              ~wmart1.cre~   ~override~ // Joluv
              ~yarin.cre~    ~override~ // Yarin
              ~yscara01.cre~ ~override~ // Merchant
              ~yscara02.cre~ ~override~ // Merchant
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 34 // alignment: true neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amsmug01.cre~ ~override~ // Smuggler
              ~antenos.cre~  ~override~ // Antenos
              ~arntra02.cre~ ~override~ // Trainee
              ~arntra06.cre~ ~override~ // Shadow Thief
              ~bdock1.cre~   ~override~ // Dockhand Ogre
              ~bdock2.cre~   ~override~ // Dockhand Ogre
              ~beast.cre~    ~override~ // Beastmaster
              ~bmugg1.cre~   ~override~ // Mugger
              ~chtaz02.cre~  ~override~ // Tamoko
              ~copcust3.cre~ ~override~ // Nobleman
              ~cujon.cre~    ~override~ // Jon Irenicus
              ~cujon2.cre~   ~override~ // Jon Irenicus
              ~cujon3.cre~   ~override~ // Jon Irenicus
              ~cujon4.cre~   ~override~ // Jon Irenicus
              ~dedsmug.cre~  ~override~ // Smuggler
              ~dpjon01.cre~  ~override~ // Jon Irenicus
              ~dpjon02.cre~  ~override~ // Jon Irenicus
              ~dream2.cre~   ~override~ // Jon Irenicus
              ~driren.cre~   ~override~ // Jon Irenicus
              ~drjon.cre~    ~override~ // Jon Irenicus
              ~elemep01.cre~ ~override~ // Ooze Mephit
              ~elemep02.cre~ ~override~ // Steam Mephit
              ~elemep03.cre~ ~override~ // Salt Mephit
              ~elemep04.cre~ ~override~ // Fire Mephit
              ~elemep05.cre~ ~override~ // Magma Mephit
              ~elemep06.cre~ ~override~ // Earth Mephit
              ~elemep07.cre~ ~override~ // Mineral Mephit
              ~elemep08.cre~ ~override~ // Dust Mephit
              ~elemhydr.cre~ ~override~ // Olhydra
              ~firamb02.cre~ ~override~ // Gerg
              ~firban04.cre~ ~override~ // Orc
              ~firban05.cre~ ~override~ // Orc
              ~firorc02.cre~ ~override~ // Derg the Orc
              ~gorch.cre~    ~override~ // Gorch
              ~gpfam1.cre~   ~override~ // Pitch
              ~hellho01.cre~ ~override~ // Hell Hound
              ~hellslay.cre~ ~override~ // Slayer
              ~hlmage.cre~   ~override~ // Mage
              ~jadermin.cre~ ~override~ // Dermin Courtierdale
              ~jaga3.cre~    ~override~ // Nadinal
              ~jamage1.cre~  ~override~ // Gracien
              ~jamage2.cre~  ~override~ // Malacazar
              ~jarlaxle.cre~ ~override~ // Jarlaxle
              ~jon1.cre~     ~override~ // Jon Irenicus
              ~korcrazy.cre~ ~override~ // Crazyface
              ~kproen01.cre~ ~override~ // Lord Roenall
              ~legdor.cre~   ~override~ // Legdoril
              ~lin.cre~      ~override~ // Lin
              ~obsfir02.cre~ ~override~ // Fire Mephit
              ~obsfir03.cre~ ~override~ // Magma Mephit
              ~obsfir04.cre~ ~override~ // Smoke Mephit
              ~obsfir05.cre~ ~override~ // Hell Hound
              ~obsice02.cre~ ~override~ // Ice Mephit
              ~pardru.cre~   ~override~ // Sorsha
              ~pbhunt04.cre~ ~override~ // Bounty Hunter
              ~pcapt02.cre~  ~override~ // Prison Captain
              ~pcapt03.cre~  ~override~ // Prison Captain
              ~pcapt04.cre~  ~override~ // Prison Captain
              ~pcapt05.cre~  ~override~ // Prison Captain
              ~pcapt06.cre~  ~override~ // Prison Captain
              ~ppireni1.cre~ ~override~ // Coordinator
              ~ppireni2.cre~ ~override~ // Jon Irenicus
              ~reband04.cre~ ~override~ // Bandit
              ~reband05.cre~ ~override~ // Bandit
              ~recler02.cre~ ~override~ // Cleric
              ~redilav.cre~  ~override~ // Dilav
              ~reeldar.cre~  ~override~ // Eldarin
              ~remage02.cre~ ~override~ // Slaver Wizard
              ~rengaa.cre~   ~override~ // Rengaard
              ~sargrd07.cre~ ~override~ // Fighter
              ~sargrd08.cre~ ~override~ // Fighter
              ~sargrd10.cre~ ~override~ // Fighter
              ~sargrd11.cre~ ~override~ // Fighter
              ~sethle.cre~   ~override~ // Sethle
              ~sewdue01.cre~ ~override~ // Duergar Sapper
              ~sewdue02.cre~ ~override~ // Duergar Sapper
              ~seworo01.cre~ ~override~ // Elite Orog
              ~sewyag01.cre~ ~override~ // Duergar Sapper
              ~sewyag03.cre~ ~override~ // Elite Orog
              ~shagbag.cre~  ~override~ // Shagbag
              ~sujon.cre~    ~override~ // Jon Irenicus
              ~sujon2.cre~   ~override~ // Jon Irenicus
              ~teltief1.cre~ ~override~ // Tiefling
              ~terrece.cre~  ~override~ // Terrece
              ~trcut05.cre~  ~override~ // Lady Lilith Lurraxol
              ~trcut06.cre~  ~override~ // Lord Skarmaen Alibakkar
              ~trfued01.cre~ ~override~ // Lady Lilith Lurraxol
              ~trfued05.cre~ ~override~ // Lord Skarmaen Alibakkar
              ~yaga03.cre~   ~override~ // Lieutenant Fighter
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 35 // alignment: neutral evil
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~c6elf1.cre~   ~override~ // Elven Warrior
              ~c6elhan.cre~  ~override~ // Elhan
              ~c6elven2.cre~ ~override~ // Elven War Guard
              ~c6elvenw.cre~ ~override~ // Elven War Guard
              ~chgood04.cre~ ~override~ // Elven Warrior
              ~chgood05.cre~ ~override~ // Elven Warrior
              ~cupris1.cre~  ~override~ // Elven Warrior
              ~cupris2.cre~  ~override~ // Elven Warrior
              ~daelf.cre~    ~override~ // Elven Mage
              ~daelf2.cre~   ~override~ // Elven Mage
              ~dreself1.cre~ ~override~ // Elf Male
              ~dreself2.cre~ ~override~ // Elf Female
              ~dreself3.cre~ ~override~ // Elf Male
              ~dreself4.cre~ ~override~ // Elf Female
              ~dreself5.cre~ ~override~ // Elf Male
              ~dreself6.cre~ ~override~ // Elf Female
              ~dreself7.cre~ ~override~ // Elf Male
              ~hellgen.cre~  ~override~ // Enslaved Genie
              ~jarev4.cre~   ~override~ // Harper
              ~m05elf1.cre~  ~override~ // Elven Warrior
              ~m05elf2.cre~  ~override~ // Elven Warrior
              ~m05spir1.cre~ ~override~ // Elven Spirit
              ~m05spir2.cre~ ~override~ // Elven Spirit
              ~pirmur09.cre~ ~override~ // Golin
              ~sarelf01.cre~ ~override~ // Elven Man
              ~sarelf02.cre~ ~override~ // Elven Man
              ~sarelf03.cre~ ~override~ // Elven Woman
              ~sarelf04.cre~ ~override~ // Elven Woman
              ~sarelf05.cre~ ~override~ // Elf
              ~sarelf06.cre~ ~override~ // Elf
              ~suavatar.cre~ ~override~ // Avatar of Rillifane
              ~sudead01.cre~ ~override~ // Elven Warrior
              ~sudead02.cre~ ~override~ // Elven Warrior
              ~sudead03.cre~ ~override~ // Elven Warrior
              ~sudemin.cre~  ~override~ // Priestess Demin
              ~suelf1.cre~   ~override~ // Elf
              ~suelf10.cre~  ~override~ // Reirra
              ~suelf12.cre~  ~override~ // Captain Aduo'on
              ~suelf13.cre~  ~override~ // Elven Warrior
              ~suelf2.cre~   ~override~ // Elf
              ~suelf3.cre~   ~override~ // Elven Warrior
              ~suelf6.cre~   ~override~ // Elven Warrior
              ~suelf7.cre~   ~override~ // Elven Warrior
              ~suelf8.cre~   ~override~ // Elven Warrior
              ~suelfw1.cre~  ~override~ // Elven Warrior
              ~suelfw10.cre~ ~override~ // Elven Battle Mage
              ~suelfw11.cre~ ~override~ // Elven Battle Mage
              ~suelfw12.cre~ ~override~ // Elven Battle Mage
              ~suelfw13.cre~ ~override~ // Elven Archer
              ~suelfw14.cre~ ~override~ // Elven Archer
              ~suelfw15.cre~ ~override~ // Elven Archer
              ~suelfw2.cre~  ~override~ // Elven Warrior
              ~suelfw3.cre~  ~override~ // Elven Warrior
              ~suelfw4.cre~  ~override~ // Elven Warrior
              ~suelfw5.cre~  ~override~ // Elven Warrior
              ~suelfw6.cre~  ~override~ // Elven Warrior
              ~suelfw7.cre~  ~override~ // Elven Warrior
              ~suelfw8.cre~  ~override~ // Elven Warrior
              ~suelfw9.cre~  ~override~ // Elven Battle Mage
              ~suelhan.cre~  ~override~ // Elhan
              ~suelleg1.cre~ ~override~ // Elven Warrior
              ~suendel1.cre~ ~override~ // Elven Warrior
              ~suendel2.cre~ ~override~ // Elven Warrior
              ~suendel3.cre~ ~override~ // Elf Male
              ~suendel4.cre~ ~override~ // Elf Female
              ~suendel5.cre~ ~override~ // Elf
              ~suendel6.cre~ ~override~ // Elf
              ~suendel7.cre~ ~override~ // Elven Warrior
              ~suendel8.cre~ ~override~ // Elven Warrior
              ~sumoon.cre~   ~override~ // Elven Warrior
              ~udelf01.cre~  ~override~ // War Elf
              ~udelf02.cre~  ~override~ // War Elf
              ~udelf03.cre~  ~override~ // War Elf
              ~udelf04.cre~  ~override~ // War Elf
              ~udelf05.cre~  ~override~ // War Elf
              ~warsage.cre~  ~override~ // Elven War Sage
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 49 // alignment: chaotic good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~c6lanf.cre~   ~override~ // Lanfear
              ~clrani01.cre~ ~override~ // Rania
              ~crothf01.cre~ ~override~ // Tiiro
              ~crothf02.cre~ ~override~ // Aulava
              ~gereth.cre~   ~override~ // Gereth
              ~gorcamb.cre~  ~override~ // Aesgareth
              ~gorsal.cre~   ~override~ // Saladrex
              ~gromnir.cre~  ~override~ // Gromnir Il-Khan
              ~lout.cre~     ~override~ // Vittorio
              ~rngwlf01.cre~ ~override~ // Anath
              ~rngwlf02.cre~ ~override~ // Anath
              ~rngwlf03.cre~ ~override~ // Anath
              ~rngwlf04.cre~ ~override~ // Anath
              ~rngwlf05.cre~ ~override~ // Anath
              ~sarthf01.cre~ ~override~ // Hectan
              ~sarthf02.cre~ ~override~ // Squip
              ~shth01.cre~   ~override~ // Hanz
              ~shth03.cre~   ~override~ // Kretor
              ~shth04.cre~   ~override~ // Morsa
              ~shth06.cre~   ~override~ // Varia
              ~shthdr01.cre~ ~override~ // Brannel
              ~shthlt02.cre~ ~override~ // Lathan
              ~slcent.cre~   ~override~ // Amnish Centurion
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 50 // alignment: chaotic neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte1.cre~ ~override~ // Talon Zogas
              ~ar18prie.cre~ ~override~ // Priest of Cyric
              ~bazeye01.cre~ ~override~ // Iycanth the Mad
              ~bazeye02.cre~ ~override~ // Iycanth the Mad
              ~c6drow1.cre~  ~override~ // Drow
              ~caehan.cre~   ~override~ // Caehan
              ~cldad.cre~    ~override~ // Talon Nirkhas
              ~clstkn01.cre~ ~override~ // Storm Knight
              ~cltalp01.cre~ ~override~ // Weather Master
              ~daqilue.cre~  ~override~ // Qilue
              ~dvampfl.cre~  ~override~ // Vampire
              ~eletro02.cre~ ~override~ // Troll
              ~gnlcap01.cre~ ~override~ // Gnoll Captain
              ~gnleli01.cre~ ~override~ // Gnoll Elite
              ~gnlsla01.cre~ ~override~ // Gnoll Slasher
              ~gnlvet01.cre~ ~override~ // Gnoll Veteran
              ~gnlwar01.cre~ ~override~ // Gnoll
              ~gnoll01.cre~  ~override~ // Gnoll
              ~gnollsu.cre~  ~override~ // Gnoll Elite
              ~gpmage1.cre~  ~override~ // N'ashtar
              ~gppri1.cre~   ~override~ // Chandrilla
              ~gpsimb.cre~   ~override~ // Simbja
              ~hlketta.cre~  ~override~ // Ketta
              ~hlketta2.cre~ ~override~ // Ketta
              ~hlskull.cre~  ~override~ // Golden Skull
              ~hobarc01.cre~ ~override~ // Hobgoblin Archer
              ~hobarc02.cre~ ~override~ // Hobgoblin Archer
              ~hobcap01.cre~ ~override~ // Hobgoblin Captain
              ~hobeli01.cre~ ~override~ // Hobgoblin Elite
              ~hobwar01.cre~ ~override~ // Hobgoblin Warrior
              ~hobwiz01.cre~ ~override~ // Hobgoblin Wizard
              ~jaerto1.cre~  ~override~ // Jarden
              ~jaerto2.cre~  ~override~ // Turg
              ~jaerto3.cre~  ~override~ // Tamile
              ~jaerto4.cre~  ~override~ // Wurn
              ~jaertof.cre~  ~override~ // Ertof Dand
              ~jaga2.cre~    ~override~ // Kail
              ~jaga4.cre~    ~override~ // Iko
              ~kalah.cre~    ~override~ // Kalah
              ~kalah2.cre~   ~override~ // Kalah
              ~kaol.cre~     ~override~ // Kaol
              ~kaypal01.cre~ ~override~ // Anarg
              ~nalla.cre~    ~override~ // Stormherald Nallabir
              ~obshal01.cre~ ~override~ // Entu
              ~obshal03.cre~ ~override~ // Necre
              ~obshal06.cre~ ~override~ // Taibela
              ~ogre01.cre~   ~override~ // Ogre
              ~pirmur01.cre~ ~override~ // Galvena
              ~pirmur02.cre~ ~override~ // Assassin
              ~pirpir01.cre~ ~override~ // Pirate
              ~pirpir02.cre~ ~override~ // Andar the Pirate
              ~pirpir03.cre~ ~override~ // Olben the Pirate
              ~pirpir05.cre~ ~override~ // Chremy
              ~pirpir07.cre~ ~override~ // Pirate Bill
              ~pirpir08.cre~ ~override~ // Pirate Dan
              ~pirpir09.cre~ ~override~ // Pirate Jimmy
              ~pirpir10.cre~ ~override~ // Pirate Scotty
              ~pirpir11.cre~ ~override~ // Pirate Paul
              ~pirpir12.cre~ ~override~ // Pirate Newf
              ~pirsea01.cre~ ~override~ // Pirate Captain
              ~pirsea02.cre~ ~override~ // Pirate
              ~pirsea03.cre~ ~override~ // Pirate
              ~plass02.cre~  ~override~ // Assassin
              ~plass03.cre~  ~override~ // Assassin
              ~plass04.cre~  ~override~ // Assassin
              ~ppdesh.cre~   ~override~ // Desharik
              ~ppdesh2.cre~  ~override~ // Desharik
              ~ppdoor.cre~   ~override~ // Pirate Door Guard
              ~ppduel1.cre~  ~override~ // Andante
              ~ppduel2.cre~  ~override~ // Dirbish the Black
              ~ppduelc.cre~  ~override~ // Duel Coordinator
              ~ppguard.cre~  ~override~ // Pirate
              ~ppguarda.cre~ ~override~ // Pirate
              ~pplackey.cre~ ~override~ // Pirate
              ~ppldr01.cre~  ~override~ // Pirate Leader
              ~ppmag01.cre~  ~override~ // Pirate Mage
              ~pppirate.cre~ ~override~ // Pirate
              ~ppsail01.cre~ ~override~ // Pirate
              ~ppsail02.cre~ ~override~ // Pirate
              ~ppsail03.cre~ ~override~ // Pirate
              ~ppthf01.cre~  ~override~ // Pirate
              ~ppthf02.cre~  ~override~ // Pirate
              ~pptiax.cre~   ~override~ // Tiax
              ~pptiax2.cre~  ~override~ // Tiax
              ~ppumb01.cre~  ~override~ // Priestess of Umberlee
              ~reband01.cre~ ~override~ // Bandit
              ~reband02.cre~ ~override~ // Bandit
              ~rorcs01.cre~  ~override~ // Orog
              ~ruffian.cre~  ~override~ // Amalas
              ~sahkng01.cre~ ~override~ // King Ixilthetocal
              ~sahkng02.cre~ ~override~ // King Ixilthetocal
              ~samia.cre~    ~override~ // Samia
              ~sarbul04.cre~ ~override~ // Gromnir Soldier
              ~sarbul05.cre~ ~override~ // Gromnir Soldier
              ~sarbul06.cre~ ~override~ // Il-Khan Soldier
              ~sarbul07.cre~ ~override~ // Il-Khan Soldier
              ~scyarryl.cre~ ~override~ // Talon Yarryl
              ~sevpat01.cre~ ~override~ // Mencar Pebblecrusher
              ~sevpat04.cre~ ~override~ // Smaeluv Orcslicer
              ~shadel.cre~   ~override~ // Shade Lord
              ~slapri.cre~   ~override~ // Priest of Cyric
              ~talkni01.cre~ ~override~ // Storm Knight
              ~talkni02.cre~ ~override~ // Storm Knight
              ~talmiss.cre~  ~override~ // Mistress Ada
              ~talmiss2.cre~ ~override~ // Mistress Ada
              ~talvilon.cre~ ~override~ // Acolyte Vilon
              ~tanthf01.cre~ ~override~ // Rune Assassin
              ~telsuc1.cre~  ~override~ // Alu-Fiend
              ~teltief3.cre~ ~override~ // Tiefling
              ~trevil01.cre~ ~override~ // Lord Khellon Menold
              ~trskin03.cre~ ~override~ // Rejiek Hidesman
              ~trskin06.cre~ ~override~ // Darsidian Moor
              ~trskin3b.cre~ ~override~ // Rejiek Hidesman
              ~trskin6b.cre~ ~override~ // Darsidian Moor
              ~trskind2.cre~ ~override~ // Darsidian Moor
              ~uddoor01.cre~ ~override~ // Drow
              ~uddoor02.cre~ ~override~ // Drow
              ~uddoor03.cre~ ~override~ // Drow
              ~uddrow06.cre~ ~override~ // Ilmryn
              ~uddrow12.cre~ ~override~ // Drow
              ~uddrow14.cre~ ~override~ // Drow
              ~uddrow15.cre~ ~override~ // Drow
              ~uddrow18.cre~ ~override~ // Drow
              ~uddrow20.cre~ ~override~ // Egg Guard
              ~uddrow21.cre~ ~override~ // Egg Guard
              ~uddrow23.cre~ ~override~ // Drow
              ~uddrow24.cre~ ~override~ // Drow
              ~uddrow25.cre~ ~override~ // Drow
              ~uddrow26.cre~ ~override~ // Drow
              ~uddrow27.cre~ ~override~ // Drow
              ~uddrow28.cre~ ~override~ // Drow
              ~uddrow29.cre~ ~override~ // Drow
              ~uddrow31.cre~ ~override~ // Drow
              ~uddrow36.cre~ ~override~ // Handmaiden of Lolth
              ~uddrow37.cre~ ~override~ // Drow
              ~udrunner.cre~ ~override~ // Drow
              ~vampbat.cre~  ~override~ // Vampire
              ~vicg2.cre~    ~override~ // Fanatic
              ~yssold04.cre~ ~override~ // Yaga-Shura Elite
              ~yssold16.cre~ ~override~ // Cleric Of Talos
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 51 // alignment: chaotic evil
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BDTURM03.CRE~ ~override~
              ~CLCOTI01.CRE~ ~override~
              ~COWENF1.CRE~  ~override~
              ~COWENF3.CRE~  ~override~
              ~COWENF4.CRE~  ~override~
              ~EYEVIG01.CRE~ ~override~
              ~FIRMAG01.CRE~ ~override~
              ~FSMAGE01.CRE~ ~override~
              ~FSMAGE02.CRE~ ~override~
              ~FSMAGE03.CRE~ ~override~
              ~HLLAYEN.CRE~  ~override~
              ~HSPECTR2.CRE~ ~override~
              ~RIFTG03.CRE~  ~override~
              ~SAHBEH03.CRE~ ~override~
              ~SLVIC02.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 1 // human
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~ALUFIE01.CRE~ ~override~
              ~ARNMAN07.CRE~ ~override~
              ~BOUNHA.CRE~   ~override~
              ~CHEVIL09.CRE~ ~override~
              ~COPAMB03.CRE~ ~override~
              ~CSIREN.CRE~   ~override~
              ~CSJON.CRE~    ~override~
              ~CUJON.CRE~    ~override~
              ~CUJON2.CRE~   ~override~
              ~CUJON3.CRE~   ~override~
              ~CUJON4.CRE~   ~override~
              ~D1MOTHEL.CRE~ ~override~
              ~DEMFIG02.CRE~ ~override~
              ~DPJON01.CRE~  ~override~
              ~DPJON02.CRE~  ~override~
              ~DREAM2.CRE~   ~override~
              ~DRIREN.CRE~   ~override~
              ~DRJON.CRE~    ~override~
              ~EYESNT01.CRE~ ~override~
              ~GORSTA02.CRE~ ~override~
              ~GORSTA09.CRE~ ~override~
              ~GORSTA11.CRE~ ~override~
              ~HARPASS1.CRE~ ~override~
              ~HELLJON.CRE~  ~override~
              ~HELLJON2.CRE~ ~override~
              ~HLARCH.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~HSPECTR3.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~JON1.CRE~     ~override~
              ~LIFE01.CRE~   ~override~
              ~LIFE02.CRE~   ~override~
              ~LIFE03.CRE~   ~override~
              ~LIFE04.CRE~   ~override~
              ~MGAPPR01.CRE~ ~override~
              ~PPDRA2.CRE~   ~override~
              ~PPDRADEE.CRE~ ~override~
              ~PPIRENI1.CRE~ ~override~
              ~PPIRENI2.CRE~ ~override~
              ~PPSUNA.CRE~   ~override~
              ~RIELEV.CRE~   ~override~
              ~SENANI01.CRE~ ~override~
              ~SENANI02.CRE~ ~override~
              ~SENDRO01.CRE~ ~override~
              ~SENDRO02.CRE~ ~override~
              ~SENFOD01.CRE~ ~override~
              ~SENFOD02.CRE~ ~override~
              ~SENGUA01.CRE~ ~override~
              ~SENKEN01.CRE~ ~override~
              ~SUELF10.CRE~  ~override~
              ~SUJON.CRE~    ~override~
              ~SUJON2.CRE~   ~override~
              ~SUNA.CRE~     ~override~
              ~THRAXI.CRE~   ~override~
              ~TOLMAG02.CRE~ ~override~
              ~VALRAN01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 2 // elf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BEAST.CRE~    ~override~
              ~DKHALID.CRE~  ~override~
              ~DKHALID2.CRE~ ~override~
              ~KAYSMG01.CRE~ ~override~
              ~LIN.CRE~      ~override~
              ~SHANK.CRE~    ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 3 // half-elf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~D1MOTHDW.CRE~ ~override~
              ~DRUFF2.CRE~   ~override~
              ~DUEMAG01.CRE~ ~override~
              ~DUEMAG02.CRE~ ~override~
              ~GORSTA04.CRE~ ~override~
              ~NEB.CRE~      ~override~
              ~SARDW01.CRE~  ~override~
              ~SARDW02.CRE~  ~override~
              ~SLEEPDW.CRE~  ~override~
              ~TOBPAR05.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 4 // dwarf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BBEGG2.CRE~   ~override~
              ~CHGOOD01.CRE~ ~override~
              ~D1MOTHHA.CRE~ ~override~
              ~DISRUP01.CRE~ ~override~
              ~ESCORT2.CRE~  ~override~
              ~ESCORT2A.CRE~ ~override~
              ~MOURNER6.CRE~ ~override~
              ~SARBHA02.CRE~ ~override~
              ~SARHAL.CRE~   ~override~
              ~TREVIL01.CRE~ ~override~
              ~WELLYN.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 5 // halfling
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~EYESEK01.CRE~ ~override~
              ~UDSVIR07.CRE~ ~override~
              ~UDSVIR08.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 6 // gnome
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~EYEGOR01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 102 // basilisk
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GIBBER01.CRE~ ~override~
              ~GIBBERSU.CRE~ ~override~
              ~FSGIBB.CRE~   ~override~
              ~TTGIBB.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 109 // gibberling
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HLMAFER.CRE~ ~override~
  WRITE_BYTE 0x0272 110 // gnoll
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HOBELI01.CRE~ ~override~
              ~HOBGOB01.CRE~ ~override~
              ~HOBGOBSU.CRE~ ~override~
  WRITE_BYTE 0x0272 111 // hobgoblin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~FSGOBL.CRE~  ~override~
              ~ICGOB03.CRE~ ~override~
              ~ICGOB04.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 112 // kobold
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~CEGLUT.CRE~   ~override~
              ~GORSTA12.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 113 // ogre
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHSKEL.CRE~  ~override~
              ~SKELWA02.CRE~ ~override~
              ~SKELWA03.CRE~ ~override~
              ~SKELWASU.CRE~ ~override~
  WRITE_BYTE 0x0272 115 // skeleton
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SLIFIS01.CRE~ ~override~
              ~SLIFIS02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 119 // slime
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HAMASU.CRE~   ~override~
              ~KSLAVE01.CRE~ ~override~
              ~RSPIRIT1.CRE~ ~override~
  WRITE_BYTE 0x0272 120 // fairy
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~AEWERE2.CRE~ ~override~
              ~AEWERE3.CRE~ ~override~
              ~AEWERE4.CRE~ ~override~
              ~AEWERE5.CRE~ ~override~
              ~AEWERE6.CRE~ ~override~
  WRITE_BYTE 0x0272 122 // lycanthrope
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GORMIND.CRE~  ~override~
              ~MINDUL01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 124 // mindflayer
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~OTYUGH01.CRE~ ~override~
  WRITE_BYTE 0x0272 127 // otyugh
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~RAKRUH01.CRE~ ~override~
  WRITE_BYTE 0x0272 128 // rakshasa
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 129 // troll
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHANGU.CRE~ ~override~
  WRITE_BYTE 0x0272 131 // sahuagin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BODFGT01.CRE~ ~override~
              ~BODFGT02.CRE~ ~override~
              ~DRSHSP01.CRE~ ~override~
              ~ELEARB01.CRE~ ~override~
              ~ELEARB02.CRE~ ~override~
              ~ELEARB03.CRE~ ~override~
              ~ELEARB04.CRE~ ~override~
              ~ELEARB05.CRE~ ~override~
              ~ELEARB06.CRE~ ~override~
              ~ELEARB07.CRE~ ~override~
              ~ELEARB08.CRE~ ~override~
              ~ELEARB09.CRE~ ~override~
              ~ELEARB10.CRE~ ~override~
              ~ELEARB11.CRE~ ~override~
              ~ELEPUZ01.CRE~ ~override~
              ~ELEPUZ02.CRE~ ~override~
              ~ELEPUZ03.CRE~ ~override~
              ~ELEPUZ04.CRE~ ~override~
              ~SENSTALK.CRE~ ~override~
              ~STALKE.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 133 // spectre
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BANSHE01.CRE~ ~override~
              ~EYEDED01.CRE~ ~override~
              ~FIRMON01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 134 // wraith
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HAKSU.CRE~    ~override~
              ~NISHRUSU.CRE~ ~override~
  WRITE_BYTE 0x0272 136 // mist
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~COPLION.CRE~  ~override~
              ~JAGUARSU.CRE~ ~override~
              ~NCAT.CRE~     ~override~
              ~SLCAT.CRE~    ~override~
              ~SPIRLION.CRE~ ~override~
              ~TRANIM03.CRE~ ~override~
  WRITE_BYTE 0x0272 137 // cat
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GIAFIR01.CRE~ ~override~
              ~YAGASPIR.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 142 // giant
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~AR18FIG.CRE~  ~override~
              ~GROMG02.CRE~  ~override~
              ~HLOLAF.CRE~   ~override~
              ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~SARBUL04.CRE~ ~override~
              ~TOBBAN02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 143 // orc
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~PLYSALA.CRE~ ~override~
  WRITE_BYTE 0x0272 145 // elemental
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHZOMB.CRE~  ~override~
              ~ZOMBIE01.CRE~ ~override~
              ~ZOMBSE01.CRE~ ~override~
  WRITE_BYTE 0x0272 148 // zombie
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~CEDELICH.CRE~ ~override~
              ~HGSKU01.CRE~  ~override~
              ~HLSKULL.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 150 // lich
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~RABBIT.CRE~   ~override~
              ~RABBIT01.CRE~ ~override~
  WRITE_BYTE 0x0272 151 // rabbit
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BOUNHA04.CRE~ ~override~
              ~ICLIZ01.CRE~  ~override~
              ~ICLIZ02.CRE~  ~override~
  WRITE_BYTE 0x0272 154 // yuanti
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~PLANET01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 158 // planatar [sic]
  END
  BUT_ONLY_IF_IT_CHANGES

// clasify ettins as ettin race so Crom Faeyr will work
COPY_EXISTING ~pettin.cre~   ~override~
              ~plshfg01.cre~ ~override~
              ~plshfg02.cre~ ~override~
              ~sahoty01.cre~ ~override~
  WRITE_BYTE 0x272 199 // race: ettin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 201 // sword
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~DAABOL.CRE~  ~override~
              ~MEPHSP1.CRE~ ~override~
              ~MEPHSP2.CRE~ ~override~
              ~MEPHSP3.CRE~ ~override~
              ~MEPHSP4.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 255 // unk
  END
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~icyuan03.cre~ ~override~
              ~icyuan05.cre~ ~override~
              ~kpsham01.cre~ ~override~
              ~pbhunt03.cre~ ~override~
              ~pbhunt04.cre~ ~override~
              ~planet01.cre~ ~override~
              ~planevil.cre~ ~override~
              ~plangood.cre~ ~override~
              ~planwish.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 1 // mage
  END
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~icyuan01.cre~ ~override~
              ~icyuan02.cre~ ~override~
              ~icyuan04.cre~ ~override~
              ~kpyuan01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 2 // fighter
  END
  BUT_ONLY_IF_IT_CHANGES

// devas need to be a spellcasting classs, otherwise dispel magic cast at level 1 and fails
COPY_EXISTING ~devagood.cre~ ~override~
              ~devaevil.cre~ ~override~
              ~devast01.cre~ ~override~
              ~devmon01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 3 // cleric
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~nwyvbab.cre~  ~override~
              ~plywyvrn.cre~ ~override~
              ~wyvbab01.cre~ ~override~
              ~wyvern01.cre~ ~override~
              ~wyvgre01.cre~ ~override~
  WRITE_BYTE 0x273 149 // wyvern
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~gorjelf2.cre~ ~override~
              ~gorjelfu.cre~ ~override~
              ~pudden01.cre~ ~override~
              ~pudden02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 151 // mustard jelly
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~jelgra01.cre~ ~override~
  WRITE_BYTE 0x273 153 // gray ooze
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~gorjelgr.cre~ ~override~
              ~jelgre01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 154 // green slime
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~OTYUGH01.CRE~ ~override~
  WRITE_BYTE 0x0273 165 // otyugh
  BUT_ONLY_IF_IT_CHANGES

// class fixes. note that dgtrol0[12] are excluded so as to not break druid grove scripts
COPY_EXISTING ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 167 // class: troll
  END
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~pettin.cre~   ~override~
  WRITE_BYTE 0x273 180 // giant
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~elemchan.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 186 // elemental: air
  END
  BUT_ONLY_IF_IT_CHANGES

// Wave halberd should work against salamanders
COPY_EXISTING ~plysala.cre~ ~override~
  WRITE_BYTE 0x273 187 // class: elemental_fire
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~sahzomb.cre~   ~override~
  WRITE_BYTE 0x273 198 // zombie_normal
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~chickdef.cre~ ~override~
              ~chicke.cre~   ~override~
              ~chicker.cre~  ~override~
              ~cow.cre~      ~override~
              ~cowh.cre~     ~override~
              ~deadcow1.cre~ ~override~
              ~deadcow2.cre~ ~override~
              ~gorstalk.cre~ ~override~
              ~mephsp1.cre~  ~override~
              ~mephsp2.cre~  ~override~
              ~mephsp3.cre~  ~override~
              ~mephsp4.cre~  ~override~
              ~nchick.cre~   ~override~
              ~ncow.cre~     ~override~
              ~senstalk.cre~ ~override~
              ~stalke.cre~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 255 // no class
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~KUOARC20.CRE~ ~override~
              ~KUOCLE20.CRE~ ~override~
              ~SAHCHF01.CRE~ ~override~
              ~SHAGRL01.CRE~ ~override~
              ~TOWNC01.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 1 // humanoid
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~EYEEGL01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 2 // animal
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~BODTAN.CRE~   ~override~
              ~CEDELICH.CRE~ ~override~
              ~D1GHOST.CRE~  ~override~
              ~D1GORI.CRE~   ~override~
              ~D1MOTHDW.CRE~ ~override~
              ~D1MOTHEL.CRE~ ~override~
              ~D1MOTHHA.CRE~ ~override~
              ~D1MOTHHU.CRE~ ~override~
              ~D1SKEL.CRE~   ~override~
              ~HLSKULL.CRE~  ~override~
              ~LAUNE.CRE~    ~override~
              ~RSPIRIT1.CRE~ ~override~
              ~SAHBEH02.CRE~ ~override~
              ~SDSHADFI.CRE~ ~override~
              ~SDSHADOW.CRE~ ~override~
              ~SKELDED.CRE~  ~override~
              ~WELLYN.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 4 // undead
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~dgtrol01.cre~ ~override~
              ~dgtrol02.cre~ ~override~
              ~DRUEAR01.CRE~ ~override~
              ~ELAIRL01.CRE~ ~override~
              ~ELAIRSU1.CRE~ ~override~
              ~ELAIRSU2.CRE~ ~override~
              ~ELAIRSU3.CRE~ ~override~
              ~ELAIRSUW.CRE~ ~override~
              ~ELEARPR.CRE~  ~override~
              ~ELEARPR2.CRE~ ~override~
              ~ELEARPR3.CRE~ ~override~
              ~ELEARSU2.CRE~ ~override~
              ~ELEARSU3.CRE~ ~override~
              ~ELEARSU4.CRE~ ~override~
              ~ELEARSUW.CRE~ ~override~
              ~ELFIRL01.CRE~ ~override~
              ~ELFIRSUW.CRE~ ~override~
              ~GENIE02.CRE~  ~override~
              ~GORAIR01.CRE~ ~override~
              ~GORSTA12.CRE~ ~override~
              ~GIAFIR01.CRE~ ~override~
              ~IGOLFLE3.CRE~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~MDEARTH.CRE~  ~override~
              ~MDEARTH2.CRE~ ~override~
              ~MEKEAR01.CRE~ ~override~
              ~OBSGOL02.CRE~ ~override~
              ~plangood.cre~ ~override~
              ~PLSHFG01.CRE~ ~override~
              ~PLSHFG02.CRE~ ~override~
              ~SAHOTY01.CRE~ ~override~
              ~SARFAKI2.CRE~ ~override~
              ~SARFAKIE.CRE~ ~override~
              ~SUELEW2.CRE~  ~override~
              ~SWAAIR01.CRE~ ~override~
              ~SWAAIR02.CRE~ ~override~
              ~SWAEAR01.CRE~ ~override~
              ~SWAEAR02.CRE~ ~override~
              ~SWAFIR01.CRE~ ~override~
              ~SWAAIR01.CRE~ ~override~
              ~TORGAL.CRE~   ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
              ~UHOGRE03.CRE~ ~override~
              ~YSCARA03.CRE~ ~override~
              ~YSGUAR01.CRE~ ~override~
              ~YSSOLD10.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 5 // giant humanoid
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 101 // weapon
  END
  BUT_ONLY_IF_IT_CHANGES

// general fixes
COPY_EXISTING ~BOUNHA04.CRE~ ~override~
              ~DAABOL.CRE~   ~override~
              ~DASPITRO.CRE~ ~override~
              ~DRAGBLAC.cre~ ~override~
              ~dragshad.cre~ ~override~
              ~FINSOL04.CRE~ ~override~
              ~GLBEAR.CRE~   ~override~
              ~GORMIM01.CRE~ ~override~
              ~GORMIM02.CRE~ ~override~
              ~GORMIM03.CRE~ ~override~
              ~GORMIM04.CRE~ ~override~
              ~HAKSU.CRE~    ~override~
              ~HDRAGSIL.cre~ ~override~
              ~HDRAGRED.cre~ ~override~
              ~ICSALCOL.CRE~ ~override~
              ~ICSALFIR.CRE~ ~override~
              ~JUGMIM01.CRE~ ~override~
//              ~KPTROL05.CRE~ ~override~
              ~MEPHSP1.CRE~  ~override~
              ~MEPHSP2.CRE~  ~override~
              ~MEPHSP3.CRE~  ~override~
              ~MEPHSP4.CRE~  ~override~
              ~MIMIC01.CRE~  ~override~
              ~NISHRUSU.CRE~ ~override~
              ~OBSDEM04.CRE~ ~override~
              ~PLANEVIL.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
//              ~PPTROLL1.CRE~ ~override~
              ~RIFTCR04.CRE~ ~override~
//              ~TROLSI01.CRE~ ~override~
//              ~TROLSI02.CRE~ ~override~
//              ~TROLSN01.CRE~ ~override~
//              ~TROLSN02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 255 // monster
  END
  BUT_ONLY_IF_IT_CHANGES

// sex fixes
COPY_EXISTING ~BAZLIZ01.CRE~ ~override~
              ~BAZLIZ02.CRE~ ~override~
              ~C6GOFUS.CRE~  ~override~
              ~C6KACH.CRE~   ~override~
              ~COWENF1.CRE~  ~override~
              ~cscleric.cre~ ~override~
              ~DERRICK.CRE~  ~override~
              ~dpmon01.cre~  ~override~
              ~DROFOD03.CRE~ ~override~
              ~ESCORT3.CRE~  ~override~
              ~KAYSMG01.CRE~ ~override~
              ~KPSOLD10.CRE~ ~override~
              ~KUOARC20.CRE~ ~override~
              ~PALERN.CRE~   ~override~
              ~PALKNI02.CRE~ ~override~
              ~PALKNI04.CRE~ ~override~
              ~PALKNI05.CRE~ ~override~
              ~PCAPT02.CRE~  ~override~
              ~SARBHA01.CRE~ ~override~
              ~SLVIC02.CRE~  ~override~
              ~TOBPAR04.CRE~ ~override~
              ~trfued02.cre~ ~override~
              ~WINNKEEP.CRE~ ~override~
              ~YARMY03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 1 // male
  END
  BUT_ONLY_IF_IT_CHANGES

// more sex fixes
COPY_EXISTING ~AMFEM01.CRE~  ~override~
              ~AMFEM02.CRE~  ~override~
              ~AMGIRL01.CRE~ ~override~
              ~AMMONK08.CRE~ ~override~
              ~AR18ARCH.CRE~ ~override~
              ~C6CATTI.CRE~  ~override~
              ~C6CATTI2.CRE~ ~override~
              ~C6CLER3.CRE~  ~override~
              ~C6DEL.CRE~    ~override~
              ~C6GUEN.CRE~   ~override~
              ~C6GUEN2.CRE~  ~override~
              ~CEFALD02.CRE~ ~override~
              ~CHICKDEF.CRE~ ~override~
              ~CHICKE.CRE~   ~override~
              ~CHICKER.CRE~  ~override~
              ~COW.CRE~      ~override~
              ~CSHECK3.CRE~  ~override~
              ~CSSUPP2.CRE~  ~override~
              ~DEADCOW1.CRE~ ~override~
              ~DEADCOW2.CRE~ ~override~
              ~DEER01.CRE~   ~override~
              ~DEVAEVIL.CRE~ ~override~
              ~DEVAST01.CRE~ ~override~
              ~DEVMON01.CRE~ ~override~
              ~DPFEMALE.CRE~ ~override~
              ~DPSTAT05.CRE~ ~override~
              ~DROFOD02.CRE~ ~override~ // Drow, female mage (Wisp)
              ~DROFOD04.CRE~ ~override~
              ~DROW04.CRE~   ~override~
              ~DSBODY01.CRE~ ~override~
              ~FANGEL01.CRE~ ~override~
              ~FINSOL01.CRE~ ~override~
              ~garkid01.cre~ ~override~
              ~GEMCH01.CRE~  ~override~
              ~GEMCH02.CRE~  ~override~
              ~GORSTA05.CRE~ ~override~
              ~HLSHYR.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~MGKHOL01.CRE~ ~override~
              ~NCHICK.CRE~   ~override~
              ~NCOW.CRE~     ~override~
              ~NYMPHSU.CRE~  ~override~
              ~PIRFSH02.CRE~ ~override~
              ~PIRSAL02.CRE~ ~override~
              ~PLANET01.CRE~ ~override~
              ~PLANEVIL.CRE~ ~override~
              ~PLANGOOD.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
              ~PPMAG01.CRE~  ~override~
              ~SENDAI7.CRE~  ~override~
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~SOLAR.CRE~    ~override~
              ~SOLAR01.CRE~  ~override~
              ~SUENDEL2.CRE~ ~override~
              ~SUENDEL4.CRE~ ~override~
              ~SUENDEL6.CRE~ ~override~
              ~SUENDEL8.CRE~ ~override~
              ~TOBPAR02.CRE~ ~override~
              ~TRFTOW04.CRE~ ~override~
              ~TRSKIN01.CRE~ ~override~
              ~UDDOOR06.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~VAMPAER.CRE~  ~override~
              ~VAMPJAH.CRE~  ~override~
              ~VAMPVIC.CRE~  ~override~
              ~VVMADMAN.CRE~ ~override~
              ~WPWENCH1.CRE~ ~override~
              ~YARMY01.CRE~  ~override~
              ~YSMAGE02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 2 // female
  END
  BUT_ONLY_IF_IT_CHANGES

// yet more sex fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 3 // neither
  END
  BUT_ONLY_IF_IT_CHANGES

// gender fixes
COPY_EXISTING ~BAZLIZ01.CRE~ ~override~
              ~BAZLIZ02.CRE~ ~override~
              ~BDOCK1.CRE~   ~override~
              ~C6GOFUS.CRE~  ~override~
              ~C6KACH.CRE~   ~override~
              ~COWENF1.CRE~  ~override~
              ~DADROW2.CRE~  ~override~
              ~DADROW8.CRE~  ~override~
              ~DADROW9.CRE~  ~override~
              ~DADROW15.CRE~ ~override~
              ~dagnoll.cre~  ~override~ // Gnoll (ar2200.are)
              ~daumber.cre~  ~override~ // Umber Hulk (ar2200.are)
              ~DERRICK.CRE~  ~override~
              ~dgtrol01.CRE~ ~override~
              ~dgtrol02.CRE~ ~override~
              ~DORKUS.CRE~   ~override~
              ~DPMON01.CRE~  ~override~
              ~DROFOD02.CRE~ ~override~
              ~DROFOD03.CRE~ ~override~
              ~ESCORT3.CRE~  ~override~
              ~GITH05.CRE~   ~override~
              ~GITH06.CRE~   ~override~
              ~GORAPR.CRE~   ~override~
              ~GORGUA04.CRE~ ~override~
              ~GORGUA05.CRE~ ~override~
              ~HLMAGE.CRE~   ~override~
              ~JONDAL.CRE~   ~override~
              ~KAYSMG01.CRE~ ~override~
              ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~KPROEN03.CRE~ ~override~
              ~KPSOLD10.CRE~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~KRUIN.CRE~    ~override~
              ~KUOARC20.CRE~ ~override~
              ~LAVOK02.CRE~  ~override~
              ~OGRE01.CRE~   ~override~
              ~OGRHAL01.CRE~ ~override~
              ~OGRILL01.CRE~ ~override~
              ~PALERN.CRE~   ~override~
              ~PALKNI02.CRE~ ~override~
              ~PALKNI03.CRE~ ~override~
              ~PALKNI04.CRE~ ~override~
              ~PALKNI05.CRE~ ~override~
              ~PCAPT02.CRE~  ~override~
              ~PETTIN.CRE~   ~override~
              ~PLYOGRE.CRE~  ~override~
              ~PLYSALA.CRE~  ~override~
              ~RETHUG02.CRE~ ~override~
              ~RIFTG03.CRE~  ~override~
              ~SAHBEH03.CRE~ ~override~
              ~SAHOTY01.CRE~ ~override~
              ~SARBHA01.CRE~ ~override~
              ~SEWERM.CRE~   ~override~
              ~SHTH03.CRE~   ~override~
              ~SLVIC02.CRE~  ~override~
              ~TOBBAN01.CRE~ ~override~
              ~TOBPAR04.CRE~ ~override~
              ~TOLGER.CRE~   ~override~
              ~TOLGER2.CRE~  ~override~
              ~TOWNC01.CRE~  ~override~
              ~TRCUT06.CRE~  ~override~
              ~TRFUED02.CRE~ ~override~
              ~TRFUED05.CRE~ ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
              ~WINNKEEP.CRE~ ~override~
              ~YARMY03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 1 // male
  END
  BUT_ONLY_IF_IT_CHANGES

// gender fixes
COPY_EXISTING ~AMMONK08.CRE~ ~override~
              ~AR18ARCH.CRE~ ~override~
              ~C6CATTI.CRE~  ~override~
              ~C6CATTI2.CRE~ ~override~
              ~C6CLER3.CRE~  ~override~
              ~C6DEL.CRE~    ~override~
              ~C6GUEN2.CRE~  ~override~
              ~CEFALD02.CRE~ ~override~
              ~CHICKDEF.CRE~ ~override~
              ~CHICKE.CRE~   ~override~
              ~CHICKER.CRE~  ~override~
              ~COPLION.CRE~  ~override~
              ~COW.CRE~      ~override~
              ~CSHECK1.CRE~  ~override~
              ~CSHECK3.CRE~  ~override~
              ~CSSUPP2.CRE~  ~override~
              ~DADROW10.CRE~ ~override~
              ~DADROW23.CRE~ ~override~
              ~DAGHAUN1.CRE~ ~override~
              ~DAGHAUN2.CRE~ ~override~
              ~DEADCOW1.CRE~ ~override~
              ~DEADCOW2.CRE~ ~override~
              ~DEER01.CRE~   ~override~
//              ~DEVAGOOD.CRE~ ~override~
//              ~DEVAEVIL.CRE~ ~override~
              ~DEVAST01.CRE~ ~override~
              ~DEVMON01.CRE~ ~override~
              ~DPFEMALE.CRE~ ~override~
              ~DPSTAT05.CRE~ ~override~
              ~DROFOD04.CRE~ ~override~
              ~DROW04.CRE~   ~override~
              ~DSBODY01.CRE~ ~override~
              ~FANGEL01.CRE~ ~override~
              ~FINSOL01.CRE~ ~override~
              ~GEMCH01.CRE~  ~override~
              ~GEMCH02.CRE~  ~override~
              ~GORSTA05.CRE~ ~override~
              ~HLSHYR.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~JAMERONI.CRE~ ~override~
              ~MGKHOL01.CRE~ ~override~
              ~NCHICK.CRE~   ~override~
              ~NCOW.CRE~     ~override~
              ~PIRFSH02.CRE~ ~override~
              ~PIRSAL02.CRE~ ~override~
              ~PLANET01.CRE~ ~override~
//              ~PLANGOOD.CRE~ ~override~
//              ~PLANEVIL.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
              ~PPBODHI3.CRE~ ~override~
              ~PPMAG01.CRE~  ~override~
              ~PPVALEN.CRE~  ~override~
              ~REMAGE01.CRE~ ~override~
              ~SENDAI7.CRE~  ~override~
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~SUENDEL2.CRE~ ~override~
              ~SUENDEL4.CRE~ ~override~
              ~SUENDEL6.CRE~ ~override~
              ~SUENDEL8.CRE~ ~override~
              ~TOBPAR02.CRE~ ~override~
              ~TRFTOW04.CRE~ ~override~
              ~TRSKIN01.CRE~ ~override~
              ~UDDOOR06.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~VAMANC01.CRE~ ~override~
              ~VAMEMI01.CRE~ ~override~
              ~VAMMAT01.CRE~ ~override~
              ~VAMPAT01.CRE~ ~override~
              ~VAMVER01.CRE~ ~override~
              ~VAMPAER.CRE~  ~override~
              ~VAMPJAH.CRE~  ~override~
              ~VAMPVIC.CRE~  ~override~
              ~VVBODHI.CRE~  ~override~
              ~VVDEL.CRE~    ~override~
              ~VVPARIS.CRE~  ~override~
              ~VVSALIA.CRE~  ~override~
              ~VVTANOV.CRE~  ~override~
              ~WPWENCH1.CRE~ ~override~
              ~YARMY01.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 2 // female
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~ABISRED1.CRE~ ~override~
              ~ABYDEM01.CRE~ ~override~
              ~AR18SKEL.CRE~ ~override~
              ~BEHHIV01.CRE~ ~override~
              ~BHGHOUL2.CRE~ ~override~
              ~BHGHOUL4.CRE~ ~override~
              ~DACEMIST.CRE~ ~override~
              ~DEADDEM1.CRE~ ~override~
              ~DEATHKNI.CRE~ ~override~
              ~DECK615.CRE~  ~override~
              ~DELMIST.CRE~  ~override~
              ~DEMABI01.CRE~ ~override~
              ~DEMCOR01.CRE~ ~override~
              ~DEMGLA01.CRE~ ~override~
              ~DEMPIT01.CRE~ ~override~
              ~DEMILICH.CRE~ ~override~
              ~demnab02.cre~ ~override~ // Nabassu (ar2800.are)
              ~DEMOSUM1.CRE~ ~override~
              ~DEMOSUM2.CRE~ ~override~
              ~DEMOSUM3.CRE~ ~override~
              ~DGLAB01.CRE~  ~override~
              ~DPDEM01.CRE~  ~override~
              ~DPMON02.CRE~  ~override~
              ~ELEARB01.CRE~ ~override~
              ~ELEARB02.CRE~ ~override~
              ~ELEARB03.CRE~ ~override~
              ~ELEARB04.CRE~ ~override~
              ~ELEARB05.CRE~ ~override~
              ~ELEARB06.CRE~ ~override~
              ~ELEARB07.CRE~ ~override~
              ~ELEARB08.CRE~ ~override~
              ~ELEARB09.CRE~ ~override~
              ~ELEARB10.CRE~ ~override~
              ~ELEARB11.CRE~ ~override~
              ~ELEPUZ01.CRE~ ~override~
              ~ELEPUZ02.CRE~ ~override~
              ~ELEPUZ03.CRE~ ~override~
              ~ELEPUZ04.CRE~ ~override~
              ~FIRLCH01.CRE~ ~override~
              ~FIRWRA01.CRE~ ~override~
              ~FSSKEL.CRE~   ~override~
              ~GHOGR01.CRE~  ~override~
              ~GLBEAR.CRE~   ~override~
              ~GORBAT1.CRE~  ~override~
              ~GORBAT3.CRE~  ~override~
              ~GORCAMB.CRE~  ~override~
              ~GORCHR.CRE~   ~override~
              ~gormistp.cre~ ~override~ // Poison Mist (ar3016.bcs)
              ~GORTAN1.CRE~  ~override~
              ~GORTAN4.CRE~  ~override~
              ~GORWOM05.CRE~ ~override~
              ~GRSKEL1.CRE~  ~override~
              ~GRSKEL2.CRE~  ~override~
              ~HELLFEAR.CRE~ ~override~
              ~HELLGREE.CRE~ ~override~
              ~HELLPRID.CRE~ ~override~
              ~HELLSELF.CRE~ ~override~
              ~HGMIS02.CRE~  ~override~
              ~HGSKL01.CRE~  ~override~
              ~HGSKL02.CRE~  ~override~
              ~HGSKL03.CRE~  ~override~
              ~HGWRA01.CRE~  ~override~
              ~HLDEMI.CRE~   ~override~
              ~HLSKULL.CRE~  ~override~
              ~ICFUNG02.CRE~ ~override~
              ~ICMYC01.CRE~  ~override~
              ~ICMYC02.CRE~  ~override~
              ~IGOLFLE3.CRE~ ~override~
              ~IGOLFLE4.CRE~ ~override~
              ~KELZOMB.CRE~  ~override~
              ~KSHADOW.CRE~  ~override~
              ~LESTER.CRE~   ~override~
              ~MISTHO01.CRE~ ~override~
              ~MISTWA01.CRE~ ~override~
              ~NEVM2.CRE~    ~override~
              ~OBSDEM01.CRE~ ~override~
              ~PMASTER.CRE~  ~override~
              ~PPDEMON.CRE~  ~override~
              ~PWARDEN.CRE~  ~override~
              ~PPNAB01.CRE~  ~override~
              ~PPNAB02.CRE~  ~override~
              ~PPNAB03.CRE~  ~override~
              ~RNGSHA.CRE~   ~override~
              ~RNGSHA01.CRE~ ~override~
              ~RNGSHA02.CRE~ ~override~
              ~RNGSHA03.CRE~ ~override~
              ~RNGSHA04.CRE~ ~override~
              ~RNGSHA2D.CRE~ ~override~
              ~RSKEL01.CRE~  ~override~
              ~RSKEL03.CRE~  ~override~
              ~RUMAR02.CRE~  ~override~
              ~SDSHADFI.CRE~ ~override~
              ~SDSHADOW.CRE~ ~override~
              ~SENDARK.CRE~  ~override~
              ~SEWSHA01.CRE~ ~override~
              ~SEWSHA02.CRE~ ~override~
              ~SEWSHA03.CRE~ ~override~
              ~SHADEL.CRE~   ~override~
              ~SHADELD.CRE~  ~override~
              ~SHADFI01.CRE~ ~override~
              ~SHADFI02.CRE~ ~override~
              ~SHADOW01.CRE~ ~override~
              ~SHAPE.CRE~    ~override~
              ~SHAWOL01.CRE~ ~override~
              ~SHAWOL02.CRE~ ~override~
              ~SKELAR01.CRE~ ~override~
              ~SKELAR02.CRE~ ~override~
              ~SKELE2.CRE~   ~override~
              ~SKELET01.CRE~ ~override~
              ~SKELHP1.CRE~  ~override~
              ~SLIFIS01.CRE~ ~override~
              ~SLIFIS02.CRE~ ~override~
              ~SWORD03.CRE~  ~override~
              ~TANARI01.CRE~ ~override~
              ~TANOMIST.CRE~ ~override~
              ~TELBAL1.CRE~  ~override~
              ~telcam1.cre~  ~override~ // Cambion (ar3007.are)
              ~TELCOR1.CRE~  ~override~
              ~TELPIT1.CRE~  ~override~
              ~TELPIT2.CRE~  ~override~
              ~TELSLAV.CRE~  ~override~
              ~TELTAN1.CRE~  ~override~
              ~TELTAN2.CRE~  ~override~
              ~TELWRAI.CRE~  ~override~
              ~UDDEATH.CRE~  ~override~
              ~UDDEATH2.CRE~ ~override~
              ~uddoor07.cre~ ~override~ // Skeleton (ar2402.are)
              ~UDNABA.CRE~   ~override~
              ~UHCREAT.CRE~  ~override~
              ~VALEMIST.CRE~ ~override~
              ~wish02.cre~   ~override~
              ~WOLFZO01.CRE~ ~override~
              ~WRAITH01.CRE~ ~override~
              ~WRASHI01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 4 // neither
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes summoned creature gender
COPY_EXISTING ~bearblsu.cre~ ~override~
              ~beargrsu.cre~ ~override~
              ~ettercsu.cre~ ~override~
              ~sumdjinn.cre~ ~override~
              ~sword02.cre~  ~override~
              ~worgsu.cre~   ~override~
              ~xvartsu.cre~  ~override~
  WRITE_BYTE 0x275 6 // summoned
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// creatures with invalid item fixes                \\\\\
/////                                                  \\\\\

// creatures needing items

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB stuff
  // bow but no arrows
  COPY_EXISTING ~amarch01.cre~ ~override~
    ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER1 QUIVER2 QUIVER3~

  // monk has no fist
  COPY_EXISTING ~ammonk03.cre~ ~override~
    ADD_CRE_ITEM ~mfist8~ #0 #0 #0 ~UNSTEALABLE&UNDROPPABLE~ ~WEAPON1 WEAPON2 WEAPON3 WEAPON4~ EQUIP
END

// add golem immunity items
COPY_EXISTING ~arngol01.cre~ ~override~
              ~csgolem.cre~  ~override~
              ~golem01.cre~  ~override~
              ~icbone01.cre~ ~override~
              ~igolem01.cre~ ~override~
              ~igolem02.cre~ ~override~
  ADD_CRE_ITEM ~golcla~ #0 #0 #0 ~NONE~ ~RRING~
  BUT_ONLY_IF_IT_CHANGES

// sling but no bullets
COPY_EXISTING ~edwin12.cre~ ~override~
              ~edwin13.cre~ ~override~
  ADD_CRE_ITEM ~bull01~ #20 #0 #0 ~NONE~ ~QUIVER1 QUIVER2 QUIVER3~

// arrows but no bow
COPY_EXISTING ~prisonk1.cre~ ~override~
  ADD_CRE_ITEM ~bow01~ #0 #0 #0 ~NONE~ ~WEAPON3 WEAPON4~ // already has weapon equipped

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB stuff

  // add golem immunity items
  COPY_EXISTING ~golice01.cre~   ~override~
    ADD_CRE_ITEM ~golstone~ #0 #0 #0 ~NONE~ ~AMULET~
    BUT_ONLY_IF_IT_CHANGES

END

// arrows but no bow
COPY_EXISTING ~refigh01.cre~ ~override~
  ADD_CRE_ITEM ~bow01~ #0 #0 #0 ~NONE~ ~WEAPON2 WEAPON3 WEAPON4~ // already has weapon equipped

// juggernaut golem missing weapon and has wrong immunity
COPY_EXISTING ~tomegol4.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
      READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "immune1" = 0) BEGIN // find invalid resref
        WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "immune2" #8 // corrected resref
        SET "index" = "%itm_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add golem immunity items
COPY_EXISTING ~xgolem.cre~   ~override~
  ADD_CRE_ITEM ~golfle~ #0 #0 #0 ~NONE~ ~RRING~
  BUT_ONLY_IF_IT_CHANGES

// bow but no arrows
COPY_EXISTING ~yoshi11.cre~ ~override~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER1~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER2~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER3~

// incorrct item entries, either due to typos or other errors

// resref typo
COPY_EXISTING ~genie01.cre~  ~override~
              ~genie02.cre~  ~override~
              ~genie03.cre~  ~override~
              ~genie04.cre~  ~override~
              ~ppdjinn.cre~  ~override~
              ~trgeni02.cre~ ~override~
              ~trgeni03.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "b3-18" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "b3-18m3" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~cor.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "2hsw02" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw2h02" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~pirexe01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "blunt06" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "blun06" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~senani03.cre~ ~override~
              ~sendro03.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bwbolt01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "dwbolt01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~gorje.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "cham01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "chan01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~cuphaer.cre~  ~override~
              ~drow05.cre~   ~override~
              ~udchal.cre~   ~override~
              ~udphae02.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "dwcha01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "dwchan01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~sahspc01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ghost01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ghost" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~pirsea01.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leath01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "leat01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~cultist1.cre~ ~override~
              ~excult1.cre~  ~override~
              ~excult2.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leath04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "leat04" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~gorwom01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rdntre03" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "rndtre03" #8 // corrected resref
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rdntre04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "rndtre04" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~demosum4.cre~ ~override~
              ~gorcamb.cre~  ~override~
              ~gorcamb6.cre~ ~override~
              ~gorcamb7.cre~ ~override~
              ~hgfel01.cre~  ~override~
              ~telimp1.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rngdemn" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ringdemn" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~arntra01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sh1h04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw1h04" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~tirthold.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staff01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "staf01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~gorsta10.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "umber1" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "umber01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~laune.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "vamp01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "vamp1" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ringloup makes creatures well-nigh invincible as using old BG immunity (unused in BG2)
COPY_EXISTING ~firwlf01.cre~ ~override~
              ~firwlf02.cre~ ~override~
              ~rngwlf01.cre~ ~override~
              ~rngwlf02.cre~ ~override~
              ~rngwlf03.cre~ ~override~
              ~rngwlf04.cre~ ~override~
              ~rngwlf05.cre~ ~override~
              ~weregr01.cre~ ~override~
              ~weregrdr.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ringloup" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ringwolf" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Varscona is unique; repacing all references except Ribald's with generic +2 sword
COPY_EXISTING ~C6BRAN.cre~   ~override~ // Branet Al-Thon
              ~c6catti.cre~  ~override~ // catti-brie
              ~c6catti2.cre~ ~override~ // catti-brie
              ~C6ELF1.cre~   ~override~ // Elven Warrior
              ~C6FAKE.cre~   ~override~ // Elhan
              ~C6GENER.cre~  ~override~ // General Sovalidaas
              ~C6GOD.cre~    ~override~ // Elven God
              ~C6KACH2.cre~  ~override~ // Kachiko
              ~C6KALDEN.cre~ ~override~ // Kalden
              ~C6LEVIN.cre~  ~override~ // Levin Rayn
              ~C6NERIT.cre~  ~override~ // Nerit
              ~C6WILL.cre~   ~override~ // William Reirrac
              ~CUPRIS1.cre~  ~override~ // Elven Warrior
              ~CUPRIS2.cre~  ~override~ // Elven Warrior
              ~E34.cre~      ~override~ // Coran
//              ~RIBALD.cre~   ~override~ // Ribald
              ~SUELF12.cre~  ~override~ // Captain Aduo'on
              ~SUELF13.cre~  ~override~ // Elven Warrior
              ~SUELLEG1.cre~ ~override~ // Elven Warrior
              ~SUENDEL1.cre~ ~override~ // Elven Warrior
              ~SUENDEL2.cre~ ~override~ // Elven Warrior
              ~SUENDEL3.cre~ ~override~ // Elf Male
              ~SUENDEL4.cre~ ~override~ // Elf Female
              ~SUENDEL5.cre~ ~override~ // Elf
              ~SUENDEL6.cre~ ~override~ // Elf
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h06" = 0) BEGIN // find Varscona
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw1h41" #8 // replace with Long Sword +2
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// creatures with items not assigned

// items to be deleted
COPY_EXISTING ~amwyvern.cre~ ~override~
              ~bazdra03.cre~ ~override~
              ~bearbr01.cre~ ~override~
              ~bearca01.cre~ ~override~
              ~bearpo01.cre~ ~override~
              ~bhelm.cre~    ~override~
              ~bodhi.cre~    ~override~
              ~bodhi2.cre~   ~override~
              ~bodhiamb.cre~ ~override~
              ~braiwa2.cre~  ~override~
              ~c6bodhi.cre~  ~override~
              ~c6drizz.cre~  ~override~
              ~c6drizz2.cre~ ~override~
              ~c6drizz3.cre~ ~override~
              ~c6guen.cre~   ~override~
              ~c6guen2.cre~  ~override~
              ~catjag01.cre~ ~override~
              ~catjagsu.cre~ ~override~
              ~catjagwp.cre~ ~override~
              ~catlio01.cre~ ~override~
              ~catliosu.cre~ ~override~
              ~catliowp.cre~ ~override~
              ~catlis01.cre~ ~override~
              ~catpan01.cre~ ~override~
              ~cefald02.cre~ ~override~
              ~chevil02.cre~ ~override~
              ~cubodhi.cre~  ~override~
              ~deck622.cre~  ~override~
              ~dopgre01.cre~ ~override~
              ~dopple01.cre~ ~override~
              ~dragyell.cre~ ~override~
              ~drizzt.cre~   ~override~
              ~e32.cre~      ~override~
              ~famcat.cre~   ~override~
              ~famcat25.cre~ ~override~
              ~famimp.cre~   ~override~
              ~famqua25.cre~ ~override~
              ~famquas.cre~  ~override~
              ~famrab.cre~   ~override~
              ~firkra02.cre~ ~override~
              ~fsridd.cre~   ~override~
              ~genie1.cre~   ~override~
              ~golsan01.cre~ ~override~
              ~hellho01.cre~ ~override~
              ~hellil01.cre~ ~override~
              ~idjinni.cre~  ~override~
              ~kgenie1.cre~  ~override~
              ~kgenie2.cre~  ~override~
              ~korgan8.cre~  ~override~
              ~korgan9.cre~  ~override~
              ~korgan11.cre~ ~override~
              ~korgan12.cre~ ~override~
              ~lacedo01.cre~ ~override~
              ~lacedo02.cre~ ~override~
              ~mumgre01.cre~ ~override~
              ~nwyvbab.cre~  ~override~
              ~obsdem04.cre~ ~override~
              ~plywyvrn.cre~ ~override~
              ~ppbhaal.cre~  ~override~
              ~pries12c.cre~ ~override~
              ~resuna.cre~   ~override~
              ~riftcr03.cre~ ~override~
              ~rngsta01.cre~ ~override~
              ~rskel01.cre~  ~override~
              ~sahlace.cre~  ~override~
              ~sendai2.cre~  ~override~
              ~sahoty01.cre~ ~override~
              ~shape.cre~    ~override~
              ~skele2.cre~   ~override~
              ~skelet01.cre~ ~override~
              ~skelhp1.cre~  ~override~
              ~tranim03.cre~ ~override~
              ~trevil05.cre~ ~override~
              ~trgeni01.cre~ ~override~
              ~uddeath2.cre~ ~override~
              ~udlesa.cre~   ~override~
              ~vbearca.cre~  ~override~
              ~vvamn1.cre~   ~override~
              ~weregrdr.cre~ ~override~
              ~wolfdi01.cre~ ~override~
              ~wraithsu.cre~ ~override~
              ~wyvbab01.cre~ ~override~
              ~ysfire02.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  READ_LONG  0x2c4 "fx_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "ax1h02" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan8" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan9" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan11" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan12" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-8" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bearbr01" = 0)
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-10" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bearca01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vbearca" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-12" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bearpo01" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "b2-8" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahoty01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b3-18" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "genie1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "idjinni" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kgenie1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kgenie2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "trgeni01" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "blun21" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sendai2" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "boot01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz3" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "drizzt" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "chan01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "vvamn1" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "dragyell" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bazdra03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dragyell" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "dwsw1h02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "udlesa" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "ghast1" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "lacedo02" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "ghoul1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "lacedo01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahlace" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "giafir2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "ysfire02" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "hastring" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famcat" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famcat25" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "immune1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famimp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famqua25" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famquas" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "fsridd" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "golsan01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "mumgre01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "riftcr03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "shape" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "e32" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "misc50" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "rskel01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skele2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skelet01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skelhp1" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "misc52" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "amwyvern" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "firkra02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "nwyvbab" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "plywyvrn" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "wyvbab01" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "p1-8" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6guen" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6guen2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjag01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjagsu" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjagwp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catpan01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "cefald02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tranim03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "trevil05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "wolfdi01" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "p1-10" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catlio01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catliosu" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catliowp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "hellho01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "hellil01" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "p1-12" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "catlis01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "braiwa2" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "pries12c" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rabring" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "famrab" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rods05" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "obsdem04" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s1-8" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "wraithsu" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "s1-12" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz3" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "chevil02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dopgre01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dopple01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "drizzt" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s1-12m2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "weregrdr" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "s2-16" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhi" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhi2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhiamb" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6bodhi" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "cubodhi" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s3-8m3" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "deck622" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "scrl25" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bhelm" = 0)
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ppbhaal" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "resuna" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw2h01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "uddeath2" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "vampreg2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhiamb" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "rngsta01" = 0)
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots to alter references
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = "%index%") BEGIN // if deleted item
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 0xffff // removes reference
        END ELSE
        PATCH_IF (("%ref%" > "%index%") AND ("%ref%" != 0xffff)) BEGIN // if higher index than delted
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) ("%ref%" - 1) // decrements by one
        END
      END
      DELETE_BYTES ("%itm_off%" + (0x14 * "%index%")) 0x14 // deletes item
      SET "itm_num" = ("%itm_num%" - 1)
      WRITE_LONG  0x2c0 "%itm_num%"
      SET "index" = ("%index%" - 1)
      PATCH_IF ("%fx_off%" > "%itm_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x14)
        WRITE_LONG  0x2c4 "%fx_off%"
      END
      PATCH_IF ("%slot_off%" > "%itm_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x14)
        WRITE_LONG  0x2b8 "%slot_off%"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// helms
COPY_EXISTING ~garock.cre~ ~override~
              ~rock.cre~   ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "helm01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "garock" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "rock" = 0)
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in helm
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 0) BEGIN // if end of helm slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// armor: mel01, meliss01, and cutmelis not modified--appearance changed too dramatically
COPY_EXISTING ~aerie9.cre~   ~override~
              ~c6god.cre~    ~override~
              ~hobcap01.cre~ ~override~
              ~jondal.cre~   ~override~
              ~plfarm06.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
              ~udduer01.cre~ ~override~
              ~uhogre03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "chan02" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "chan04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hobcap01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "uhogre03" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "udduer01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "aerie9" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "jondal" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plfarm06" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat14" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "c6god" = 0)
             ) BEGIN
      FOR (index2 = 1 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in armor
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 1) BEGIN // if end of armor slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shields
COPY_EXISTING ~plfarm03.cre~ ~override~
              ~plmetr01.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "shld03" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plfarm03" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plmetr01" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "shld04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
               )
             ) BEGIN
      FOR (index2 = 2 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in shield
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 2) BEGIN // if end of shield slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rings/amulets
COPY_EXISTING ~c6elven2.cre~ ~override~
              ~c6elvenw.cre~ ~override~
//              ~centeo01.cre~ ~override~
              ~d1ghost.cre~  ~override~
              ~dacemist.cre~ ~override~
              ~delmist.cre~  ~override~
              ~ghogr01.cre~  ~override~
              ~imp01.cre~    ~override~
              ~impqua01.cre~ ~override~
              ~lester.cre~   ~override~
              ~riftcr01.cre~ ~override~
              ~rumar03.cre~  ~override~
              ~sahimp01.cre~ ~override~
              ~sahimp02.cre~ ~override~
              ~sahimp03.cre~ ~override~
              ~sahimp04.cre~ ~override~
              ~sahimp05.cre~ ~override~
              ~sahimp06.cre~ ~override~
              ~sahimp07.cre~ ~override~
              ~suziyaad.cre~ ~override~
              ~udimp.cre~    ~override~
              ~tanomist.cre~ ~override~
              ~valemist.cre~ ~override~
              ~warsage.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "ghost3" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "d1ghost" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "immune1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ghogr01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "imp01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "impqua01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "riftcr01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "rumar03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp04" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp06" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp07" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "udimp" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "immune2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "suziyaad" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "mage06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "lester" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "minhp1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6elven2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6elvenw" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dacemist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "delmist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tanomist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "valemist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "warsage" = 0)
                 )
               )
             ) OR (
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0) AND (
                   ("%item%" STRING_COMPARE_CASE "ring18" = 0) OR
                   ("%item%" STRING_COMPARE_CASE "ring23" = 0)
                 )
               )
             ) BEGIN
      FOR (index2 = 4 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in rings, amulets
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 6) BEGIN // if end of jewelry slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// weapons
COPY_EXISTING ~c6coran.cre~  ~override~
//              ~centeo01.cre~ ~override~
              ~cowled.cre~   ~override~
              ~duearc01.cre~ ~override~
              ~e32.cre~      ~override~
              ~firmon02.cre~ ~override~
              ~gith04.cre~   ~override~
              ~gorgith2.cre~ ~override~
              ~gorkuo05.cre~ ~override~
              ~jaerto1.cre~  ~override~
              ~jaerto2.cre~  ~override~
              ~kchild1.cre~  ~override~
              ~kuowhi01.cre~ ~override~
              ~pirmur02.cre~ ~override~
              ~pries18c.cre~ ~override~
              ~rumar01.cre~  ~override~
              ~sahextra.cre~ ~override~
              ~sarjai01.cre~ ~override~
              ~swshaman.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
              ~tomegol4.cre~ ~override~
              ~vvshad1.cre~  ~override~
              ~vvshad4.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "ax1h01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "duearc01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "b1-2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "kchild1" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "blun04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "pries18c" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "blun05" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bow01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "firmon02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bow03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "c6coran" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "dagg01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vvshad1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vvshad4" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "dart01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "goltome4" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "tomegol4" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "staf02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "rumar01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jaerto1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jaerto2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ppbhaal" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "resuna" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h05" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sarjai01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h07" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "pirmur02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h08" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "swshaman" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw2h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "e32" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gith04" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gorgith2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "uddeath2" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw2h06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "xbow01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahextra" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gorkuo05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kuowhi01" = 0)
                 )
               )
             ) BEGIN
      FOR (index2 = 9 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in weapons
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 12) BEGIN // if end of weapon slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// items for quiver
COPY_EXISTING ~bhaal01.cre~  ~override~
              ~dragblac.cre~ ~override~
              ~elekob01.cre~ ~override~
              ~kobcom01.cre~ ~override~
              ~kobsla01.cre~ ~override~
              ~plmetg02.cre~ ~override~
              ~sahcpt02.cre~ ~override~
              ~sahpri02.cre~ ~override~
              ~sahramb1.cre~ ~override~
              ~sahrnt01.cre~ ~override~
              ~sarevok.cre~  ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll6.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "arow01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "elekob01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kobcom01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kobsla01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "swsfoll1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "swsfoll6" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "arow07" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plmetg02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "arow11" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahpri02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahrnt01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt06" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bhaal01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sarevok" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bull03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sahbolt" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahrnt01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahcpt02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahramb1" = 0)
               )
             ) BEGIN
      FOR (index2 = 13 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in quivers
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 16) BEGIN // if end of quiver slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// quickslot items
COPY_EXISTING //~centeo01.cre~ ~override~
              ~chgood09.cre~ ~override~
              ~cowled.cre~   ~override~
//              ~davaeo.cre~   ~override~
//              ~gorion.cre~   ~override~
              ~hamasu.cre~   ~override~
              ~imoen.cre~    ~override~
              ~sahbeh04.cre~ ~override~
              ~teltief3.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "potn02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn08" = 0) AND
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
               )
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn09" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn20" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn32" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahbeh04" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn55" = 0) AND
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "chgood09" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "teltief3" = 0)
               )
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl1g" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl1q" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl77" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl84" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) BEGIN
      FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quick slots/inventory and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// generic inventory/quickslot
COPY_EXISTING ~aegnoll.cre~  ~override~
              ~ammerc07.cre~ ~override~
              ~c6lanf.cre~   ~override~
//              ~centeo01.cre~ ~override~
              ~chgood09.cre~ ~override~
              ~cowled.cre~   ~override~
              ~dagnoll.cre~  ~override~
//              ~davaeo.cre~   ~override~
              ~dragblac.cre~ ~override~
              ~garkid02.cre~ ~override~
              ~gibbersu.cre~ ~override~
              ~gibmut01.cre~ ~override~
              ~gnleli01.cre~ ~override~
              ~gnlwar01.cre~ ~override~
              ~gnoll01.cre~  ~override~
              ~gnollhp1.cre~ ~override~
//              ~gorion.cre~   ~override~
              ~hamasu.cre~   ~override~
              ~hobcap01.cre~ ~override~
              ~icliz01.cre~  ~override~
              ~icliz02.cre~  ~override~
              ~imoen.cre~    ~override~
              ~sahbeh04.cre~ ~override~
              ~tasloisu.cre~ ~override~
              ~teltief3.cre~ ~override~
              ~xvartsu.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "dart04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "misc90" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn08" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn09" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn20" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn32" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahbeh04" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn55" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "chgood09" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "teltief3" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre02" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "ammerc07" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "c6lanf" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "garkid02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gibbersu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gibmut01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tasloisu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "xvartsu" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hobcap01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "aegnoll" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dagnoll" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnleli01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnlwar01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnoll01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnollhp1" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "icliz01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "icliz02" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl1g" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl1q" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl77" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl84" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "wand06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) BEGIN
      FOR (index2 = 21 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through inventory and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// item in wrong slots, dupe entries, etc.

// icgob02 has overlapping refs
COPY_EXISTING ~icgob02.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  SET "dupe" = 0
  FOR (index2 = 13 ; index2 < 17 ; index2 = index2 + 1) BEGIN // search through quiver slots
    READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
    PATCH_IF ("%ref%" = 3) BEGIN // dupe reference in quivers
      PATCH_IF ("%dupe%" = 0) BEGIN
        SET "dupe" = 1
      END ELSE BEGIN
        WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 1 // removes dupe reference
        SET "index2" = 17 // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// both have dupe ring ref in weapon slot instead of weapon
COPY_EXISTING ~impqua01.cre~ ~override~
              ~kuocle20.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ((("%item%" STRING_COMPARE_CASE "impqua" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "impqua01" = 0)) OR
              (("%item%" STRING_COMPARE_CASE "blun33" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "kuocle20" = 0))) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x12) "%index%" // puts in primary weapon slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

  // has ring in weapon slots
COPY_EXISTING ~amlich01.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 9 ; index < 13 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "ring46" = 0) BEGIN
        READ_SHORT ("%slot_off%" + 0x08) "lring" // read lring slot
        READ_SHORT ("%slot_off%" + 0x0a) "rring" // read rring slot
        PATCH_IF ("%lring%" = 0xffff) BEGIN // if lring slot open
          WRITE_SHORT ("%slot_off%" + 0x08) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END ELSE
        PATCH_IF ("%rring%" = 0xffff) BEGIN // if rring slot open
          WRITE_SHORT ("%slot_off%" + 0x0a) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 13 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has armor in weapon slot, weapon not assigned (fixed later)
COPY_EXISTING ~ppsail03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leat01" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x02) "%index%" // puts in armor slot
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h20" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x18) "%index%" // puts in primary weapon slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rskel03 has dupe entries for throwing axes
COPY_EXISTING ~rskel03.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ax1h04" = 0) BEGIN
      SET "exists" = 0
      SET "insert" = 0
      FOR (index2 = 9 ; index2 < 13 ; index2 = index2 + 1) BEGIN // search through weapon slots
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%index%" = "%ref%") BEGIN
          SET "exists" = 1
          SET "index2" = 17 // kills loop
        END ELSE
        PATCH_IF (("%insert%" = 0) AND ("%ref%" = 0xffff)) BEGIN // if null entry, set insert point
          SET "insert" = "%index2%"
        END
      END
      PATCH_IF ("%exists%" = 0) BEGIN
        PATCH_IF ("%insert%" = 0) BEGIN // no insert point found already
          FOR (index3 = 21 ; index3 < 36 ; index3 = index3 + 1) BEGIN // search through weapon slots
            READ_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "ref"
            PATCH_IF ("%ref%" = 0xffff) BEGIN
              WRITE_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "%index%" // adds reference
            END
          END
        END ELSE BEGIN
          WRITE_SHORT ("%slot_off%" + ("%insert%" * 0x02)) "%index%" // adds reference
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// sewyag03 has dupe quiver reference
COPY_EXISTING ~sewyag03.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    SET "dupe" = 0
    FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots
      READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
      PATCH_IF ("%ref%" = 4) BEGIN // dupe reference in quivers
        PATCH_IF ("%dupe%" = 0) BEGIN
          SET "dupe" = 1
        END ELSE BEGIN
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 3 // removes dupe reference
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// number of creatures with dupe entries for rndtre05
COPY_EXISTING ~drush.cre~    ~override~
              ~ogrema01.cre~ ~override~
              ~ogrmag01.cre~ ~override~
              ~plshom01.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rndtre05" = 0) BEGIN
      SET "exists" = 0
      SET "insert" = 0
      FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quick slots & inventory
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%index%" = "%ref%") BEGIN
          SET "exists" = 1
          SET "index2" = 36 // kills loop
        END ELSE
        PATCH_IF (("%insert%" = 0) AND ("%ref%" = 0xffff)) BEGIN // if null entry, set insert point
          SET "insert" = "%index2%"
        END
      END
      PATCH_IF ("%exists%" = 0) BEGIN
        FOR (index3 = 21 ; index3 < 36 ; index3 = index3 + 1) BEGIN // search through weapon slots
          READ_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "ref"
          PATCH_IF ("%ref%" = 0xffff) BEGIN
            WRITE_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "%index%" // adds reference
            SET "index3" = 36 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has shield in armor slot, armor not assigned
COPY_EXISTING ~kpsold06.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "chan04" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x02) "%index%" // puts in armor slot
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "shld05" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x04) "%index%" // puts in shield slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

  // has helm in quickslot/inventory
COPY_EXISTING ~gorfirg.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    READ_LONG  0x2bc "itm_off" ELSE 0
    FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
      READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
      PATCH_IF ("%ref%" != 0xffff) BEGIN
        READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
        PATCH_IF ("%item%" STRING_COMPARE_CASE "helm31" = 0) BEGIN
          READ_SHORT ("%slot_off%") "helm" // read helm slot
          PATCH_IF ("%helm%" = 0xffff) BEGIN // if helm slot open
            WRITE_SHORT ("%slot_off%") "%ref%" // write reference
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
          END
          SET "index" = 37 //kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has dupe armor entry in weapon slot; properly equipping weapon is handled in mass patch
COPY_EXISTING ~ppsail03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off"  ELSE 0
  FOR (index = 9 ; index < 13 ; index = index + 1) BEGIN // search through weapon slots
    READ_SHORT ("%slot_off%" + ("%index%" * 0x02)) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN // if legit reference
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "leat01" = 0) BEGIN
        WRITE_SHORT ("%slot_off%" + ("%index%" * 0x02)) 0xffff // blanks reference
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has armor in cloak/quickslots/inventory
COPY_EXISTING ~aerie10.cre~  ~override~
              ~elearb01.cre~ ~override~
              ~elearb02.cre~ ~override~
              ~elearb03.cre~ ~override~
              ~elearb04.cre~ ~override~
              ~elearb05.cre~ ~override~
              ~elearb06.cre~ ~override~
              ~elearb07.cre~ ~override~
              ~elearb08.cre~ ~override~
              ~elearb09.cre~ ~override~
              ~elearb10.cre~ ~override~
              ~elearb11.cre~ ~override~
              ~flyfgt04.cre~ ~override~
              ~gmage14.cre~  ~override~
              ~gorsta11.cre~ ~override~
              ~gromg05.cre~  ~override~
              ~gromg08.cre~  ~override~
              ~gromg13.cre~  ~override~
              ~hlsion.cre~   ~override~
              ~jangit02.cre~ ~override~
              ~loveone5.cre~ ~override~
              ~rigen02.cre~  ~override~
              ~rumar01.cre~  ~override~
              ~sarmag01.cre~ ~override~
              ~shugmg01.cre~ ~override~
              ~shupol01.cre~ ~override~
              ~stein.cre~    ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 17 ; index < 37 ; index = index + 1) BEGIN
  READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff // slots starting with cloak
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 ("%item%" STRING_COMPARE_CASE "clck10" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck13" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck14" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck15" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck16" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "leat04" = 0)
               ) BEGIN
        READ_SHORT ("%slot_off%" + 0x02) "armor" // read armor slot
        PATCH_IF ("%armor%" = 0xffff) BEGIN // if armor slot open
          WRITE_SHORT ("%slot_off%" + 0x02) "%ref%" // add as armor
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has shield in quickslot/inventory
COPY_EXISTING ~trfued05.cre~ ~override~
              ~yaga01.cre~   ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 ("%item%" STRING_COMPARE_CASE "shld01" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "shld04" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "shld32" = 0)
               ) BEGIN
        READ_SHORT ("%slot_off%" + 0x04) "shld" // read shld slot
        PATCH_IF ("%shld%" = 0xffff) BEGIN // if shld slot open
          WRITE_SHORT ("%slot_off%" + 0x04) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has bracers in quickslot/inventory
COPY_EXISTING ~gorwom03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "brac21" = 0) BEGIN
        READ_SHORT ("%slot_off%" + 0x06) "brac" // read helm slot
        PATCH_IF ("%brac%" = 0xffff) BEGIN // if helm slot open
          WRITE_SHORT ("%slot_off%" + 0x06) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have ring in quickslot/inventory
COPY_EXISTING ~aran02.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "ring07" = 0) BEGIN // RoP +2
        FOR (index2 = 4 ; index2 < 37 ; index2 = index2 + 1) BEGIN // start at ring slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 21 //kills loop
            SET "index2" = 37 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have weapons in quickslot/inventory
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~bshop01.cre~  ~override~
              ~corneil.cre~  ~override~
              ~dario.cre~    ~override~
              ~DSHOP01.cre~  ~override~
              ~edwin12.cre~  ~override~
              ~edwin13.cre~  ~override~
              ~elders.cre~   ~override~
              ~ffactor2.cre~ ~override~
              ~garrick.cre~  ~override~
              ~gerhardt.cre~ ~override~
              ~jaga4.cre~    ~override~
              ~jamage1.cre~  ~override~
              ~jamage2.cre~  ~override~
              ~jameroni.cre~ ~override~
              ~jan15.cre~    ~override~
              ~nalia8.cre~   ~override~
              ~nalia10.cre~  ~override~
              ~nalia11.cre~  ~override~
              ~nalia13.cre~  ~override~
              ~nalia15.cre~  ~override~
              ~pwarden.cre~  ~override~
              ~scyarryl.cre~ ~override~
              ~surly.cre~    ~override~
              ~temsup.cre~   ~override~
              ~thief5.cre~   ~override~
              ~valyg9.cre~   ~override~
              ~valyg11.cre~  ~override~
              ~valyg12.cre~  ~override~
              ~vara.cre~     ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 (
                   ("%item%" STRING_COMPARE_CASE "blun02" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gerhardt" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "blun03" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "temsup" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "blun20" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "scyarryl" = 0)
                 ) OR (
                   (
                     ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR
                     ("%item%" STRING_COMPARE_CASE "sper01" = 0)
                   ) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg9" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg11" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg12" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "bow05" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia8" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia10" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia11" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia13" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia15" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "dagg01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "bshop01" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "ffactor2" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "thief5" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "hamm01" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "surly" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "slng01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen6" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen7" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen8" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen9" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen10" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "edwin12" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "edwin13" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "staf01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "corneil" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "dario" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "elders" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jamage1" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jamage2" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "vara" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "sw1h07" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "DSHOP01" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "sw1h35" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "pwarden" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "xbow04" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "garrick" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jaga4" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jameroni" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "xbow12" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jan15" = 0)
                 )
               ) BEGIN
        FOR (index2 = 9 ; index2 < 37 ; index2 = index2 + 1) BEGIN // start at weapon slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 21 //kills loop
            READ_SHORT ("%slot_off%" + 0x4c) "equipped"
            PATCH_IF (("%index2%" < 13) AND ("%equipped%" = 0xffff)) BEGIN
              WRITE_SHORT ("%slot_off%" + 0x4c) ("%index2%" - 9) // equipped weapon
            END
            SET "index2" = 37 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have ammo in quickslot/inventory
COPY_EXISTING ~elekob01.cre~ ~override~
              ~kobcom01.cre~ ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll6.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "arow08" = 0) BEGIN
        FOR (index2 = 13 ; index2 < 17 ; index2 = index2 + 1) BEGIN //quiver slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 37 //kills loop
            SET "index2" = 17 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amnish guards shouldn't be using bows and arrows, especially w/o animation
COPY_EXISTING ~bamng01.cre~ ~override~
              ~bamng02.cre~ ~override~
              ~circg1.cre~  ~override~
  READ_LONG  0x2b8 "slot_off"
  READ_LONG  0x2bc "itm_off"
  FOR (index = 0; index < 4; index = index + 1) BEGIN // cycles through weapon slots
    READ_SHORT ("%slot_off%" + 0x12 + ("%index%" * 0x02)) "slot_num"
    PATCH_IF ("%slot_num%" < 37) BEGIN
      READ_ASCII ("%itm_off%" + ("%slot_num%" * 0x14)) "weapon"
      PATCH_IF ("sw1h04" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT ("%slot_off%" + 0x4c) "%index%" // sets weapon slot to selected weapon
        SET "index" = 4
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// zombies shouldn't be using bows and arrows, especially w/o animation
COPY_EXISTING ~bhghoul5.cre~ ~override~
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "arrw01" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x14 * "%itm_num%")) ~arow01~ #8
      READ_BYTE   ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) "flags"
      WRITE_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) ("%flags%" BOR   0b00001010) // adds unstealable, undroppable flags
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bow03" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x14 * "%itm_num%")) ~b3-12~ #8 // replace bow with zombie attack item
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have incorrect equipped weapon reference
COPY_EXISTING ~aemess.cre~   ~override~
              ~alex.cre~     ~override~
              ~AMMAJIRA.CRE~ ~OVERRIDE~
              ~AMTCLE01.CRE~ ~override~
              ~AMTCLER0.CRE~ ~override~
              ~ANTENOS.CRE~  ~override~
              ~ARLED.cre~    ~override~
              ~BAZEYE01.CRE~ ~override~
              ~BGUARD1.cre~  ~override~
              ~boo.CRE~      ~override~
              ~BOUNHA02.cre~ ~override~
              ~BOUNHA03.cre~ ~override~
              ~C6KACH2.cre~  ~override~
              ~ch3mag01.CRE~ ~override~
              ~CHGOOD09.CRE~ ~override~
              ~CHSAM01.CRE~  ~override~
              ~CHSAM02.CRE~  ~override~
              ~COPAMB01.cre~ ~override~
              ~COPAMB03.cre~ ~override~
              ~COPAMB04.cre~ ~override~
              ~DADROW11.CRE~ ~override~
              ~DADROW17.CRE~ ~override~
              ~DADROW20.CRE~ ~override~
              ~DADROW4.CRE~  ~override~
              ~DAQILUE.CRE~  ~override~
              ~DAWNMAS.cre~  ~override~
              ~democler.CRE~ ~override~
              ~DERRICK.cre~  ~override~
              ~DROW04.CRE~   ~override~
              ~EYEEGL01.CRE~ ~override~
              ~firorc02.cre~ ~override~
              ~firorc03.cre~ ~override~
              ~glad2.cre~    ~override~
              ~GORCAMB2.CRE~ ~override~
              ~GORCAMB3.CRE~ ~override~
              ~GORPRI1.CRE~  ~override~
              ~gromg05.CRE~  ~override~
              ~gromg08.CRE~  ~override~
              ~GROMG13.CRE~  ~override~
              ~HGBER01.CRE~  ~override~
              ~HGNYA01.CRE~  ~override~
              ~HGSKL01.CRE~  ~override~
              ~HGSKL03.CRE~  ~override~
              ~hlassa.cre~   ~override~
              ~hlketta.cre~  ~override~
              ~hlketta2.cre~ ~override~
              ~HLMAGE.CRE~   ~override~
              ~hprelate.cre~ ~override~
              ~jolus.cre~    ~override~
              ~kendak.cre~   ~override~
              ~kuocle20.cre~ ~override~
              ~magetest.CRE~ ~override~
              ~MVPRIES.CRE~  ~override~
              ~pace.cre~     ~override~
              ~PCAPT04.CRE~  ~override~
              ~pettin.CRE~   ~override~
              ~PIRMUR09.CRE~ ~override~
              ~PPALTK1.CRE~  ~override~
              ~PPALTK2.CRE~  ~override~
              ~ppguard3.cre~ ~override~
              ~ppsail03.cre~ ~override~ // armor in weapon slot fixed elsewhere
              ~ppsuna.cre~   ~override~
              ~REBAND05.CRE~ ~override~
              ~RECLER01.CRE~ ~override~
              ~RECLER02.CRE~ ~override~
              ~rethie01.cre~ ~override~
              ~RETHUG03.CRE~ ~override~
              ~RIGEN02.CRE~  ~override~
              ~ribald.cre~   ~override~
              ~ryan.cre~     ~override~
              ~sahamb03.cre~ ~override~
              ~sahamb06.cre~ ~override~
              ~salvanas.cre~ ~override~
              ~sarcult.cre~  ~override~
              ~sarcult2.cre~ ~override~
              ~sarculto.cre~ ~override~
              ~sarhal.cre~   ~override~
              ~SARMAG01.CRE~ ~override~
              ~SARTEM01.CRE~ ~override~
              ~SENDAI.CRE~   ~override~
              ~SENDAI2.CRE~  ~override~
              ~SENDAI8.CRE~  ~override~
              ~senorc01.cre~ ~override~
              ~senorc03.cre~ ~override~
              ~SENPRI01.CRE~ ~override~
              ~SHUGMG01.CRE~ ~override~
              ~SHUGPR01.CRE~ ~override~
              ~SNAKE01.CRE~  ~override~
              ~SNAKEG01.CRE~ ~override~
              ~suna.cre~     ~override~
              ~TELTIEF3.CRE~ ~override~
              ~temsup.cre~   ~override~
              ~thief5.cre~   ~override~
              ~TOBPAR05.CRE~ ~override~
              ~tomegol4.CRE~ ~override~
              ~TREVIL01.CRE~ ~override~
              ~TRTHF02.CRE~  ~override~
              ~turn.CRE~     ~override~
              ~UDDEAR02.CRE~ ~override~
              ~UDDROW14.CRE~ ~override~
              ~UDDROW15.CRE~ ~override~
              ~UDDROW31.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~UDDUER01.CRE~ ~override~
              ~UDELF05.CRE~  ~override~
              ~udgirl.CRE~   ~override~
              ~udtrap05.cre~ ~override~
              ~UHMER02.CRE~  ~override~
              ~vorsquir.CRE~ ~override~
              ~wauksna.CRE~  ~override~
              ~yaga02.CRE~   ~override~
              ~yaga04.CRE~   ~override~
              ~YSSOLD14.CRE~ ~override~
              ~YSSOLD16.CRE~ ~override~
              ~zilmag01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    FOR (index = 0 ; index < 4 ; index = index + 1) BEGIN // search through weapon slots
      READ_SHORT ("%slot_off%" + 0x12 + ("%index%" * 0x02)) "ref"
      PATCH_IF ("%ref%" != 0xffff) BEGIN // if valid reference in weapon slots
        WRITE_SHORT ("%slot_off%" + 0x4c) "%index%" // equipped weapon
        SET "index" = 4 // kills loop and prevents next patch_if
      END ELSE
      PATCH_IF ("%index%" = 3) BEGIN // if value hits 12, means no weapon slots are valid
        WRITE_SHORT ("%slot_off%" + 0x4c) 0xffff // equipped weapon is null, -1
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// eliminates pickpocket exploits
COPY_EXISTING ~ankheg01.cre~ ~override~
              ~bazdra02.cre~ ~override~
              ~cltiva01.cre~ ~override~
              ~firmag01.cre~ ~override~
              ~gemch02.cre~  ~override~
              ~hellgen.cre~  ~override~
              ~hlkang.cre~   ~override~
              ~jarlich.cre~  ~override~ // non-helm in helm slot for non-legit critical protection
              ~neb.cre~      ~override~ // non-helm in helm slot for non-legit critical protection
              ~ppjoye2.cre~  ~override~ // non-helm in helm slot for non-legit critical protection
              ~pptroll1.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
//              ~sctelwyn.cre~ ~override~
              ~trolsi01.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsi02.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsp01.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsp02.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trrak01.cre~  ~override~
              ~udprince.cre~ ~override~
  READ_LONG 0x2b8 "slot_off" ELSE 0
  READ_LONG 0x2bc "itm_off"  ELSE 0
  READ_LONG 0x2c0 "itm_num"  ELSE 0
  SET "added" = 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "bazplo02" = 0) OR // draconis' head
                 ("%item%" STRING_COMPARE_CASE "ghost3"   = 0) OR // item w/ visual effects
                 ("%item%" STRING_COMPARE_CASE "illblur"  = 0) OR // item w/ visual effects
                 ("%item%" STRING_COMPARE_CASE "misc12"   = 0) OR // ankheg shell
                 ("%item%" STRING_COMPARE_CASE "misc7f"   = 0) OR // Ti'Vael's head
                 ("%item%" STRING_COMPARE_CASE "misc8k"   = 0) OR // ihtafeer's head
                 ("%item%" STRING_COMPARE_CASE "misc9h"   = 0) OR // neb's head
                 ("%item%" STRING_COMPARE_CASE "misca7"   = 0) OR // sahuagin prince's blood
                 ("%item%" STRING_COMPARE_CASE "miscb7"   = 0) OR // tears of bhaal
                 ("%item%" STRING_COMPARE_CASE "miscbg"   = 0)    // lich's tooth
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "misc6z" = 0) AND    // beljuril
                 ("gemch02" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from chicken
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "key09" = 0) AND   // firkraag's prison key
                 ("firmag01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from conster
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "ring39" = 0) AND   // ring of gaxx
                 ("hlkang" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from kangaxx
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through item slots
        READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref"
        PATCH_IF (("%index2%" = 1) OR ("%index2%" = 3) OR (("%index2%" > 6) AND ("%index2%" < 18))) BEGIN // if legit slot (1, 3, 7-17)
          PATCH_IF ("%ref%" = "%index%") BEGIN // if item in question
            PATCH_IF ("%added%" = 0) BEGIN // if found in a legit slot
              SET "added" = 1
            END ELSE BEGIN // if already found
              WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) 0xffff // nulls reference
            END
          END ELSE
          PATCH_IF (("%ref%" = 0xffff) AND ("%added%" = 0)) BEGIN // if empty, legit slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%index%" // adds reference
            SET "added" = 1
          END
        END ELSE BEGIN // if non-legit spot
          PATCH_IF ("%ref%" = "%index%") BEGIN // if reference to item being moved and in non-legit spot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) 0xffff // nulls reference
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// summoned creatures shouldn't drop items
COPY_EXISTING ~dagnoll.cre~  ~override~ // halb01.itm, rndtre04.itm, rndtre02.itm
              ~gibbersu.cre~ ~override~ // rndtre02.itm
              ~gnollsu.cre~  ~override~ // helm01.itm, halb01.itm
              ~hamasu.cre~   ~override~ // dagg01.itm, potn20.itm, potn08.itm
              ~hobgobsu.cre~ ~override~ // bow05.itm, arow01.itm, leat01.itm, sw1h01.itm
              ~koboldsu.cre~ ~override~ // sw1h07.itm, bow05.itm, arow08.itm, arow01.itm, helm01.itm
              ~ogremasu.cre~ ~override~ // sw1h02.itm
              ~sahangu.cre~  ~override~ // rndtre04.itm, sper01.itm
              ~sahlace.cre~  ~override~ // rndtre04.itm
              ~sahskel.cre~  ~override~ // sw2h02.itm, rndtre05.itm, helm08.itm
              ~tasloisu.cre~ ~override~ // rndtre02.itm, sper01.itm, slng01.itm, bull01.itm, helm01.itm
              ~wolfwisu.cre~ ~override~ // misc01.itm
              ~wolfwwsu.cre~ ~override~ // misc01.itm
              ~wyvernsu.cre~ ~override~ // misc52.itm
              ~xvartsu.cre~  ~override~ // sw1h07.itm, rndtre02.itm, helm01.itm
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c0 "item_num"
  FOR (index = 0 ; index < item_num ; index = index + 1) BEGIN
    READ_BYTE ("%item_off%" + 0x10 + ("%index%" * 0x14)) "flags"
    PATCH_IF (("%flags%" BAND 0b00001000) = 0b00000000) BEGIN // if droppable
      WRITE_BYTE ("%item_off%" + 0x10 + ("%index%" * 0x14)) ("%flags%" BOR 0b00001000) // adds undroppable flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// set this batch to use their filename as DV
COPY_EXISTING ~bodfgt01.cre~ ~override~
              ~bodfgt02.cre~ ~override~
              ~cattig01.cre~ ~override~
              ~cldad.cre~    ~override~
              ~ffcrowd1.cre~ ~override~
              ~ffcrowd2.cre~ ~override~
              ~ffcrowd3.cre~ ~override~
              ~ffcrowd4.cre~ ~override~
              ~ffcrowd5.cre~ ~override~
              ~gerhardt.cre~ ~override~
              ~guard3.cre~   ~override~
              ~hobarc02.cre~ ~override~
              ~kpumb01.cre~  ~override~
              ~mourner4.cre~ ~override~
              ~mugger3.cre~  ~override~
              ~nobl4.cre~    ~override~
//              ~pparan2.cre~  ~override~
              ~rskel01.cre~  ~override~
              ~spidgi01.cre~ ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll2.cre~ ~override~
              ~swsfoll3.cre~ ~override~
              ~swsfoll4.cre~ ~override~
              ~swsfoll5.cre~ ~override~
              ~swsfoll6.cre~ ~override~
              ~toady.cre~    ~override~
              ~tolger2.cre~  ~override~
              ~tolmag01.cre~ ~override~
              ~uddoor02.cre~ ~override~
              ~vammat01.cre~ ~override~
              ~vamold01.cre~ ~override~
              ~wcust01.cre~  ~override~
              ~wcust02.cre~  ~override~
              ~wcust03.cre~  ~override~
              ~wcust04.cre~  ~override~
              ~wolfdi.cre~   ~override~
  WRITE_EVALUATED_ASCII 0x280 ~%SOURCE_RES%~ #18
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
COPY_EXISTING ~gordem.cre~   ~override~
              ~jondem02.cre~ ~override~
              ~jondem04.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x28 4352
  END
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
COPY_EXISTING ~dempit01.cre~ ~override~
  WRITE_SHORT 0x28 32558
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB check

  COPY_EXISTING ~demgla01.cre~ ~override~
                ~demglab.cre~  ~override~
                ~demglab2.cre~ ~override~
                ~demglasu.cre~ ~override~
                ~enddem01.cre~ ~override~
                ~enddem02.cre~ ~override~
                ~jondem01.cre~ ~override~
                ~jondem03.cre~ ~override~
                ~jondem05.cre~ ~override~
    WRITE_SHORT 0x28 57585
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~abisred1.cre~ ~override~
    WRITE_SHORT 0x28 57568
    BUT_ONLY_IF_IT_CHANGES

END

/*
// soundset fixes for carrion crawlers; unable to get this to work via 2da
COPY_EXISTING ~CARCRA01.CRE~ ~OVERRIDE~
              ~CARRIO.CRE~   ~OVERRIDE~
              ~CARRIOSU.CRE~ ~OVERRIDE~
              ~POLYCARR.CRE~ ~OVERRIDE~
              ~SEWCC.CRE~    ~OVERRIDE~
  SAY 0xc8 #5874
  SAY 0xcc #5875
  SAY 0xdc #5877
  SAY 0xe0 #5877
  SAY 0xe4 #5876
  SAY 0xec #5879
  SAY 0xf0 #5880
  SAY 0x010c #5872
  SAY 0x0110 #5873
  BUT_ONLY_IF_IT_CHANGES
*/  

// knows class- or alignment-restricted spell
COPY_EXISTING ~aerbod01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr105" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr314" = 0)) BEGIN
      DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
      SET "known_num" = ("%known_num%" - 1)
      PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
        SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
      END
      PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
        SET "mem_off" = ("%mem_off%" - 0x0C)
      END
      PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x0C)
      END
      PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
        SET "item_off" = ("%item_off%" - 0x0C)
      END
      PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x0C)
      END
    END
  END
  WRITE_LONG 0x2a0 "%known_off%"
  WRITE_LONG 0x2a4 "%known_num%"
  WRITE_LONG 0x2a8 "%meminfo_off%"
  WRITE_LONG 0x2b0 "%mem_off%"
  WRITE_LONG 0x2b8 "%slot_off%"
  WRITE_LONG 0x2bc "%item_off%"
  WRITE_LONG 0x2c4 "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES
  
// norh paladin from rep trap has wrong DV, script
COPY_EXISTING ~alex.cre~ ~override~
  WRITE_ASCII 0x248 ~NOrder~ #8 // override script
  WRITE_ASCII 0x280 ~NobleOrder~ #18 // DV
  BUT_ONLY_IF_IT_CHANGES

// has typos in spell resrefs
COPY_EXISTING ~amcarras.cre~ ~override~
  READ_LONG 0x2a0 "known_off" ELSE 0
  READ_LONG 0x2a4 "known_num" ELSE 0
  READ_LONG 0x2b0 "mem_off"   ELSE 0
  READ_LONG 0x2b4 "mem_num"   ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_REGEXP "^spw[0-9][0-9][0-9]$" = 0) BEGIN
      INSERT_BYTES ("%known_off%" + 0x03 + (0x0c * "%index%")) 1
      WRITE_ASCII  ("%known_off%" + 0x03 + (0x0c * "%index%")) "i"
      DELETE_BYTES ("%known_off%" + 0x08 + (0x0c * "%index%")) 1
    END
  END
  FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN
    READ_ASCII ("%mem_off%" +       (0x0c * "%index2%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_REGEXP "^spw[0-9][0-9][0-9]$" = 0) BEGIN
      INSERT_BYTES ("%mem_off%" + 0x03 + (0x0c * "%index2%")) 1
      WRITE_ASCII  ("%mem_off%" + 0x03 + (0x0c * "%index2%")) "i"
      DELETE_BYTES ("%mem_off%" + 0x08 + (0x0c * "%index2%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mem & known spell resref typos
COPY_EXISTING ~amelm01.cre~  ~override~
              ~jatermin.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"     
    SET "delta_known" = 0
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
      READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi121" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi125"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi122" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi610" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi624"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi706" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi719"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi709" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi718"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi802"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi806" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi816"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi814" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi817"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi901" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi917"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi904" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi906" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
    WRITE_LONG 0x2a8 "%meminfo_off%"
    SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
    WRITE_LONG  0x2b0 "%mem_off%"
    SET "delta_mem" = 0
    FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
      READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
      READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
      SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
      WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
      FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
        READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi121" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi125"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi122" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi610" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi624"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi706" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi719"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi709" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi718"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi802"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi806" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi816"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi814" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi817"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi901" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi917"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi904" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi906" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END
      END
      WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
    END
    WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
    SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// knows class- or alignment-restricted spell
COPY_EXISTING ~ammajira.cre~ ~override~
              ~chgood09.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2a0 "known_off"
    READ_LONG  0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
      READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
      PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr506" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr517" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr605" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr702" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr717" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a0 "%known_off%"
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
  END  
  BUT_ONLY_IF_IT_CHANGES

// eliminates non-STs from using ST soundset
COPY_EXISTING ~amsi.cre~     ~override~
              ~gpthief1.cre~ ~override~
  WRITE_LONG 0xcc 0xffffffff
  BUT_ONLY_IF_IT_CHANGES

// cre changes to match new kit.ids
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
              ~imoen.cre~    ~override~
              ~imoen6.cre~   ~override~
              ~imoen10.cre~  ~override~
              ~imoen15.cre~  ~override~
              ~imoen211.cre~ ~override~
              ~imoen213.cre~ ~override~
              ~mazzy8.cre~   ~override~
              ~mazzy9.cre~   ~override~
              ~mazzy11.cre~  ~override~
              ~mazzy12.cre~  ~override~
              ~mazzy15.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00000000) BEGIN
      WRITE_LONG 0x244 0x40000000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// aerie spellbook fix, should know flame blade
COPY_EXISTING ~aerie6.cre~  ~override~
              ~aerie7.cre~  ~override~
              ~aerie9.cre~  ~override~
              ~aerie10.cre~ ~override~
              ~aerie11.cre~ ~override~
              ~aerie12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// aerie7 has an extra star; need to remove spurious club prof
COPY_EXISTING ~aerie7.cre~ ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 115)) BEGIN // club prof
      DELETE_BYTES ("%fx_off%" + ("%index%" * 0x108)) 0x108
      SET "delta" = "%delta%" - 1
      SET "index" = "%fx_num%" // kills loop
    END
  END
  WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
  SET "offset" = ("%delta%" * 0x108)
  PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
    WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
    WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
    WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES
  
// anomen save fix
COPY_EXISTING ~anomen6.cre~ ~override~
  WRITE_BYTE 0x57 12 // save v breath
  BUT_ONLY_IF_IT_CHANGES

// anomen spellbook fix, remove fire seeds
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr607~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF ("sppr606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr314~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr414~ #3 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// anomen short 4 stars from f > c dual (revised by Wisp)
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x3c ~NANOMENM~  // portrait fix for anomen9 in SoA
    SET_BG2_PROFICIENCY 98 2 //spears
    SET_BG2_PROFICIENCY 102 1 //staffs
    SET_BG2_PROFICIENCY 112 2 //sword & shield
    SET_BG2_PROFICIENCY 97 "%SOURCE_RES%" STRING_CONTAINS_REGEXP "1[02]" ? 1 : 2 //war hammers
  END
  BUT_ONLY_IF_IT_CHANGES

// skeleton warrior anim fix
COPY_EXISTING ~ar18skel.cre~ ~override~
  WRITE_SHORT 0x28 60176

// assigning names to creatures; from UB
COPY_EXISTING ~ARNBOY01.CRE~ ~override~  // Apprentice Torturer Douglas
  SAY NAME1 #38998
  SAY NAME2 #38998

// Suryris's Blade is unique; repacing all cre references (still for sale at Ribald's)
COPY_EXISTING ~bazliz04.cre~ ~override~ // lizard man captain
              ~gorsta02.cre~ ~override~ // wk statue
              ~gorsta09.cre~ ~override~ // wk statue
              ~jarevia.cre~  ~override~ // reviane
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "halb03" = 0) BEGIN // find Suryris's Blade
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "halb07" #8 // replace with generic halberd +2
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~bazpat03.cre~ ~override~ // typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~wtasight~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~bonebld.cre~ ~override~
              ~sword01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    WRITE_BYTE 0x23a 25 // lower int to allowed range
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~boy1.cre~     ~override~ //typo
              ~vvstand3.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~runenemy~ #8
  BUT_ONLY_IF_IT_CHANGES

// DV changes
COPY_EXISTING ~brus.cre~  ~override~
              ~brus2.cre~ ~override~
  WRITE_ASCII 0x280 ~brus~ #18

// catti should not attack mages randomly
COPY_EXISTING ~C6CATTI.CRE~ ~OVERRIDE~
  WRITE_ASCII 0x0250 ~~ #8
  BUT_ONLY_IF_IT_CHANGES

// added paladiny stats to c6eric; replaces harbinger with party-friendly version
// both are also patched to LG alignment in the Oversight alignment section
COPY_EXISTING ~c6eric.cre~  ~override~
              ~c6eric3.cre~ ~override~
  WRITE_BYTE 0x238 15 // str
  WRITE_BYTE 0x23b 16 // wis
  WRITE_BYTE 0x23d 12 // con
  WRITE_BYTE 0x23e 18 // chr
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw2h07" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "cdsw2h07"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// cernd spellbook fixes
COPY_EXISTING ~cernd10.cre~  ~override~
              ~cernd12.cre~  ~override~
              ~cernd13.cre~  ~override~
              ~cernd13b.cre~ ~override~
              ~cernd14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // call woodland beings for mental domination
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr410~ #8
      END ELSE
      PATCH_IF ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // cure disease for ZoSA
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr317~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF (("sppr318" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr507" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// cernd12 missing star in single weapon style
COPY_EXISTING ~cernd12.cre~  ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "delta" = 1
  INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
    WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
    WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
    WRITE_LONG  ("%fx_off%" + 0x18) 113    // prof - single weapon style
    WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
    WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
//    WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
  WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
  SET "offset" = ("%delta%" * 0x108)
  PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
    WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
    WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
    WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// highest level cernds missing their override script, removing BG profs
COPY_EXISTING ~cernd13.cre~  ~override~
              ~cernd13b.cre~ ~override~
  WRITE_BYTE  0x6e 0
  WRITE_BYTE  0x6f 0
  WRITE_BYTE  0x70 0
  WRITE_BYTE  0x75 0
  WRITE_ASCII 0x248 ~CERND~ #8
  BUT_ONLY_IF_IT_CHANGES

// ToB cernd also missing his override script
COPY_EXISTING ~cernd14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~CERN25~ #8
    WRITE_BYTE  0x6e 0
    WRITE_BYTE  0x6f 0
    WRITE_BYTE  0x70 0
    WRITE_BYTE  0x75 0
  END
  BUT_ONLY_IF_IT_CHANGES

// prevents Tamoko from running away and making PP challenge unfinishable, see cdtamoko.bcs for other half
COPY_EXISTING ~chtaz02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~cdtamoko~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// Ellesime clone in Chateau Irenicus
COPY_EXISTING ~clone1.cre~ ~override~
  WRITE_LONG 0x28 32561
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow9.cre~ ~override~ // typo
  WRITE_ASCII 0x250 ~mage8a~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow10.cre~ ~override~ //typo
  WRITE_ASCII 0x250 ~pries10b~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow12.cre~ ~override~ //typo
  WRITE_ASCII 0x250 ~pries14t~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow15.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~mage8a~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~daghaun1.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~pries14t~ #8
  BUT_ONLY_IF_IT_CHANGES

// lots o' bugs in ddguard series, easier to clone a friend
COPY_EXISTING ~ddguard1.cre~ ~override/ddguard2.cre~
              ~ddguard1.cre~ ~override/ddguard3.cre~
              ~ddguard1.cre~ ~override/ddguard4.cre~
              ~ddguard1.cre~ ~override/ddguard5.cre~
              ~ddguard1.cre~ ~override/ddguard6.cre~
  WRITE_EVALUATED_ASCII 0x280 ~%DEST_RES%~ #18
  WRITE_EVALUATED_ASCII 0x2CC ~%DEST_RES%~ #8
  READ_LONG             0x2BC "itm_off"
  READ_SHORT            0x2C0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + ("%index%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "key14" = 0) BEGIN
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard2" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key15~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard3" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key16~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard4" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key17~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard5" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key18~ #8
      END ELSE BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key19~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// illegal CON scores
COPY_EXISTING ~deadb01.cre~  ~override~
              ~deadb02.cre~  ~override~
              ~deadb03.cre~  ~override~
              ~firwlf01.cre~ ~override~
              ~firwlf02.cre~ ~override~
              ~rngwlf01.cre~ ~override~
              ~rngwlf02.cre~ ~override~
              ~rngwlf03.cre~ ~override~
              ~rngwlf04.cre~ ~override~
              ~rngwlf05.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    WRITE_BYTE 0x23d 25 // lower con to allowed range
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~demgla01.cre~ ~override~ // has summoned script, so destroys allies in shade lord dungeon
              ~demnab02.cre~ ~override~ // script reference broken, changed so they'll use actual powers instead of just melee
  WRITE_ASCII 0x248 ~tanari~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dempit01.cre~ ~override~ //assigned to dempit.cre
              ~telpit2.cre~  ~override~ //assigned to dempit.cre
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~dempit~ #8
  END  
  BUT_ONLY_IF_IT_CHANGES

// ferric runs away since he uses Yoshimo's script
COPY_EXISTING ~deshar.cre~ ~override~
  WRITE_ASCII 0x258 ~thief14t~ #8
  BUT_ONLY_IF_IT_CHANGES

// fallen devas using normal deva script
COPY_EXISTING ~devaevil.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~devaevil~ // override script
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes good deva's spells
// sets devas to lev 25 to match fallen devas and planetars
COPY_EXISTING ~devagood.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x234 25
    READ_LONG  0x2a0 "known_off"
    READ_LONG  0x2a8 "mem_info"
    READ_LONG  0x2b0 "mem_off"
    READ_LONG  0x2b4 "mem_num"
    READ_LONG  0x2b8 "slot_off"
    READ_LONG  0x2bc "item_off"
    READ_LONG  0x2c4 "fx_off"
    SET "mem_delta" = 0
    FOR (index = 4 ; index < 17 ; index = index + 1) BEGIN
      PATCH_IF (("%index%" = 4) OR ("%index%" = 6)) BEGIN
        READ_SHORT  ("%mem_info%" + 0x02 + ("%index%" * 0x10)) "num_mem1"
        READ_SHORT  ("%mem_info%" + 0x04 + ("%index%" * 0x10)) "num_mem2"
        READ_LONG   ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "mem_idx"
        READ_SHORT  ("%mem_info%" + 0x0c + ("%index%" * 0x10)) "mem_count"
        WRITE_SHORT ("%mem_info%" + 0x02 + ("%index%" * 0x10)) ("%num_mem1%" + 2)
        WRITE_SHORT ("%mem_info%" + 0x04 + ("%index%" * 0x10)) ("%num_mem2%" + 2)
        SET "mem_idx" = "%mem_idx%" + "%mem_delta%"
        WRITE_LONG  ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "%mem_idx%"
        WRITE_SHORT ("%mem_info%" + 0x0c + ("%index%" * 0x10)) ("%mem_count%" + 2)
        FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
          INSERT_BYTES    ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) 0x0c
            PATCH_IF ("%index%" = 4) BEGIN
              WRITE_ASCII ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) ~sppr502~
            END ELSE BEGIN
              WRITE_ASCII ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) ~sppr725~
            END
            WRITE_SHORT   ("%mem_off%" + 0x08 + (0x0c * ("%mem_delta%" + "%mem_idx%"))) 1
        END
        SET "mem_delta" = "%mem_delta%" + 2
      END ELSE BEGIN // adjust indices for other levels
        READ_LONG   ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "mem_idx"
        WRITE_LONG  ("%mem_info%" + 0x08 + ("%index%" * 0x10)) ("%mem_idx%" + "%mem_delta%")
      END
    END
    WRITE_LONG 0x2b4 ("%mem_num%" + "%mem_delta%")
    // final wrapup; correct # of memorized spells and offsets
    SET "offset_delta" = ("%mem_delta%" * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~drow06.cre~   ~override~
              ~uddrow19.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
      WRITE_ASCII ("%known_off%" +       (0x0c * "%index%")) "spwi811"
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi811"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// create 'dead' or 'knocked down' versions of 'special' trolls (revised by Nythrun)
COPY_EXISTING 
drshnl01.cre ~override/drshnl11.cre~
eletro01.cre ~override/eletro03.cre~
kptrol03.cre ~override/kptrol23.cre~
pptroll1.cre ~override/pptroll2.cre~
sutroll.cre  ~override/sutroll2.cre~
torgal.cre   ~override/torgal2.cre~
  WRITE_SHORT    0x24    1 // current HP
  WRITE_SHORT    0x46   10 // natural AC
  WRITE_SHORT    0x48   10 // effective AC
  WRITE_BYTE     0x5a  100 // resist cold
  WRITE_BYTE     0x5b  100 // resist electricity
  WRITE_BYTE     0x5f  100 // resist magic cold
  WRITE_BYTE     0x60  100 // resist slashing
  WRITE_BYTE     0x61  100 // resist crushing
  WRITE_BYTE     0x62  100 // resist piercing
  WRITE_BYTE     0x63  100 // resist missile
  WRITE_BYTE     0x23c   9 // dexterity
  WRITE_BYTE     0x270 255 // enemy
  PATCH_IF          "%SOURCE_RES%" STRING_EQUAL_CASE kptrol03 BEGIN
    WRITE_ASCII  0x248 kptrol13   // override script
  END ELSE PATCH_IF "%SOURCE_RES%" STRING_EQUAL_CASE drshnl01 BEGIN
    WRITE_ASCII  0x248 drshnl21
  END ELSE PATCH_IF "%SOURCE_RES%" STRING_EQUAL_CASE torgal   BEGIN
    WRITE_ASCII  0x248 torgal3 #8 
  END ELSE BEGIN
    WRITE_ASCIIE 0x248 ~%SOURCE_RES%~ // new script
  END
  WRITE_ASCII    0x250 ~~ #32         // blanks all other script references
  WRITE_ASCII    0x2cc ~~ #8          // blanks dialog file
  REMOVE_CRE_ITEM  monhp1 trollreg trollspi
  REPLACE_CRE_ITEM trolldie #0 #0 #0 ~UNSTEALABLE&UNDROPPABLE~ BELT

// add monhp1 item to trolls to prevent death; assign script to force transformation to dead form at low HP
COPY_EXISTING ~drshnl01.cre~ ~override~
              ~eletro01.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~pptroll1.cre~ ~override~
              ~sutroll.cre~  ~override~
              ~torgal.cre~   ~override~
  ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "kptrol03" = 0) BEGIN
    WRITE_ASCII 0x248 ~kptrol23~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "drshnl01" = 0) BEGIN
    WRITE_ASCII 0x248 ~drshnl11~
    WRITE_ASCII 0x258 ~drshnl01~ // restore Nith's attack script, pt 2: assign script
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "eletro01" = 0) BEGIN
    WRITE_ASCII 0x248 ~eletro03~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "pptroll1" = 0) BEGIN
    WRITE_ASCII 0x248 ~pptroll2~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "sutroll" = 0) BEGIN
    WRITE_ASCII 0x248 ~sutroll2~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "torgal" = 0) BEGIN
    WRITE_ASCII 0x258 ~torgal2~ #8 // race script
  END

// one-off change for Nilthiri to prevent repeating dialogue after regenerating
COPY_EXISTING ~drshnl01.cre~ ~override/drshnl21.cre~
  WRITE_ASCII 0x250 ~~ #8 // no approach and speak script
  WRITE_BYTE  0x270 255   // enemy
  WRITE_ASCII 0x2cc ~~ #8 // no dialogue file

// makes druidad DestroySelf() if player is great druid; druidad.baf is compiled in the folder
COPY_EXISTING ~druidad.cre~ ~override~
  WRITE_ASCII 0x248 ~druidad~ #8 // override script
  WRITE_ASCII 0x250 ~initdlg~ #8 // class script
  BUT_ONLY_IF_IT_CHANGES
  
// edwin spell slot fix
// this is long and ugly. Edwin has one additional slot per level; so we remove all
// of his memorized mage spells and rebuild the section completely. The same methodology
// is also used to rebuild haer15, minsc8,9,10,12 and nalia8,9,13 and valyg8,9,11,12,13,16.
COPY_EXISTING ~edwin7.cre~  ~override~
              ~edwin9.cre~  ~override~
              ~edwin11.cre~ ~override~
              ~edwin12.cre~ ~override~
              ~edwin13.cre~ ~override~
              ~edwin15.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x18  "xp"
    READ_BYTE 0x234 "level"
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a8 "mem_info"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
    READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
    DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
    SET "delta" = 0

    // level 1
    SET "lev1" = 5
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi120~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi119~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi119~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi104~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi102~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi101~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 7)
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev1" = ("%lev1%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi106~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi102~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) ("%lev1%" + 2)
  
    //level 2 fixes
    SET "lev2" = 4
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi201~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi220~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi215~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi212~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi205~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 6)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi217~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi205~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi209~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi220~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev2%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) ("%lev2%" + 2)
  
    //level 3 fixes
    SET "lev3" = 4
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi314~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi309~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi304~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi303~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi302~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 6)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi308~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi307~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi304~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev3%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) ("%lev3%" + 2)
  
    //level 4 fixes
    SET "lev4" = 3
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi416~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi407~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 5)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev4" = ("%lev4%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi405~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi407~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev4" = ("%lev4%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi401~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev4%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) ("%lev4%" + 2)
  
    //level 5 fixes
    SET "lev5" = 2
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi522~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi516~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi505~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi504~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 4)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev5" = ("%lev5%" + 2)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi521~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi520~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 2)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev5" = ("%lev5%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi502~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev5%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) ("%lev5%" + 2)
  
    //level 6 fixes
    SET "lev6" = 0
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev6" = ("%lev6%" + 2) // not an error
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi619~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi612~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi605~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi601~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 4)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev6" = ("%lev6%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi620~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (12 * 0x10)) "%lev6%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (12 * 0x10)) "%lev6%"
    PATCH_IF ("%lev6%" > 0) BEGIN
      WRITE_LONG  ("%mem_info%" + 0x08 + (12 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev6%" + 2))
      WRITE_SHORT ("%mem_info%" + 0x0c + (12 * 0x10)) ("%lev6%" + 2)
    END ELSE BEGIN
      WRITE_LONG  ("%mem_info%" + 0x08 + (12 * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (12 * 0x10)) 0
    END

    // wrapping up; correcting indexes for remaining wizard spells and innates
    SET "loops" = 0
    WHILE ("%loops%" < 3) BEGIN
      SET "loops" = ("%loops%" + 1)
      WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 12) * 0x10)) 0
      WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 12) * 0x10)) 0
      WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 12) * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 12) * 0x10)) 0
    END
    WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
    
    // final wrapup; correct # of memorized spells and offsets
    WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
    SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// 'knocked down' troll can be killed by anything
COPY_EXISTING ~firamb05.cre~ ~override~
  WRITE_SHORT           0x24    1            // current HP
  WRITE_SHORT           0x46   10            // natural AC
  WRITE_SHORT           0x48   10            // effective AC
  WRITE_BYTE            0x5a  100            // resist cold
  WRITE_BYTE            0x5b  100            // resist electricity
  WRITE_BYTE            0x5f  100            // resist magic cold
  WRITE_BYTE            0x60  100            // resist slashing
  WRITE_BYTE            0x61  100            // resist crushing
  WRITE_BYTE            0x62  100            // resist piercing
  WRITE_BYTE            0x63  100            // resist missile
  WRITE_BYTE            0x23c   9            // dexterity
  WRITE_BYTE            0x270 255            // enemy
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// familiar fixes                                   \\\\\
/////                                                  \\\\\

// see also string fixes

// soa pseudo-dragon
COPY_EXISTING ~fampsd.cre~   ~override~
  WRITE_SHORT 0x46  2 // AC
  WRITE_SHORT 0x48  2 // AC
  WRITE_BYTE  0x5d 50 // resist magic
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "s1-3" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) ~cdfampsd~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// soa ferret
COPY_EXISTING ~famfer.cre~ ~override~
  WRITE_BYTE  0x45 30 // hide in shadows
  WRITE_SHORT 0x46 4  // natural ac
  WRITE_SHORT 0x48 4  // effective ac
  WRITE_BYTE  0x68 30 // move silently
  WRITE_BYTE  0x69 15 // find/disarm traps
  WRITE_BYTE  0x6a 65 // pick pockets
  BUT_ONLY_IF_IT_CHANGES

// soa imp
COPY_EXISTING ~famimp.cre~ ~override~
  WRITE_SHORT 0x46 6  // natural ac
  WRITE_SHORT 0x48 6  // effective ac
  BUT_ONLY_IF_IT_CHANGES
  
// soa rabbit
COPY_EXISTING ~famrab.cre~   ~override~
  WRITE_BYTE  0x45 20 // hide in shadows
  WRITE_SHORT 0x46 5  // natural ac
  WRITE_SHORT 0x48 5  // effective ac
  WRITE_BYTE  0x59 75 // resist fire
  WRITE_BYTE  0x5c 0  // resist acid
  WRITE_BYTE  0x5d 65 // resist magic
  WRITE_BYTE  0x5e 75 // resist magic fire
  WRITE_BYTE  0x68 20 // move silently
  WRITE_BYTE  0x69 45 // find/disarm traps
  WRITE_BYTE  0x6a 0  // pick pockets
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "mepfir" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
    END
  END
  // rabtring deleted elsewhere
  BUT_ONLY_IF_IT_CHANGES

// soa dust mephit
COPY_EXISTING ~famdust.cre~   ~override~
  WRITE_SHORT 0x46 10 // natural ac
  WRITE_SHORT 0x48 10 // effective ac
  BUT_ONLY_IF_IT_CHANGES
  
// soa fairy dragon
COPY_EXISTING ~famfair.cre~   ~override~
  WRITE_SHORT 0x46 8 // natural ac
  WRITE_SHORT 0x48 8 // effective ac
  WRITE_BYTE  0x59 0 // resist fire
  WRITE_BYTE  0x5b 0 // resist electricity
  WRITE_BYTE  0x5e 0 // resist magic fire
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "meplig" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// soa cat
COPY_EXISTING ~famcat.cre~   ~override~
  WRITE_BYTE  0x45 89 // hide in shadows
  WRITE_SHORT 0x46 4  // natural ac
  WRITE_SHORT 0x48 4  // effective ac
  WRITE_BYTE  0x68 89 // move silently
  // sound restorations
  SAY 0xa4 @126
  SAY 0xc8 @126
  SAY 0xec @126
  SAY 0xf0 @126
  SAY 0x010c @126
  SAY 0x0110 @126
  // hastring deleted elsewhere
  BUT_ONLY_IF_IT_CHANGES
  
// soa quasit
COPY_EXISTING ~famquas.cre~   ~override~
  WRITE_SHORT 0x46 6  // natural ac
  WRITE_SHORT 0x48 6  // effective ac
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "impqua" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-6" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // tob familiars
  
  // tob pseudo-dragon
  COPY_EXISTING ~fampsd25.cre~   ~override~
    WRITE_SHORT 0x46  2 // AC
    WRITE_SHORT 0x48  2 // AC
    WRITE_BYTE  0x5d 50 // resist magic
    WRITE_BYTE 0x238 15 // strength
    BUT_ONLY_IF_IT_CHANGES
  
  // tob ferret
  COPY_EXISTING ~famfer25.cre~ ~override~
    WRITE_BYTE  0x45 50 // hide in shadows
    WRITE_SHORT 0x46 0  // natural ac
    WRITE_SHORT 0x48 0  // effective ac
    WRITE_BYTE  0x68 50 // move silently
    WRITE_BYTE  0x69 55 // find/disarm traps
    WRITE_BYTE  0x6a 85 // pick pockets
    WRITE_BYTE 0x238 15 // strength
    BUT_ONLY_IF_IT_CHANGES

  // tob imp
  COPY_EXISTING ~famimp25.cre~ ~override~
    WRITE_SHORT 0x46 2  // natural ac
    WRITE_SHORT 0x48 2  // effective ac
    BUT_ONLY_IF_IT_CHANGES
  
  // tob rabbit
  COPY_EXISTING ~famrab25.cre~ ~override~
    WRITE_BYTE  0x45 50 // hide in shadows
    WRITE_SHORT 0x46 5  // natural ac
    WRITE_SHORT 0x48 5  // effective ac
    WRITE_BYTE  0x59 75 // resist fire
    WRITE_BYTE  0x5a 75 // resist cold
    WRITE_BYTE  0x5b 75 // resist electricity
    WRITE_BYTE  0x5e 75 // resist magic fire
    WRITE_BYTE  0x5f 75 // resist magic cold
    WRITE_BYTE  0x68 50 // move silently
    WRITE_BYTE  0x69 80 // find/disarm traps
    WRITE_BYTE  0x6a 0  // pick pockets
    BUT_ONLY_IF_IT_CHANGES
  
  // tob dust mephit
  COPY_EXISTING ~famdus25.cre~ ~override~
    WRITE_SHORT 0x46 7  // natural ac
    WRITE_SHORT 0x48 7  // effective ac
    ADD_MEMORIZED_SPELL ~spwi224~ #1 ~wizard~     // glitterdust
    ADD_MEMORIZED_SPELL ~spin935~ #0 ~innate~ (2) // 2x glass dust
    BUT_ONLY_IF_IT_CHANGES

  // tob fairy dragon
  COPY_EXISTING ~famfai25.cre~   ~override~
    WRITE_SHORT 0x24 48 // current hp
    WRITE_SHORT 0x26 48 // max hp
    WRITE_SHORT 0x46 4  // natural ac
    WRITE_SHORT 0x48 4  // effective ac
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
      READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "meplig" = 0) BEGIN // find invalid resref
        WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
      END
    END
    BUT_ONLY_IF_IT_CHANGES
    
  // tob cat
  COPY_EXISTING ~famcat25.cre~   ~override~
    WRITE_BYTE  0x45 89 // hide in shadows
    WRITE_SHORT 0x46 0  // natural ac
    WRITE_SHORT 0x48 0  // effective ac
    WRITE_BYTE  0x68 89 // move silently
    WRITE_BYTE  0x69 55 // find/disarm traps
    WRITE_BYTE  0x6a 50 // pick pockets
    // hastring deleted elsewhere
    BUT_ONLY_IF_IT_CHANGES
    
  // tob quasit
  COPY_EXISTING ~famqua25.cre~   ~override~
    WRITE_SHORT 0x46 2  // natural ac
    WRITE_SHORT 0x48 2  // effective ac
    BUT_ONLY_IF_IT_CHANGES
  
END

// removes stolen flag from item
COPY_EXISTING ~GORSTA09.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c0 "itm_num"
    WHILE ("%itm_num%" > 0) BEGIN
      SET "itm_num" = ("%itm_num%" - 1)
      READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "halb07" = 0) BEGIN
        READ_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) "flags"
        WRITE_BYTE ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) ("%flags%" BAND 0b11111011)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// haer's elemental resistances and kit.ids fixes
COPY_EXISTING ~haer10.cre~ ~override~
              ~haer11.cre~ ~override~
              ~haer13.cre~ ~override~
              ~haer15.cre~ ~override~
              ~haer19.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x59 25 // these w_b are fixes for haer's elemental resistances
    WRITE_BYTE 0x5a 50
    WRITE_BYTE 0x5b 25
    WRITE_BYTE 0x5c 0
    WRITE_BYTE 0x5d 0
    WRITE_BYTE 0x5e 25
    WRITE_BYTE 0x5f 50
    WRITE_BYTE 0x60 15
    WRITE_BYTE 0x61 15
    WRITE_BYTE 0x62 15
    WRITE_BYTE 0x63 15
    WRITE_BYTE 0x6A 50 //pickpocketing, overwritten below for haer10, 11, 13
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00000020) BEGIN
      WRITE_LONG 0x244 0x400d0000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hd pickpocket fixes
COPY_EXISTING ~haer10.cre~ ~override~
  WRITE_BYTE 0x6A 25 //pickpocketing

COPY_EXISTING ~haer11.cre~ ~override~
  WRITE_BYTE 0x6A 30 //pickpocketing

COPY_EXISTING ~haer13.cre~ ~override~
  WRITE_BYTE 0x6A 40 //pickpocketing

// haer'dalis spell issues
COPY_EXISTING ~haer15.cre~ ~override~
  ADD_KNOWN_SPELL ~spwi106~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi112~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi113~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi116~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi201~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi206~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi209~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi212~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi303~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi305~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi312~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi401~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi406~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi408~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi508~ #4 ~wizard~
  ADD_KNOWN_SPELL ~spwi510~ #4 ~wizard~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi113~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi106~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) "%lev1%"

  //level 2 fixes
  SET "lev2" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi209~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi206~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi201~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi312~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi303~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) "%lev3%"

  //level 4 fixes
  SET "lev4" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi401~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - "%lev4%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) "%lev4%"

  //level 5 fixes
  SET "lev5" = 2
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi510~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi508~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 2)
  WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - "%lev5%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) "%lev5%"

  // wrapping up; correcting indexes for remaining wizard spells and innates
  SET "loops" = 0
  WHILE ("%loops%" < 4) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 11) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 11) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 11) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 11) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// knows class- or alignment-restricted spell
COPY_EXISTING ~heartg3.cre~ ~override~
              ~heartg4.cre~ ~override~
              ~heartg5.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr105" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr314" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr605" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr606" = 0)) BEGIN
      DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
      SET "known_num" = ("%known_num%" - 1)
      PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
        SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
      END
      PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
        SET "mem_off" = ("%mem_off%" - 0x0C)
      END
      PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x0C)
      END
      PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
        SET "item_off" = ("%item_off%" - 0x0C)
      END
      PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x0C)
      END
    END
  END
  WRITE_LONG 0x2a0 "%known_off%"
  WRITE_LONG 0x2a4 "%known_num%"
  WRITE_LONG 0x2a8 "%meminfo_off%"
  WRITE_LONG 0x2b0 "%mem_off%"
  WRITE_LONG 0x2b8 "%slot_off%"
  WRITE_LONG 0x2bc "%item_off%"
  WRITE_LONG 0x2c4 "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES

// improved continuity fixes from Oversight
COPY_EXISTING ~hellslay.cre~ ~override~
  SAY BATTLE_CRY1 #60501
  SAY BATTLE_CRY2 #60502
  SAY SELECT_COMMON1 #60500
  SAY DAMAGE #60503
  SAY DYING #60504

COPY_EXISTING ~helmbyr.cre~  ~override~ // replaces nonexistent initpc
              ~latlara.cre~  ~override~
              ~talvilon.cre~ ~override~
  WRITE_ASCII 0x250 ~initmain~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~jael01.cre~   ~override~
              ~ppumb01.cre~  ~override~
              ~pries18b.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr714" = 0) BEGIN
      WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "sppr706"
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr714" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "sppr706"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// trolls lacking the correct 1hp items
COPY_EXISTING ~hgtrl01.cre~  ~override~ // fire troll
              ~kptrol01.cre~ ~override~ // kptrol0[1-4] are trolls from de'Arnise keep
              ~kptrol02.cre~ ~override~
//              ~kptrol03.cre~ ~override~ handled in special batch above
              ~kptrol04.cre~ ~override~
              ~obsice01.cre~ ~override~ // snow troll from planar sphere
              ~trolgi01.cre~ ~override~ // generic giant troll
              ~trollens.cre~ ~override~ // giant troll
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~ // either adds it new, or forces minhp1 into inventory (and unequipped)
  END
  BUT_ONLY_IF_IT_CHANGES

// removes duplicate Sir Donalus
COPY_EXISTING ~HELMPR.CRE~ ~OVERRIDE~
  SAY 0x08 #17221
  SAY 0x0c #17221
  BUT_ONLY_IF_IT_CHANGES

//shyressa is a female vamp, but uses male vamp avatar
COPY_EXISTING ~hlshyr.cre~ ~override~
  WRITE_SHORT 0x28 32546
  BUT_ONLY_IF_IT_CHANGES

// lesser clay golems not immune to backstab
COPY_EXISTING ~igolfle1.cre~ ~override~
              ~igolfle2.cre~ ~override~
              ~igolfle3.cre~ ~override~
              ~igolfle4.cre~ ~override~
  ADD_CRE_ITEM ~golcla~ #0 #0 #0 ~NONE~ ~LRING RRING AMULET~
  BUT_ONLY_IF_IT_CHANGES

// imoen's thieving, script, prof, and thac0 fixes
COPY_EXISTING ~imoen10.cre~  ~override~
              ~imoen15.cre~  ~override~
              ~imoen211.cre~ ~override~
              ~imoen213.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    PATCH_IF (("%SOURCE_RES%" STRING_COMPARE_CASE "imoen15" = 0) OR  // restore battlecry and correct
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen211" = 0) OR // Imoen's bio post-Spellhold
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen213" = 0)) BEGIN
      SAY 0xd0  #11035
      SAY 0x1cc @102
    END
    PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen213" = 0) BEGIN
      WRITE_ASCII 0x248 ~imoen2~ #8 // override script missing from imoen213
    END
    WRITE_BYTE 0x67 75 // open locks
    WRITE_BYTE 0x69 85 // find/disarm traps
    WRITE_BYTE 0x6a 10 // pickpocketing
    PATCH_IF (("%SOURCE_RES%" STRING_COMPARE_CASE "imoen10" = 0) OR
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen211" = 0)) BEGIN // thac0 adjustment for low level versions
      WRITE_BYTE 0x52 17 // thac0
    END ELSE BEGIN                                                       // extra prof for high level versions
      SET "delta" = 2
      INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
        WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
        WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
        WRITE_LONG  ("%fx_off%" + 0x18) 113    // prof - single weapon
        WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
        WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
        WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 91     // prof - short sword
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assign galvarey a script that won't cause him to stutter (see soa-dlg.d for dialogue trigger change)
COPY_EXISTING ~jagalvar.cre~ ~override~
  WRITE_ASCII 0x250 ~initin15~ // class script
  BUT_ONLY_IF_IT_CHANGES
  
// jaheira thac0 and spellbook fixes... many
COPY_EXISTING ~jaheir7.cre~  ~override~
              ~jaheir8.cre~  ~override~
              ~jaheir11.cre~ ~override~
              ~jaheir12.cre~ ~override~
              ~jahei14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level1"
    WRITE_BYTE 0x52 (21 - "%level1%") // thac0
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr208" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // entangle for remove fear
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr105~ #8
      END ELSE
      PATCH_IF ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // summon insects for ZoSA
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr319~ #8
      END ELSE
      PATCH_IF ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // cause serious wounds for mental domination
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr414~ #8
      END ELSE
      PATCH_IF ("sppr507" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // true seeing for champion's strength
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr505~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF (("sppr108" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr507" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
    PATCH_IF ("%level1%" = 8) BEGIN // jaheir11
      ADD_KNOWN_SPELL ~sppr501~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr502~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr505~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr506~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr508~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr509~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr510~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr514~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr516~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr517~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr602~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr604~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr605~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr606~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr607~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr608~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr610~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr611~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr613~ #5 ~priest~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes Jahs' missing prof star and inconsistent dex at higher levels
COPY_EXISTING ~JAHEIR12.cre~ ~override~
              ~JAHEI14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    WRITE_BYTE 0x23c 17 // sets dex to 17
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
      READ_LONG ("%fx_off%" + 0x18 + ("%fx_num%" * 0x108)) "wpn"
      PATCH_IF (("%type%" = 233) AND ("%wpn%" = 95)) BEGIN      // if scimitar prof
        WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 2 // set to 2 stars
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// jan's thieving skills incorrect
COPY_EXISTING ~jan10.cre~ ~override~
   WRITE_BYTE 0x45  0 // Hide in Shadows
   WRITE_BYTE 0x64 60 // Detect Illusions
   WRITE_BYTE 0x65 20 // Set Traps
   WRITE_BYTE 0x67 75 // Open Locks
   WRITE_BYTE 0x68  0 // Move Silently
   WRITE_BYTE 0x69 65 // Find Traps
   WRITE_BYTE 0x6a 45 // Pickpockets

COPY_EXISTING ~jan11.cre~ ~override~
   WRITE_BYTE 0x45  0 // Hide in Shadows
   WRITE_BYTE 0x64 70 // Detect Illusions
   WRITE_BYTE 0x65 25 // Set Traps
   WRITE_BYTE 0x67 75 // Open Locks
   WRITE_BYTE 0x68  0 // Move Silently
   WRITE_BYTE 0x69 75 // Find Traps
   WRITE_BYTE 0x6a 45 // Pickpockets

// jan12 and jan15 shortchanged one prof star, thieving skill fixes
COPY_EXISTING ~jan12.cre~  ~override~
              ~jan15.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x45  5 // Hide in Shadows
    WRITE_BYTE 0x64 76 // Detect Illusions
    WRITE_BYTE 0x65 34 // Set Traps
    WRITE_BYTE 0x67 78 // Open Locks
    WRITE_BYTE 0x68 0  // Move Silently
    WRITE_BYTE 0x69 77 // Find Traps
    WRITE_BYTE 0x6a 45 // Pickpockets
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 106    // prof - dart
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mimics should actually be inside its chest
COPY_EXISTING ~jugmim01.cre~ ~override~ // killer mimic
  ADD_CRE_ITEM ~wallpass~ #0 #0 #0 ~NONE~ ~AMULET LRING RRING~
  BUT_ONLY_IF_IT_CHANGES

// keldorn's initial saves are too high
COPY_EXISTING ~keldor8.cre~  ~override~  
              ~keldor9.cre~  ~override~
              ~keldor10.cre~ ~override~
              ~keldor12.cre~ ~override~
              ~keldor14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
      READ_BYTE  (0x54 + "%index%") "save"
      WRITE_BYTE (0x54 + "%index%") ("%save%" - 2)
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
//Keldorn proficiency fix
COPY_EXISTING ~keldor9.cre~ ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "orig_fx_num" = "%fx_num%"
  SET "patch" = 0
  WHILE (("%fx_num%" > 0) AND ("%patch%" = 0)) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%fx_num%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 90)) BEGIN // if longsword prof exists
      WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 2
      SET "patch" = 1
    END
  END
  PATCH_IF ("%patch%" = 0) BEGIN // if not present and adjusted
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 2      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 90     // prof
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    SET "patch" = 2
  END
  PATCH_IF ("%patch%" = 2) BEGIN // fixes offsets if bytes were inserted
    WRITE_LONG 0x2c8 ("%orig_fx_num%" + 1)
    PATCH_IF ("%fx_off%" < "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + 0x108)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~KORCRAZY.CRE~ ~override~  // Crazyface, Korgan's old cohort
  SAY NAME1 #30508
  SAY NAME2 #30509

// korgan's kit.ids fixes
COPY_EXISTING ~korgan8.cre~  ~override~
              ~korgan9.cre~  ~override~
              ~korgan11.cre~ ~override~
              ~korgan12.cre~ ~override~
              ~korgan15.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00010000) BEGIN
      WRITE_LONG 0x244 0x40010000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~KORPIMG1.CRE~ ~override~  // Pimlico Guard
  SAY NAME1 #30490
  SAY NAME2 #30490

// keep dogs don't go hostile when oty attacked
COPY_EXISTING ~kpdog01.cre~ ~override~
              ~kpdog02.cre~ ~override~
              ~kpdog03.cre~ ~override~
              ~kpdog04.cre~ ~override~
  WRITE_ASCII 0x248 ~cdkpdog~ #8
  BUT_ONLY_IF_IT_CHANGES

// live/dead troll versions have mismatching XP
COPY_EXISTING ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~rogtro01.cre~ ~override~
  WRITE_LONG 0x14 1400
  BUT_ONLY_IF_IT_CHANGES

// revived version of kptrol03
COPY_EXISTING ~kptrol03.cre~ ~override/kptrol13.cre~

// there can be only one. Paac.
COPY_EXISTING ~mage16c.cre~ ~override~
  SAY 0x08 #15232
  SAY 0x0c #15232
  BUT_ONLY_IF_IT_CHANGES

//Mazzy proficiency fix
COPY_EXISTING ~mazzy9.cre~  ~override~
              ~mazzy12.cre~ ~override~
              ~mazzy15.cre~ ~override~
  READ_BYTE 0x234 "level" ELSE 0
  READ_LONG 0x2c4 "fx_off" ELSE 0
  READ_LONG 0x2c8 "fx_num" ELSE 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 91)) BEGIN // ss prof
      PATCH_IF ("%level%" < 10) BEGIN
        WRITE_LONG ("%fx_off%" + 0x14 + ("%index%" * 0x108)) 2
      END ELSE BEGIN
        WRITE_LONG ("%fx_off%" + 0x14 + ("%index%" * 0x108)) 3
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// DV change
COPY_EXISTING ~mddust.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x280 ~DUSTMEP~ #18
  END
  BUT_ONLY_IF_IT_CHANGES

// eliminates soundsets for mindflayers as no other ones have sounds
COPY_EXISTING ~melsum06.cre~ ~override~
              ~mindal01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0xc8  0xffffffff
    WRITE_LONG 0xcc  0xffffffff
    WRITE_LONG 0xec  0xffffffff
    WRITE_LONG 0xf0  0xffffffff
    WRITE_LONG 0x10c 0xffffffff
    WRITE_LONG 0x110 0xffffffff
    WRITE_LONG 0x1b8 0xffffffff
  END
  BUT_ONLY_IF_IT_CHANGES

//one mephit portal has inconsistent dexterity
COPY_EXISTING ~mephsp1.cre~ ~override~
  WRITE_BYTE 0x23c 20 // dex
  BUT_ONLY_IF_IT_CHANGES

// ice mephit should have ice shard memorized, not magma ball
COPY_EXISTING ~mepice01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" + ("%index%" * 0x0c)) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spin930" = 0) BEGIN // if magma ball
      WRITE_ASCII ("%known_off%" + ("%index%" * 0x0c)) ~spin936~ // replace with ice shard
    END
  END
  // rest of these reads are to fix obsice02, mepice02 below
  READ_ASCII 0x2c  "color" (6)        // entire coloring block
  READ_LONG  0x46  "ac"               // natural and effective AC
  READ_ASCII 0x59  "resistances" (11) // entire resistances block
  READ_BYTE  0x23c "dex"              // dexterity
  BUT_ONLY_IF_IT_CHANGES

// fixes other two ice mephits
COPY_EXISTING ~mepice02.cre~ ~override~
              ~obsice02.cre~ ~override~
  // writes in correct values from mepice01
  WRITE_EVALUATED_ASCII 0x2c  "%color%" #6        // entire coloring block
  WRITE_LONG            0x46  "%ac%"              // natural and effective AC
  WRITE_EVALUATED_ASCII 0x59  "%resistances%" #11 // entire resistances block
  WRITE_BYTE            0x23c "%dex%"             // dexterity
  SAY NAME1 #22553
  SAY NAME2 #22553
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2b8 "slot_offset"
  READ_LONG 0x2bC "item_offset"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" + ("%index%" * 0x0c)) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spin930" = 0) BEGIN // if magma ball
      WRITE_ASCII ("%known_off%" + ("%index%" * 0x0c)) ~spin936~ // replace with ice shard
    END
  END
  READ_SHORT  ("%slot_offset%" + 0x12) "item_index" // reads location of primary weapon
  WRITE_ASCII ("%item_offset%" +        (0x14 * "%item_index%")) ~mepice~ #8 // replaces it with ice mephit weapon
  WRITE_LONG  ("%item_offset%" + 0x08 + (0x14 * "%item_index%")) 0
  WRITE_LONG  ("%item_offset%" + 0x0c + (0x14 * "%item_index%")) 0
  WRITE_LONG  ("%item_offset%" + 0x10 + (0x14 * "%item_index%")) 0
  BUT_ONLY_IF_IT_CHANGES

// fixes minsc spells
COPY_EXISTING ~minsc8.cre~  ~override~
              ~minsc9.cre~  ~override~
              ~minsc10.cre~ ~override~
              ~minsc12.cre~ ~override~
  READ_BYTE 0x234 "level"
  ADD_KNOWN_SPELL ~sppr101~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr103~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr104~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr105~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr110~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr111~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr113~ #0 ~priest~
  PATCH_IF ("%level%" > 9) BEGIN
    ADD_KNOWN_SPELL ~sppr202~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr204~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr205~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr207~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr209~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr210~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr212~ #1 ~priest~
  END
  PATCH_IF ("%level%" > 11) BEGIN
    ADD_KNOWN_SPELL ~sppr302~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr303~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr305~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr306~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr309~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr310~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr311~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr312~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr315~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr319~ #2 ~priest~
  END
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG    ("%mem_info%" + 0x08              ) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 1
  PATCH_IF ("%level%" > 8) BEGIN
    SET "lev1" = ("%lev1%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr103~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr104~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 1)
  WRITE_SHORT ("%mem_info%" + 0x02) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c) "%lev1%"

  //level 2 fixes
  SET "lev2" = 0
  PATCH_IF ("%level%" > 9) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr202~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  PATCH_IF ("%level%" > 11) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr204~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  WRITE_SHORT ("%mem_info%" + 0x02 + (1 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (1 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (1 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (1 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 0
  PATCH_IF ("%level%" > 11) BEGIN
    SET "lev3" = ("%lev3%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr315~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  WRITE_SHORT ("%mem_info%" + 0x02 + (2 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (2 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (2 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (2 * 0x10)) "%lev3%"

  // wrapping up; correcting indexes for remaining spells
  SET "loops" = 0
  WHILE ("%loops%" < 13) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 2) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 2) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 2) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 2) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// nalia short one prof star at all levels
COPY_EXISTING ~nalia8.cre~  ~override~
              ~nalia10.cre~ ~override~
              ~nalia11.cre~ ~override~
              ~nalia13.cre~ ~override~
              ~nalia15.cre~ ~override~
              ~nalia18.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
      READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
      PATCH_IF (("%type%" = 233) AND ("%weap%" = 106)) BEGIN // dart
        WRITE_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) 107 // change to sling
      END
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 106    // prof - dart
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// more heinous spell slot fixes; nalia8 and nalia9 have one extra fifth
// level spell, nalia13 one extra 6th level spell and 0 arrows
COPY_EXISTING ~nalia8.cre~  ~override~
              ~nalia10.cre~ ~override~
              ~nalia13.cre~ ~override~
  READ_BYTE 0x234 "level"
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c0 "item_num"
  READ_LONG 0x2c4 "fx_off"

  // first let's get the arrows out of the way
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + (0x14 * "%item_num%")) "itemname"
    PATCH_IF ("arow01" STRING_COMPARE_CASE "%itemname%" = 0) BEGIN
      WRITE_SHORT ("%item_off%" + 0x0a + (0x14 * "%item_num%")) 20 // quantity
    END
  END

  READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 4
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi118~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi115~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi110~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi105~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 4)
  WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) "%lev1%"

  //level 2 fixes
  SET "lev2" = 3
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi215~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi214~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi212~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 3
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev3" = ("%lev3%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi312~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi308~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi306~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) "%lev3%"

  //level 4 fixes
  SET "lev4" = 2
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev4" = ("%lev4%" + 2)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi415~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 2)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi416~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 2)
  WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - "%lev4%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) "%lev4%"

  //level 5 fixes
  SET "lev5" = 1
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev5" = ("%lev5%" + 3)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi508~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi506~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi502~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 3)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi505~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 1)
  WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - "%lev5%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) "%lev5%"

  // wrapping up; correcting indexes for remaining wizard spells and innates
  SET "loops" = 0
  WHILE ("%loops%" < 4) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 11) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 11) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 11) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 11) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// Nalia's saves
COPY_EXISTING ~nalia13.cre~ ~override~
              ~nalia15.cre~ ~override~
              ~nalia18.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x54 11
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes name
COPY_EXISTING ~pirpir06.cre~ ~override~
  READ_LONG  0x08 "name"
  WRITE_LONG 0x0c "%name%"
  BUT_ONLY_IF_IT_CHANGES

// hostile planetars via wish would still cast spells to benefit the party
COPY_EXISTING ~planet01.cre~ ~override~ // unused?
              ~planwish.cre~ ~override~ // hostile planetar summoned via wish
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~planet~   #8 // override script
    WRITE_ASCII 0x268 ~wtasight~ #8 // default script
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes evil planetar's class and spell list
COPY_EXISTING ~planevil.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2a0  "known_off"
    READ_LONG  0x2a4  "known_num"
    READ_LONG  0x2b0  "mem_off"
    READ_LONG  0x2b4  "mem_num"
    WHILE ("%known_num%" > 0) BEGIN
      SET "known_num" = ("%known_num%" - 1)
      READ_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr307" = 0) BEGIN
        WRITE_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "sppr303"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr710" = 0) BEGIN
        WRITE_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "sppr715"
      END
    END
    WHILE ("%mem_num%" > 0) BEGIN
      SET "mem_num" = ("%mem_num%" - 1)
      READ_ASCII  ("%mem_off%" +        ("%mem_num%" * 0x0c)) "spell"
      WRITE_SHORT ("%mem_off%" + 0x08 + ("%mem_num%" * 0x0c)) 1
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr307" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%mem_num%" * 0x0c)) "sppr303"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr710" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%mem_num%" * 0x0c)) "sppr715"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes regen rate for good planetars, along with class/general field fixes
COPY_EXISTING ~plangood.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2c4 "fx_off"
    READ_LONG  0x2c8 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
      PATCH_IF ("%type%" = 98) BEGIN // regerneration
        WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 4 // hp per sec
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Tyrianna fix, part 2 (first is ar0415 extend)
COPY_EXISTING ~plgirl01.cre~ ~override~
  WRITE_ASCII 0x248 ~~ #8
  BUT_ONLY_IF_IT_CHANGES

// dradeel is an elf but uses a human avatar
COPY_EXISTING ~ppdra2.cre~   ~override~
              ~ppdradee.cre~ ~override~
              ~redrad01.cre~ ~override~
  WRITE_SHORT 0x28 25089 // male elf mage
  BUT_ONLY_IF_IT_CHANGES

// changes Asylum Irenicus to use minhp1 instead of jonhp1 (Baldurdash)
// race and alignment corrections in Oversight code blocks, above
COPY_EXISTING ~ppireni1.cre~ ~override~
              ~ppireni2.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "jonhp1" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "minhp1"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds a charge to Arbane on Suna Seni
COPY_EXISTING ~resuna.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h27" = 0) BEGIN
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%itm_num%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong DV for roger's sea troll (active); if killed instantly (rather than via fire/acid) roger won't know
COPY_EXISTING ~rogtro01.cre~ ~override~
  WRITE_ASCII 0x280 ~rogtro02~ #20 // death variable
  BUT_ONLY_IF_IT_CHANGES

// assigns amalas.bcs to Amalas as his override script
COPY_EXISTING ~ruffian.cre~ ~override~
  WRITE_ASCII 0x248 ~AMALAS~ #8

// fixes sahzomb flags
COPY_EXISTING ~sahzomb.cre~ ~override~
  WRITE_LONG 0x10 0
  BUT_ONLY_IF_IT_CHANGES

// fixes to Sarevok's saves
COPY_EXISTING ~sarevok.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x57 4
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sarpro01.cre~ ~override~ // typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~wtrunsgt~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sendro05.cre~ ~override~ //typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~cassa20b~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~SHOP03.CRE~  ~override~    // Maheer, the Blacksmith
  SAY NAME1 #23302
  SAY NAME2 #23303

COPY_EXISTING ~shthdr01.cre~ ~override~
  WRITE_ASCII 0x250 ~BRANNEL~ #8 // class script

COPY_EXISTING ~slmage2.cre~   ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi422" = 0) BEGIN
      DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
      SET "delta_known" = ("%delta_known%" - 1)
      SET "index" = ("%index%" - 1)
      SET "known_num" = ("%known_num%" - 1)
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi422" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi408"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sppain.cre~  ~override~
              ~vakola.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
      DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
      SET "delta_known" = ("%delta_known%" - 1)
      SET "index" = ("%index%" - 1)
      SET "known_num" = ("%known_num%" - 1)
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
        DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
        SET "delta_mem" = ("%delta_mem%" - 1)
        SET "index3" = ("%index3%" - 1)
        SET "meminfo_num" = ("%meminfo_num%" - 1)
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// adds many missing effects to Mordy swords (Baldurdash)
COPY_EXISTING ~sword01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  // insert the 17 new immunity effect and types; the rest of the parameters are covered in the loop
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 135  // polymorph
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 134  // petrify
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 128  // confusion
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 109  // hold
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 106  // break morale
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 80   // deafness
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 78   // disease
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 76   // feeblemind
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 74   // blindness
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 45   // stun
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 39   // sleep
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 24   // panic
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 5    // charm
  SET "new_immun" = 13
  WHILE ("%new_immun%" > 0) BEGIN
    SET "new_immun" = ("%new_immun%" - 1)
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%new_immun%" * 0x108)) 101 // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x0c + ("%new_immun%" * 0x108)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x1c + ("%new_immun%" * 0x108)) 1   // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24 + ("%new_immun%" * 0x108)) 100 // probability
    WRITE_LONG  ("%fx_off%" + 0xc4 + ("%new_immun%" * 0x108)) 1   // secondary type
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin975~ // psionic domination
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin974~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin912~ // detonate
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin911~ // ballsitic attack
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin909~ // ego whip
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin910~ // domination
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin959~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin834~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin775~ // unk
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin774~ // maze
  SET "new_spimmun" = 10
  WHILE ("%new_spimmun%" > 0) BEGIN
    SET "new_spimmun" = ("%new_spimmun%" - 1)
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%new_spimmun%" * 0x108)) 206 // protection from spell
    WRITE_LONG  ("%fx_off%" + 0x0c + ("%new_spimmun%" * 0x108)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x10 + ("%new_spimmun%" * 0x108)) 0   // power
    WRITE_LONG  ("%fx_off%" + 0x1c + ("%new_spimmun%" * 0x108)) 1   // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24 + ("%new_spimmun%" * 0x108)) 100 // probability
    WRITE_LONG  ("%fx_off%" + 0x3c + ("%new_spimmun%" * 0x108)) (0 - 2)  // save bonus
    WRITE_LONG  ("%fx_off%" + 0x54 + ("%new_spimmun%" * 0x108)) 3   // dispel/bypass
    WRITE_ASCII ("%fx_off%" + 0x8c + ("%new_spimmun%" * 0x108)) ~misc9y~ // parent spell
    WRITE_LONG  ("%fx_off%" + 0xc0 + ("%new_spimmun%" * 0x108)) 10  // primary type
    WRITE_LONG  ("%fx_off%" + 0xc4 + ("%new_spimmun%" * 0x108)) 1   // secondary type
  END
  // new effects to suppress confusion string and graphic
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x0c) 1     // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0     // power
    WRITE_LONG  ("%fx_off%" + 0x14) 14782 // strref for "confused"
    WRITE_LONG  ("%fx_off%" + 0x1c) 1     // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100   // probability
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 296        // disable animation
    WRITE_LONG  ("%fx_off%" + 0x0c) 1          // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0          // power
    WRITE_LONG  ("%fx_off%" + 0x1c) 1          // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x28) ~spconfus~ // vvc file
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 296        // disable animation
    WRITE_LONG  ("%fx_off%" + 0x0c) 1          // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0          // power
    WRITE_LONG  ("%fx_off%" + 0x1c) 1          // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x28) ~spmindat~ // vvc file
  WRITE_LONG 0x2c8 ("%fx_num%" + 26)
  SET "offset_delta" = (26 * 0x108)
  PATCH_IF ("%fx_off%" < "%known_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%mem_info%") BEGIN
    WRITE_LONG 0x2a8 ("%mem_info%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%mem_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mem_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%slot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%item_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  BUT_ONLY_IF_IT_CHANGES

// ring of the ram should have a charge
COPY_EXISTING ~tolger.cre~  ~override~
              ~tolger2.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring33" = 0) BEGIN
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// one-off change for Tor'gal to prevent repeating dialogue after regenerating
COPY_EXISTING ~torgal.cre~ ~override/torgal3.cre~
  WRITE_ASCII 0x248 ~~ #8 // no approach and speak script
  WRITE_BYTE  0x270 255   // enemy
  WRITE_ASCII 0x2cc ~~ #8 // no dialogue file

// makes Logan's cre files consistent
COPY_EXISTING ~celogan.cre~ ~override/trcut07.cre~
  WRITE_ASCII 0x248 ~~ #40
  WRITE_ASCII 0x280 ~trcut07~ #18
  WRITE_ASCII 0x2cc ~trcut07~ #8

// trollens should require fire/acid to be killed
COPY_EXISTING ~trollens.cre~ ~override~
  WRITE_ASCII 0x258 ~troll01~ #8 // transform to fire/acid dead form at low HP
  BUT_ONLY_IF_IT_CHANGES

// restoring Adalon's sound set
COPY_EXISTING ~UDSILVER.CRE~ ~OVERRIDE~
  SAY 0xd0 @103
  SAY 0xd4 @104
  SAY 0x0110 @109
  SAY 0x0114 @110
  SAY 0x0118 @111
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~VALRAN01.CRE~ ~override~  // Derrick, the ranger
  SAY NAME1 #2190
  SAY NAME2 #2190

// valyg11 should be level 10 instead of 11
COPY_EXISTING ~valyg11.cre~ ~override~
  WRITE_SHORT 0x24  78 // current hp
  WRITE_SHORT 0x26  78 // max hp
  WRITE_BYTE  0x45  78 // hide in shadows
  WRITE_BYTE  0x52  11 // THAC0
  WRITE_BYTE  0x54   8 // save v death
  WRITE_BYTE  0x55  10 // save v wand
  WRITE_BYTE  0x56   9 // save v polymorph
  WRITE_BYTE  0x57   9 // save v breath
  WRITE_BYTE  0x58  11 // save v spell
  WRITE_BYTE  0x68  78 // move silently
  WRITE_BYTE  0x234 10 // level
  BUT_ONLY_IF_IT_CHANGES

// Valygar spell fixes
COPY_EXISTING ~valyg8.cre~  ~override~
              ~valyg9.cre~  ~override~
              ~valyg11.cre~ ~override~
              ~valyg12.cre~ ~override~
              ~valyg14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level"
    ADD_KNOWN_SPELL ~sppr101~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr103~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr104~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr105~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr110~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr111~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr113~ #0 ~priest~
    PATCH_IF ("%level%" > 9) BEGIN
      ADD_KNOWN_SPELL ~sppr202~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr204~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr205~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr207~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr209~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr210~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr212~ #1 ~priest~
    END
    PATCH_IF ("%level%" > 11) BEGIN
      ADD_KNOWN_SPELL ~sppr302~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr303~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr305~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr306~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr309~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr310~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr311~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr312~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr315~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr319~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra301~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra302~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra303~ #2 ~priest~
    END
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a8 "mem_info"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG    ("%mem_info%" + 0x08              ) "idx_start"
    READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
    DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
    SET "delta" = 0

    // level 1
    SET "lev1" = 1
    PATCH_IF ("%level%" > 8) BEGIN
      SET "lev1" = ("%lev1%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr113~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr103~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x04) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x0c) "%lev1%"

    //level 2 fixes
    SET "lev2" = 0
    PATCH_IF ("%level%" > 9) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr204~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr202~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (1 * 0x10)) "%lev2%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (1 * 0x10)) "%lev2%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (1 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (1 * 0x10)) "%lev2%"

    //level 3 fixes
    SET "lev3" = 0
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr315~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (2 * 0x10)) "%lev3%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (2 * 0x10)) "%lev3%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (2 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (2 * 0x10)) "%lev3%"
  
    // wrapping up; correcting indexes for remaining spells
    SET "loops" = 0
    WHILE ("%loops%" < 13) BEGIN
      SET "loops" = ("%loops%" + 1)
      WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 2) * 0x10)) 0
      WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 2) * 0x10)) 0
      WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 2) * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 2) * 0x10)) 0
    END
    WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")

    // final wrapup; correct # of memorized spells and offsets
    WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
    SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// vic6 has incorrect class script
COPY_EXISTING ~viconi6.cre~ ~override~
  WRITE_ASCII 0x250 ~initrg10~
  BUT_ONLY_IF_IT_CHANGES

// Viconia proficiency fix, remove holy smite, fire seeds, add flame blade
COPY_EXISTING ~viconi6.cre~  ~override~
              ~viconi8.cre~  ~override~
              ~viconi9.cre~  ~override~
              ~viconi11.cre~ ~override~
              ~viconi13.cre~ ~override~
              ~viconi16.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level"
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "fx_delta" = 1
    FOR (index = known_num ; index > 0 ; index = index - 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + (("%index%" - 1) * 0x0C)) "spell"
      PATCH_IF (("SPPR313" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("SPPR606" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + (("%index%" - 1) * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    FOR (index = mem_num ; index > 0 ; index = index - 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) "spell"
      PATCH_IF ("SPPR313" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) ~sppr314~ #8
      END ELSE
      PATCH_IF ("SPPR606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) ~sppr601~ #8
      END
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 112    // prof - sword & shield
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    PATCH_IF ("%level%" > 12) BEGIN
      SET "fx_delta" = 2
      INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
        WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
        WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
        WRITE_LONG  ("%fx_off%" + 0x18) 100    // prof - flail
        WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
        WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
        WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    END
    PATCH_IF ("%known_off%" >= "%fx_off%") BEGIN
      SET "known_off" = ("%known_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%meminfo_off%" >= "%fx_off%") BEGIN
      SET "meminfo_off" = ("%meminfo_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%mem_off%" >= "%fx_off%") BEGIN
      SET "mem_off" = ("%mem_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%slot_off%" >= "%fx_off%") BEGIN
      SET "slot_off" = ("%slot_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%item_off%" >= "%fx_off%") BEGIN
      SET "item_off" = ("%item_off%" + ("%fx_delta%" * 0x108))
    END
    WRITE_LONG 0x2a0 "%known_off%"
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    WRITE_LONG 0x2c8 ("%fx_num%" + "%fx_delta%")
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes to Parisa's soundset
COPY_EXISTING ~VVPARIS.CRE~ ~OVERRIDE~
  SAY INITIAL_MEETING #61743
  SAY MORALE          #61749
  SAY BATTLE_CRY1     #61745
  SAY BATTLE_CRY2     #61746
  SAY DAMAGE          #61747
  SAY DYING           #61748
  SAY SELECT_COMMON1  #61741
  SAY SELECT_COMMON2  #61742
  SAY SELECT_COMMON3  #61743
  SAY SELECT_COMMON4  #61744
  SAY PICKED_POCKET   #61744

// wish01 and wish02 should be the same genie
COPY_EXISTING ~wish02.cre~ ~override/wish01.cre~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN
    WRITE_ASCII 0x280 ~wish01~ #18 // death var
    WRITE_ASCII 0x2cc ~wish~    #8 // dialogue
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~yarmy01.cre~ ~override~ //typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN
    WRITE_ASCII 0x258 ~cfigh20b~ #8
  END
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi7.cre~  ~override~
              ~yoshi8.cre~  ~override~
              ~yoshi10.cre~ ~override~
  WRITE_BYTE 0x45 35 // hide in shadows
  WRITE_BYTE 0x68 40 // move silently
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi11.cre~ ~override~
  WRITE_BYTE 0x45 40 // hide in shadows
  WRITE_BYTE 0x68 45 // move silently
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi12.cre~ ~override~
  WRITE_BYTE 0x45 45 // hide in shadows
  WRITE_BYTE 0x65 15 // set traps
  WRITE_BYTE 0x68 50 // move silently
  BUT_ONLY_IF_IT_CHANGES

// overcharged items on creatures
COPY_EXISTING ~aerbod01.cre~ ~override~ // slng01 (num 2) has assigned 20 to max 1 in header 1
              ~aerie6.cre~   ~override~ // slng01 (num 2) has assigned 20 to max 1 in header 1
              ~amarch01.cre~ ~override~ // helm33 (num 0) has assigned 30 to max 1 in header 1
              ~amarch02.cre~ ~override~ // helm33 (num 1) has assigned 30 to max 1 in header 1
              ~ar18dwaf.cre~ ~override~ // ax1h04 (num 0) has assigned 1 to max 0 in header 2
              ~aran.cre~     ~override~ // helmnoan (num 0) has assigned 2 to max 1 in header 1
              ~aran02.cre~   ~override~ // misc6w (num 7) has assigned 3 to max 1 in header 1
              ~beast.cre~    ~override~ // arow01 (num 4) has assigned 20 to max 0 in header 2
              ~c6catti.cre~  ~override~ // ring05 (num 2) has assigned 10 to max 1 in header 1
              ~c6kngt1.cre~  ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~c6regis.cre~  ~override~ // ring05 (num 4) has assigned 6 to max 1 in header 1
              ~chang01.cre~  ~override~ // ring05 (num 6) has assigned 10 to max 1 in header 1
              ~chang02.cre~  ~override~ // ring05 (num 6) has assigned 10 to max 1 in header 1
              ~chgood08.cre~ ~override~ // ring05 (num 3) has assigned 10 to max 1 in header 1
              ~deckass1.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~deshar.cre~   ~override~ // ring05 (num 3) has assigned 5 to max 1 in header 1
              ~docsol01.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~docsol02.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~duearc01.cre~ ~override~ // ax1h01 (num 1) has assigned 20 to max 1 in header 1
              ~e33.cre~      ~override~ // sw1h10 (num 5) has assigned 10 to max 1 in header 1
              ~fshorde2.cre~ ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~fshorde6.cre~ ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~gordeck5.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck6.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck7.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck8.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck9.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordecka.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gorkuo05.cre~ ~override~ // xbow01 (num 1) has assigned 20 to max 1 in header 1
              ~gororc02.cre~ ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~grvlch01.cre~ ~override~ // rods05 (num 6) has assigned 5 to max 1 in header 1
              ~hgskl02.cre~  ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~hobarc02.cre~ ~override~ // bow03 (num 4) has assigned 20 to max 1 in header 1
              ~icgob01.cre~  ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~icgob02.cre~  ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~jaga4.cre~    ~override~ // sw1h08 (num 4) has assigned 2 to max 1 in header 1
              ~keldor8.cre~  ~override~ // helm01 (num 1) has assigned 20 to max 1 in header 1
              ~kobarc01.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~kobcap01.cre~ ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~kuowhi01.cre~ ~override~ // xbow01 (num 1) has assigned 20 to max 1 in header 1
              ~latkni01.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~latkni02.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~maevar.cre~   ~override~ // helmnoan (num 10) has assigned 2 to max 1 in header 1
              ~nalia13.cre~  ~override~ // bow05 (num 2) has assigned 20 to max 1 in header 1
              ~orc02.cre~    ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~pirsea02.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~plshhg01.cre~ ~override~ // bow03 (num 4) has assigned 20 to max 1 in header 1
              ~pparan2.cre~  ~override~ // misc6w (num 7) has assigned 3 to max 1 in header 1
              ~ppguard1.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~saerk.cre~    ~override~ // ring34 (num 8) has assigned 4 to max 1 in header 1
              ~sahuag01.cre~ ~override~ // xbow01 (num 2) has assigned 20 to max 1 in header 1
              ~sargrd05.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sargrd09.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis01.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis02.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis03.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis04.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~senani05.cre~ ~override~ // leat02 (num 0) has assigned 5 to max 1 in header 1
              ~sendai.cre~   ~override~ // wand19 (num 5) has assigned 1 to max 0 in header 2
              ~sendro05.cre~ ~override~ // leat02 (num 0) has assigned 5 to max 1 in header 1
              ~sevpat05.cre~ ~override~ // ring05 (num 3) has assigned 4 to max 1 in header 1
              ~shabod01.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~shadeld.cre~  ~override~ // clck25 (num 0) has assigned 1 to max 0 in header 2
              ~swsfoll4.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~swsfoll5.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~tanthf01.cre~ ~override~ // ring05 (num 6) has assigned 4 to max 1 in header 1
              ~waukni01.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~yaga05.cre~   ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
  READ_LONG 0x2bc "itm_off" ELSE 0
  READ_LONG 0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow01" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "ax1h04" = 0)) BEGIN // throwing axes
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0 // no secondary charge
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ax1h01" = 0) OR     // battle axe
              ("%item%" STRING_COMPARE_CASE "bow01" = 0) OR      // composite long bow
              ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR      // long bow
              ("%item%" STRING_COMPARE_CASE "bow05" = 0) OR      // short bow
              ("%item%" STRING_COMPARE_CASE "chan01" = 0) OR     // chain mail
              ("%item%" STRING_COMPARE_CASE "helm01" = 0) OR     // generic helm
              ("%item%" STRING_COMPARE_CASE "helm33" = 0) OR     // gold-horned helm
              ("%item%" STRING_COMPARE_CASE "helmnoan" = 0) OR   // invisible helm
              ("%item%" STRING_COMPARE_CASE "leat02" = 0) OR     // leaher armor +1
              ("%item%" STRING_COMPARE_CASE "misc6w" = 0) OR     // wooden stake
              ("%item%" STRING_COMPARE_CASE "rods05" = 0) OR     // rod of terror
              ("%item%" STRING_COMPARE_CASE "slng01" = 0) OR     // sling
              ("%item%" STRING_COMPARE_CASE "sw1h08" = 0) OR     // short sword +1
              ("%item%" STRING_COMPARE_CASE "sw1h10" = 0) OR     // short sword of backstabbing
              ("%item%" STRING_COMPARE_CASE "xbow01" = 0)) BEGIN // heavy crossbow
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 0 // no charges, not stackable
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0
      WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 0
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "clck25" = 0) OR     // cloak of the stars
              ("%item%" STRING_COMPARE_CASE "wand19" = 0)) BEGIN // wand of cursing
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0 // no secondary charges
      WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 0 // no tertiary charges
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring05" = 0) OR     // ring of invisibility
              ("%item%" STRING_COMPARE_CASE "ring34" = 0)) BEGIN // ring of spell turning
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1 // once per day
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// checking creatures for undercharged items
COPY_EXISTING ~aerie10.cre~  ~override~ // bull01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~aerie11.cre~  ~override~ // bull01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~aerie9.cre~   ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~amarch01.cre~ ~override~ // bow20 (num 3) has assigned 0 to max 1 in header 2
              ~amcarras.cre~ ~override~ // boot12 (num 7) has assigned 0 to stack 1 charges 2 in header 1
              ~ammerc08.cre~ ~override~ // arow11 (num 5) has assigned 0 to stack 40 charges 1 in header 1
              ~bdturm02.cre~ ~override~ // bolt03 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~bhcrypt.cre~  ~override~ // sw1h36 (num 4) has assigned 0 to max 3 in header 2
              ~bonebld.cre~  ~override~ // ipsion (num 0) has assigned 0 to stack 1 charges 50 in header 1
              ~chalcy02.cre~ ~override~ // ring34 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc01.cre~ ~override~ // ring29 (num 4) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc02.cre~ ~override~ // ring29 (num 4) has assigned 0 to max 1 in header 2
              ~chalpc03.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc04.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc05.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc06.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc07.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc08.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc09.cre~ ~override~ // amul22 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc10.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc11.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc12.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc13.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc14.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc15.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc16.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chevil09.cre~ ~override~ // ring34 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chsam01.cre~  ~override~ // staf12 (num 4) has assigned 0 to max 10 in header 2
              ~chsam02.cre~  ~override~ // staf12 (num 4) has assigned 0 to max 10 in header 3
              ~chtaz01.cre~  ~override~ // clck20 (num 3) has assigned 0 to stack 1 charges 50 in header 1
              ~e33.cre~      ~override~ // amul01 (num 6) has assigned 0 to stack 1 charges 25 in header 1
              ~elemimix.cre~ ~override~ // halb10 (num 2) has assigned 0 to max 2 in header 2
              ~firkra02.cre~ ~override~ // sw2h10 (num 4) has assigned 1 to max 3 in header 2
              ~firmon01.cre~ ~override~ // sw1h32 (num 3) has assigned 0 to max 1 in header 2
              ~flyfgt03.cre~ ~override~ // arow01 (num 0) has assigned 0 to stack 40 charges 1 in header 1
              ~fsdragon.cre~ ~override~ // sw1h70 (num 4) has assigned 0 to max 1 in header 2
              ~gorlic01.cre~ ~override~ // slng08 (num 3) has assigned 0 to max 1 in header 2
              ~gorsta09.cre~ ~override~ // arow01 (num 6) has assigned 0 to stack 40 charges 1 in header 1
              ~gorwom02.cre~ ~override~ // helm16 (num 6) has assigned 0 to stack 1 charges 1 in header 1
              ~habib.cre~    ~override~ // sw1h57 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~hgnya01.cre~  ~override~ // ring03 (num 5) has assigned 0 to stack 1 charges 100 in header 1
              ~hldemi.cre~   ~override~ // ring39 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~hlkang.cre~   ~override~ // ring39 (num 3) has assigned 0 to max 3 in header 2
              ~jaylos.cre~   ~override~ // dagg05 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~kaysmg01.cre~ ~override~ // arow01 (num 4) has assigned 0 to stack 40 charges 1 in header 1
              ~kproen03.cre~ ~override~ // wand07 (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~kuoarc20.cre~ ~override~ // kuobolt3 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~latkni02.cre~ ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
//              ~nalia13.cre~  ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~pbhunt03.cre~ ~override~ // clck20 (num 2) has assigned 0 to stack 1 charges 50 in header 1
              ~pcapt03.cre~  ~override~ // bolt03 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~pcapt04.cre~  ~override~ // wand05 (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~pirexe01.cre~ ~override~ // bolt01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~pirmur07.cre~ ~override~ // dart02 (num 0) has assigned 0 to stack 40 charges 1 in header 1
              ~ppcowled.cre~ ~override~ // misc3a (num 1) has assigned 0 to stack 1 charges 1 in header 1
//              ~resuna.cre~   ~override~ // sw1h27 (num 3) has assigned 0 to max 1 in header 2
              ~rumar01.cre~  ~override~ // wand07 (num 4) has assigned 0 to stack 1 charges 50 in header 1
              ~sarkis04.cre~ ~override~ // figure01 (num 4) has assigned 0 to stack 1 charges 1 in header 1
              ~sarvie01.cre~ ~override~ // ring20 (num 4) has assigned 0 to stack 1 charges 50 in header 1
              ~sendai3.cre~  ~override~ // arow05 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~sewdue01.cre~ ~override~ // fragsap (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~sewyag01.cre~ ~override~ // fragsap (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~shth01.cre~   ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~shth011.cre~  ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~shth03.cre~   ~override~ // arow05 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~sword01.cre~  ~override~ // ipsion (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~swshaman.cre~ ~override~ // misc5t (num 1) has assigned 0 to max 1 in header 2
              ~teltief3.cre~ ~override~ // wand18 (num 4) has assigned 0 to max 5 in header 2
//              ~tolger.cre~   ~override~ // ring33 (num 2) has assigned 0 to stack 1 charges 1 in header 1
//              ~tolger2.cre~  ~override~ // ring33 (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~trrak01.cre~  ~override~ // amul22 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~uhman02.cre~  ~override~ // bolt01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~uhogre04.cre~ ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~vakg02.cre~   ~override~ // bolt01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~viekang.cre~  ~override~ // ring20 (num 6) has assigned 0 to stack 1 charges 50 in header 1
              ~vulfgt02.cre~ ~override~ // dart01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~xappren1.cre~ ~override~ // wand03 (num 0) has assigned 0 to stack 1 charges 100 in header 1
  READ_LONG 0x2bc "itm_off" ELSE 0
  READ_LONG 0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "amul01" = 0) BEGIN // necklace of missiles
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 25
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "amul22" = 0) OR     // periapt of proof v poison
              ("%item%" STRING_COMPARE_CASE "figure01" = 0) OR   // shakti figurine
              ("%item%" STRING_COMPARE_CASE "fragsap" = 0) OR    // fragmentation skull
              ("%item%" STRING_COMPARE_CASE "misc3a" = 0) OR     // book of infinite spells
              ("%item%" STRING_COMPARE_CASE "ring33" = 0) OR     // ring of the ram
              ("%item%" STRING_COMPARE_CASE "ring34" = 0)) BEGIN // ring of spell turning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1 // once per day
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow01" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "arow05" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "bolt01" = 0) OR     // bolts
              ("%item%" STRING_COMPARE_CASE "bolt03" = 0) OR     // bolts of lightning
              ("%item%" STRING_COMPARE_CASE "dart01" = 0) OR     // darts
              ("%item%" STRING_COMPARE_CASE "dart02" = 0) OR     // darts +1
              ("%item%" STRING_COMPARE_CASE "kuobolt3" = 0) OR   // kuo-toa bolts +3
              ("%item%" STRING_COMPARE_CASE "ring03" = 0)) BEGIN // ring of animal friendship
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "arow11" = 0) BEGIN // arrows +2
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 30 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "boot12" = 0) BEGIN // gargoyle boots
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 2 // two secondary charges
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow20" = 0) OR
              ("%item%" STRING_COMPARE_CASE "misc5t" = 0) OR // shaman's staff
              ("%item%" STRING_COMPARE_CASE "slng08" = 0) OR // erinne sling
              ("%item%" STRING_COMPARE_CASE "sw1h27" = 0) OR // arbane
              ("%item%" STRING_COMPARE_CASE "sw1h32" = 0) OR // dragonslayer
              ("%item%" STRING_COMPARE_CASE "sw1h70" = 0)) BEGIN // hindo's doooooom
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1 // one secondary charge
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bull01" = 0) BEGIN // bullets
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // typical total for stacks
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "chalcy3" = 0) OR    // greenstone amulet
              ("%item%" STRING_COMPARE_CASE "clck20" = 0) OR     // cloak of the shield
              ("%item%" STRING_COMPARE_CASE "ipsion" = 0) OR     // greenstone amulet
              ("%item%" STRING_COMPARE_CASE "ring20" = 0)) BEGIN  // ring of energy
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 50 // max charges; none of the affected items can be dropped
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "dagg05" = 0) OR // throwing daggers
              ("%item%" STRING_COMPARE_CASE "sw1h57" = 0)) BEGIN // habib's throwing daggers
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "halb10" = 0) BEGIN // ravager +4
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 2 // two secondary charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "helm16" = 0) BEGIN // helm of brilliance
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring29" = 0) BEGIN // ring of earth control
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring39" = 0) BEGIN // ring of gaxx
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staf11" = 0) BEGIN // staff of the magi
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge3"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staf12" = 0) BEGIN // staff of power
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge3"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 10
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h36" = 0) BEGIN // namarra
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw2h10" = 0) BEGIN // carsomyr
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand03" = 0) BEGIN // wand of magic missiles
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand05" = 0) BEGIN // wand of fire
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 10
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand07" = 0) BEGIN // wand of lightning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 8 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand18" = 0) BEGIN // wand of spell striking
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF (("%charge2%" > 5) OR ("%charge2%" = 0)) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 5 // max 5 secondary charges
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// items expire due to timers
COPY_EXISTING "abydem01.cre" "override" // ringdemn
              "bdturm02.cre" "override" // bolt03
              "csiren.cre"   "override" // STAF01, RNDTRE04
              "deaddem2.cre" "override" // ringdemn
              "demosum2.cre" "override" // ringdemn, balor, immune3
              "demosum3.cre" "override" // ringdemn, immune2
              "dglab01.cre"  "override" // ringdemn, immune2
              "dquas01.cre"  "override" // ringdemn
              "duegau01.cre" "override" // BULL01
              "duegau02.cre" "override" // AX1H01, BULL01
              "duemag01.cre" "override" // STAF01, SLNG01, POTN08, BULL01
              "duemag02.cre" "override" // STAF01, SLNG01, POTN08, BULL01
              "duergar1.cre" "override" // BULL01
              "duergar3.cre" "override" // AX1H01, BULL01
              "gorbat1.cre"  "override" // RINGdemn, immune3, reghp2r
              "gorchr.cre"   "override" // ringdemn
              "gortan1.cre"  "override" // ringdemn, balor, immune3
              "gortan2.cre"  "override" // ringdemn
              "gortan3.cre"  "override" // ringdemn, dwplat01, dwsw1h01
              "gortan4.cre"  "override" // ringdemn, immune2
              "gortan5.cre"  "override" // ringdemn
              "lavok01.cre"  "override" // STAF01, RNDTRE04
              "lavok02.cre"  "override" // STAF01, RNDTRE04
              "melsum01.cre" "override" // ringdemn, immune2
              "melsum04.cre" "override" // ringdemn, balor, immune3
              "obsdem01.cre" "override" // S1-10, ringdemn
              "pmaster.cre"  "override" // S1-10, ringdemn
              "ppdemon.cre"  "override" // S1-10, ringdemn
              "shth01.cre"   "override" // BULL01
              "shth011.cre"  "override" // BULL01
              "shth03.cre"   "override" // AROW05
              "sumtan01.cre" "override" // ringdemn
              "sumtan02.cre" "override" // ringdemn
              "tanari01.cre" "override" // S1-10, ringdemn
              "teltan1.cre"  "override" // ringdemn
              "teltan2.cre"  "override" // ringdemn
              "teltief3.cre" "override" // wand18
              "tolger.cre"   "override" // STAF01, RNDTRE04
              "tolger2.cre"  "override" // STAF01, RNDTRE04
              "uddwarf.cre"  "override" // BULL01
              "uhman02.cre"  "override" // BOLT01
              "uhogre04.cre" "override" // AROW01
              "vakg02.cre"   "override" // XBOW01
  PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN
    READ_LONG   0x2bc "io"
    READ_LONG   0x2c0 "ic"
    FOR ("i" = 0x00; "i" < (0x14 * "ic"); "i" += 0x14) BEGIN
      WRITE_SHORT  ("io" + "i" + 0x08) 0x00
    END
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// item file fixes                                  \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// big block of unusability stuff                   \\\\\
/////                                                  \\\\\

// BMU, scroll supposed to be completely restriction-free
COPY_EXISTING ~scrladj.itm~ ~override~
              ~secret01.itm~ ~override~
              ~secret02.itm~ ~override~
              ~secret03.itm~ ~override~
              ~secret04.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x1e 0
    WRITE_BYTE 0x29 0
    WRITE_BYTE 0x2b 0
    WRITE_BYTE 0x2d 0
    WRITE_BYTE 0x2f 0
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~misc5x.itm~  ~override~ // harper pin
              ~misca6.itm~  ~override~ // patrol leader helmet
              ~npbow.itm~   ~override~ // bow of arvoreen
              ~npsw01.itm~  ~override~ // sword of arvoreen
              ~ring35.itm~  ~override~ // ring of lock picking
              ~wa2ring.itm~ ~override~ // mercykiller ring
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b01000000) // adds bard flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac06.itm~ ~override~ // Gauntlets of Ogre Power
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BAND 0b10111111) // removes bard flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00100000) // adds lc-axis neutral flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00010000) // adds lawful flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00001000) // adds ge-axis neutral flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00000010) // adds evil flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~  ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~  ~override~ // hallowed redeemer
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00000001) // adds chaotic flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~dagg18.itm~ ~override~ // shadow thief dagger
              ~misc9q.itm~ ~override~ // scimitar
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b10000000) // adds f/m/c flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc9q.itm~ ~override~ // scimitar
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b01000000) // adds f/c flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00100000) // adds f/m flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc4q.itm~  ~override~ // the ogre's sword
              ~rodmace.itm~ ~override~ // mace from rod o' lordly might
              ~rods01.itm~  ~override~ // rod of absorption
              ~rods04.itm~  ~override~ // rod of smiting
              ~sw1h46.itm~  ~override~ // wakizashi
              ~sw1h47.itm~  ~override~ // wakizashi +1
              ~sw1h66.itm~  ~override~ // yamato +4
              ~sw1h99.itm~  ~override~ // sword of chaos
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x1f "use"
    WRITE_BYTE 0x1f ("%use%" BOR 0b00010000) // adds f/d flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00001000) // adds f flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc9q.itm~ ~override~ // scimitar
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000100) // adds c/r flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x1f "use"
    WRITE_BYTE 0x1f ("%use%" BAND 0b11111101) // removes c/t flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc9q.itm~ ~override~ // scimitar
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000010) // adds c/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~ring35.itm~  ~override~ // ring of lock picking
              ~wa2ring.itm~ ~override~ // mercykiller ring
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000001) // adds c/m flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b10000000) // adds elf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b10111111) // removes thief flag
  BUT_ONLY_IF_IT_CHANGES


COPY_EXISTING ~scrl8e.itm~ ~override~ // protection from the elements
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b01000000) // adds thief flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
              ~staf14.itm~ ~override~ // staff of woodlands
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00100000) // adds ranger flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~ ~override~ // Amulet of power
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b11011111) // removes ranger flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc3m.itm~ ~override~ // Harp of Discord
              ~misc3o.itm~ ~override~ // Methild's Harp
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00010000) // adds paladin flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~ ~override~ // Amulet of power
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b11101111) // removes paladin flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misca6.itm~ ~override~ // patrol leader helmet
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00001000) // adds m/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~chan20.itm~ ~override~ // white dragon scale
              ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x20 "use"
    WRITE_BYTE 0x20 ("%use%" BAND 0b11110111) // removes m/t flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misca6.itm~ ~override~ // patrol leader helmet
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000100) // adds mage flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~rods04.itm~ ~override~ // rod of smiting
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000010) // adds f/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000001) // adds f/m/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~hlolth.itm~  ~override~ // handmaiden's mace
              ~misc5x.itm~  ~override~ // harper pin
              ~npbow.itm~   ~override~ // bow of arvoreen
              ~npplat.itm~  ~override~ // Firecam Full-Plate Armor
              ~npsw01.itm~  ~override~ // sword of arvoreen
              ~npsw02.itm~  ~override~ // yoshimo's katana
              ~npsw03.itm~  ~override~ // hallowed redeemer
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~npsw05.itm~  ~override~ // chaos
              ~npsw06.itm~  ~override~ // entropy
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b10000000) // adds half-orc flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sw1h46.itm~ ~override~ // wakizashi
              ~sw1h47.itm~ ~override~ // wakizashi +1
              ~sw1h66.itm~ ~override~ // yamato +4
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BOR 0b01000000) // adds druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~ ~override~ // Gauntlets of crushing
              ~dagg16.itm~ ~override~ // poisoned throwing daggers
              ~dagg18.itm~ ~override~ // shadow thief dagger
              ~dagg19.itm~ ~override~ // dagger of <CHARNAME>
              ~plat20.itm~ ~override~ // blue dragon plate
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BAND 0b10111111) // removes druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul16.itm~   ~override~ // metaspell influence amulet
              ~amul21.itm~   ~override~ // Amulet of power
              ~brac17.itm~   ~override~ // gloves of pickpocketing
              ~brac21.itm~   ~override~ // guantlets of ex specialization
              ~clck29.itm~   ~override~ // robe of apprenti
              ~dwshld01.itm~ ~override~ // drow shield +3
              ~dwsw1h01.itm~ ~override~ // drow scimitar +3
              ~misc5t.itm~   ~override~ // shaman's staff
              ~misc9o.itm~   ~override~ // staff
              ~misca6.itm~   ~override~ // patrol leader helmet
              ~npplat.itm~   ~override~ // Firecam Full-Plate Armor
              ~potn36.itm~   ~override~ // potion of master thievery
              ~ring22.itm~   ~override~ // ring o' holiness
              ~ring35.itm~   ~override~ // ring of lock picking
              ~ring40.itm~   ~override~ // ring of acuity
              ~rods01.itm~   ~override~ // rod of absorption
              ~rods04.itm~   ~override~ // rod of smiting
              ~rods05.itm~   ~override~ // rod of terror
              ~rods06.itm~   ~override~ // rod of reversal
              ~npsw03.itm~   ~override~ // hallowed redeemer
              ~scrl3g.itm~   ~override~ // vocalize
//              ~scrl56.itm~   ~override~ // cure serious wounds (Monks should be able to use Priest-only scrolls according to Bioware)
//              ~scrl58.itm~   ~override~ // free action
//              ~scrl59.itm~   ~override~ // neutralize poison
//              ~scrl5a.itm~   ~override~ // mental domination
//              ~scrl5b.itm~   ~override~ // defensive harmony
//              ~scrl5c.itm~   ~override~ // protection from lightning
//              ~scrl5d.itm~   ~override~ // protection from evil 10'
//              ~scrl5e.itm~   ~override~ // champion's strength
//              ~scrl5f.itm~   ~override~ // chaotic commands
                ~scrl5g.itm~   ~override~ // remove curse (wizard version)
//              ~scrl61.itm~   ~override~ // cure critical wounds
//              ~scrl62.itm~   ~override~ // flame strike
//              ~scrl63.itm~   ~override~ // raise dead
              ~scrl8b.itm~   ~override~ // summon nishruu
              ~scrl8c.itm~   ~override~ // stone to flesh
//              ~wa2amu.itm~   ~override~ // sensate amulet (Monks should be able to use Priest-only items according to Bioware)
              ~wa2ring.itm~  ~override~ // mercykiller ring
              ~wand02.itm~   ~override~ // wand of fear
              ~wand04.itm~   ~override~ // wand of paralyzation
              ~wand05.itm~   ~override~ // wand of fire
              ~wand06.itm~   ~override~ // wand of frost
              ~wand07.itm~   ~override~ // wand of lightning
              ~wand09.itm~   ~override~ // wand of polymorphing
              ~wand10.itm~   ~override~ // wand of monster summoning
//              ~wand11.itm~   ~override~ // wand of the heavens (Monks should be able to use Priest-only items according to Bioware)
              ~wand13.itm~   ~override~ // wand of cloudkill
              ~wand14.itm~   ~override~ // web sack
              ~wand15.itm~   ~override~ // wand of apprenti
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BOR 0b00100000) // adds monk flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~boot01.itm~ ~override~ // boots of speed
// (added by DW)              ~leat24.itm~ ~override~ // grandmaster armor
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BAND  0b11011111) // removes monk flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00010000) // adds gnome flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000100) // adds halfling flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000010) // adds half-elf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000001) // adds dwarf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b10000000) // adds wildmage flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~   ~override~ // Amulet of power
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~misc5x.itm~   ~override~ // harper pin
  READ_BYTE  0x29 "use"
  WRITE_BYTE 0x29 ("%use%" BOR  0b01000000) // adds barbarian flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b10111111) // removes barbarian flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~ ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b00100000) // add avenger flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11011111) // removes avenger flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~chan20.itm~   ~override~ // white dragon scale
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~leat19.itm~   ~override~ // white dragon scale
              ~misc5x.itm~   ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR   0b00010000) // adds shapeshifter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwshld01.itm~ ~override~ // drow medium shield
              ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
              ~scrl9b.itm~   ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11101111) // removes shapeshifter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~ ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b00001000) // adds totemic druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
              ~scrl9b.itm~   ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11110111) // removes totemic druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111011) // removes lathander flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111101) // removes helm flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111110) // removes talos flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl8e.itm~ ~override~ // protection from the elements
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11101111) // remove swashbuckler flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
              ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11110111) // remove bounty hunter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
              ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11111011) // remove assassin flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwblun01.itm~ ~override~ // drow flail +3
              ~dwhalb01.itm~ ~override~ // drow halberd +3
              ~dwsper01.itm~ ~override~ // drow lance +3
              ~dwsw1h02.itm~ ~override~ // drow long sword +3
              ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~dwsw1h01.itm~ ~override~ // Drow Scimitar +3
              ~misc4q.itm~   ~override~ // The Ogre's Sword
              ~misc4u.itm~   ~override~ // Embarl's Dagger
              ~misc9q.itm~   ~override~ // scimitar
              ~sendai.itm~   ~override~ // sendai's flail
              ~sw1h20.itm~   ~override~ // scimitar
              ~sw1h22.itm~   ~override~ // Scimitar +1
              ~sw1h23.itm~   ~override~ // Scimitar +2, Rashad's Talon
              ~sw1h30.itm~   ~override~ // belm +2
              ~sw1h50.itm~   ~override~ // Shazzellim +1
              ~sw1h52.itm~   ~override~ // Scimitar +3
              ~sw1h56.itm~   ~override~ // Scimitar
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BOR 0b00000010) // adds beastmaster flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl8e.itm~   ~override~ // protection from the elements
              ~scrl9a.itm~   ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND 0b11111101) // removes beastmaster flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
  READ_BYTE  0x2b "use"
  WRITE_BYTE 0x2b ("%use%" BOR 0b00000001) // adds stalker flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hlolth.itm~   ~override~ // handmaiden's mace
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND 0b11111110) // removes stalker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
  READ_BYTE  0x2d "use"
  WRITE_BYTE 0x2d ("%use%" BOR 0b10000000) // adds archer flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hlolth.itm~   ~override~ // handmaiden's mace
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b01111111) // removes archer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrl3h.itm~ ~override~ // protection from evil
  READ_BYTE  0x2d "use"
  WRITE_BYTE 0x2d ("%use%" BOR 0b00100000) // adds transmuter flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11011111) // removes transmuter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11101111) // removes necromancer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11110111) // removes invoker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111011) // removes illusionist flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwchan01.itm~ ~override~ // drow chain
              ~dwchan02.itm~ ~override~ // drow chain
              ~dwplat01.itm~ ~override~ // drow plate
              ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
              ~shld25.itm~   ~override~ // shield of harmony
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111101) // removes enchanter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111110) // removes diviner flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b01111111) // removes conjurer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrla1.itm~   ~override~ // wizard eye
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BOR   0b01000000) // adds abjurer flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b10111111) // removes abjurer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11011111) // removes undead hunter flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
              ~ttpot.itm~  ~override~ // potion of extra healing
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11101111) // removes inquisitor flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwxbow01.itm~ ~override~ // Drow Crossbow of Speed
              ~wasling.itm~  ~override~ // Sling of Everard +5
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BOR   0b00001000) // adds cavalier flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11110111) // removes cavalier flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~   ~override~ // Gauntlets of Crushing
              ~dart08.itm~   ~override~ // Crimson Dart +3
              ~dwxbow01.itm~ ~override~ // Drow Crossbow of Speed
              ~misc5x.itm~   ~override~ // harper pin
              ~npbow.itm~    ~override~ // bow of arvoreen
              ~wasling.itm~  ~override~ // Sling of Everard +5
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000100) // adds kensai flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b11111011) // removes kensai flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~   ~override~ // Gauntlets of Crushing
              ~dwclck01.itm~ ~override~ // Drow Piwafwi Cloak
              ~misc5x.itm~   ~override~ // harper pin
              ~misc9w.itm~   ~override~ // Drow Piwafwi Cloak
              ~regisamu.itm~ ~override~ // Ruby Pendant of Beguiling
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000010) // add wizslayer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clck09.itm~  ~override~ // mage robe of cold resistance
              ~clck10.itm~  ~override~ // mage robe of fire resistance
              ~clck11.itm~  ~override~ // mage robe of electric resistance
              ~clck12.itm~  ~override~ // knave's robe
              ~clck13.itm~  ~override~ // traveller's robe
              ~clck14.itm~  ~override~ // adventurer's robe
              ~clck15.itm~  ~override~ // robe of the good archmagi
              ~clck16.itm~  ~override~ // robe of the neutral archmagi
              ~clck17.itm~  ~override~ // robe of the evil archmagi
              ~clck18.itm~  ~override~ // knave's robe
              ~clck19.itm~  ~override~ // robe of the good archmagi
              ~clck29.itm~  ~override~ // robe of the apprenti
              ~hgwra02.itm~ ~override~ // robe of the good archmagi
              ~hlolth.itm~  ~override~ // handmaiden's mace
              ~ipotn08.itm~ ~override~ // healing potion
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~potn08.itm~  ~override~ // healing potion
              ~potn17.itm~  ~override~ // elixir of health
              ~potn20.itm~  ~override~ // antidote
              ~potn25.itm~  ~override~ // healing potion (cursed)
              ~potn32.itm~  ~override~ // antidote (cursed)
              ~potn52.itm~  ~override~ // extra healing potion
              ~potn55.itm~  ~override~ // superior healing potion
              ~scrl1w.itm~  ~override~ // fireshield (blue)
              ~scrl2b.itm~  ~override~ // stoneskin
              ~scrl5t.itm~  ~override~ // protection from electricity
              ~scrl9a.itm~  ~override~ // pierce shield
              ~ttpot.itm~   ~override~ // extra healing potion
              ~wa2robe.itm~ ~override~ // robe of vecna
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND  0b11111101) // removes wizardslayer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~   ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000001) // adds berserker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl7u.itm~ ~override~ // contingency
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b11111110) // removes berserker flag
  END
  BUT_ONLY_IF_IT_CHANGES

// items not working due to mis-targeted effects
COPY_EXISTING ~DRAGRING.ITM~ ~OVERRIDE~
              ~JONHP1.ITM~   ~OVERRIDE~
              ~LICH.ITM~     ~OVERRIDE~
  READ_LONG 0x6a ~effectsOffset~ ELSE 0x72
  FOR (READ_SHORT 0x70 numberOfEffects ELSE 0x00; numberOfEffects > 0x00; numberOfEffects = numberOfEffects - 0x01) BEGIN
    WRITE_BYTE ~%effectsOffset%~ + 0x02 0x01
    SET ~effectsOffset~ = ~%effectsOffset%~ + 0x30
  END
  BUT_ONLY_IF_IT_CHANGES

// many items have effects not being applied due to bad timing modes
COPY_EXISTING ~AEGIS.ITM~    ~override~ // color
              ~AEGIS2.ITM~   ~override~ // color
              ~AX1H04.ITM~   ~override~ // color
              ~AX1H05.ITM~   ~override~ // color
              ~AX1H06.ITM~   ~override~ // color
              ~AX1H08.ITM~   ~override~ // color
              ~BAZPATRG.ITM~ ~override~ // immunity to teleport field
              ~BLUN01.ITM~   ~override~ // color
              ~BLUN04.ITM~   ~override~ // color
              ~BLUN06.ITM~   ~override~ // color
              ~BLUN10.ITM~   ~override~ // color
              ~BLUN23.ITM~   ~override~ // color
              ~BLUN24.ITM~   ~override~ // color
              ~BLUN31.ITM~   ~override~ // color
              ~BODHI.ITM~    ~override~ // protection from spell: nature's beauty
              ~BOW02.ITM~    ~override~ // color
              ~BOW05.ITM~    ~override~ // color
              ~BOW08.ITM~    ~override~ // color
              ~BOW09.ITM~    ~override~ // color
              ~BOW10.ITM~    ~override~ // color
              ~BOW11.ITM~    ~override~ // color
              ~BOW14.ITM~    ~override~ // color
              ~BOW15.ITM~    ~override~ // color
              ~BOW16.ITM~    ~override~ // color
              ~BOW18.ITM~    ~override~ // color
              ~BOW19.ITM~    ~override~ // color
              ~BOW20.ITM~    ~override~ // color
              ~BOW21.ITM~    ~override~ // color
              ~BOW24.ITM~    ~override~ // color
              ~BOW26.ITM~    ~override~ // color
              ~BOW99.ITM~    ~override~ // color
              ~BOWNON.ITM~   ~override~ // color
              ~CATTAC1.ITM~  ~override~ // color
              ~CATTIBOW.ITM~ ~override~ // color
              ~CHALSLAY.ITM~ ~override~ // protection from spell: lower resist
              ~CHWRAITH.ITM~ ~override~ // immunities to charm, sleep, hold creature, hold creature type
              ~CLOWN.ITM~    ~override~ // colorglow pulse
              ~DAGG04.ITM~   ~override~ // color
              ~DAGG05.ITM~   ~override~ // color
              ~DAGG16.ITM~   ~override~ // color
              ~DAGG18.ITM~   ~override~ // color
              ~DAGGSHIT.ITM~ ~override~ // color
              ~DEMOGORG.ITM~ ~override~ // protection from spell: lower resist
              ~DEMSUC01.ITM~ ~override~ // protection from spell: nature's beauty
              ~DWHALB01.ITM~ ~override~ // color
              ~ENMACE.ITM~   ~override~ // color
              ~ENMORN.ITM~   ~override~ // color
              ~ENSW2H.ITM~   ~override~ // color
              ~FROSTY.ITM~   ~override~ // cold resist bonus
              ~FSSPIR.ITM~   ~override~ // character color, immunity to teleport field
              ~GHOST.ITM~    ~override~ // slow
              ~GHOST2.ITM~   ~override~ // slow
              ~GIAFIR.ITM~   ~override~ // color
              ~GIAFIR2.ITM~  ~override~ // color
              ~GIAFIR3.ITM~  ~override~ // color
              ~GIANTS01.ITM~ ~override~ // color
              ~GORCHR.ITM~   ~override~ // immunity to teleport field, slay, kill target
              ~GORFIRG.ITM~  ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORJELFU.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORJELGR.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORMISTI.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORWOM1.ITM~  ~override~ // protection from nature's beauty
              ~HALB01.ITM~   ~override~ // color
              ~HALBRD01.ITM~ ~override~ // color
              ~HAMM01.ITM~   ~override~ // color
              ~HELM14.ITM~   ~override~ // remove fear, remove fear 2 effects
              ~HGBER01.ITM~  ~override~ // color
              ~HGNYMPH.ITM~  ~override~ // protection from nature's beauty
              ~HGWRA01.ITM~  ~override~ // protection from nature's beauty
              ~HOLDRING.ITM~ ~override~ // immunity to teleport field
              ~HSLAYWPN.ITM~ ~override~ // regen
              ~HSPECTRE.ITM~ ~override~ // protection from deathsong, invis detection by script
              ~IAX1H01.ITM~  ~override~ // color
              ~IBLUN04.ITM~  ~override~ // color
              ~IBOW03.ITM~   ~override~ // color
              ~IHAMM01.ITM~  ~override~ // color
              ~INNOC2.ITM~   ~override~ // protection from nature's beauty
              ~INVULNER.ITM~ ~override~ // immunity to teleport field
              ~IRONGOL.ITM~  ~override~ // immunity to sleep, poison
              ~KUOBOW.ITM~   ~override~ // color
              ~LICH.ITM~     ~override~ // resistance to cold & electricity, immunity to non-magic weapons and spell lev < 6
              ~MDOG1.ITM~    ~override~ // immunity to charm
              ~NPBOW.ITM~    ~override~ // color
              ~OBJRING.ITM~  ~override~ // protection from nature's beauty, immunity to break morale
              ~PLYMSTAR.ITM~ ~override~ // color
              ~REAVER.ITM~   ~override~ // color
              ~RING94.ITM~   ~override~ // protection from nature's beauty
              ~RING95.ITM~   ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~RING99.ITM~   ~override~ // immunity to animations spmindat & spflayer
              ~RINGWOLF.ITM~ ~override~ // regen
              ~SELTEST.ITM~  ~override~ // use eff
              ~SHALT01.ITM~  ~override~ // protection from nature's beauty, immunity to break morale
              ~SKELCLUB.ITM~ ~override~ // color
              ~SKELWASU.ITM~ ~override~ // color
              ~SLAYERWP.ITM~ ~override~ // current hp bonus
              ~SLAYSH01.ITM~ ~override~ // protection from nature's beauty
              ~SPECTR.ITM~   ~override~ // protection from nature's beauty
              ~STALKER.ITM~  ~override~ // protection from nature's beauty
              ~STONRING.ITM~ ~override~ // set item color
              ~STONSKIN.ITM~ ~override~ // stoneskin effect
              ~SUREHP1.ITM~  ~override~ // immunity to teleport field
              ~SW1H08.ITM~   ~override~ // color
              ~SW1H14.ITM~   ~override~ // color
              ~SW1H57.ITM~   ~override~ // color
              ~SW1H99.ITM~   ~override~ // color
              ~SW2H01.ITM~   ~override~ // color
              ~SW2H01B.ITM~  ~override~ // color
              ~SW2H02.ITM~   ~override~ // color
              ~SW2H05.ITM~   ~override~ // color
              ~SW2H14.ITM~   ~override~ // imunity to spconfus animation
              ~TELSLAV.ITM~  ~override~ // protection from nature's beauty
              ~TELSLAV2.ITM~ ~override~ // immunity to charm, sleep
              ~TTSWORD2.ITM~ ~override~ // color
              ~VAMP.ITM~     ~override~ // protection from nature's beauty
              ~VAMP1.ITM~    ~override~ // protection from nature's beauty
              ~VAMP2.ITM~    ~override~ // protection from nature's beauty
              ~VAMP3.ITM~    ~override~ // protection from nature's beauty
              ~WIGHT.ITM~    ~override~ // protection from nature's beauty
              ~WRAITH1.ITM~  ~override~ // protection from nature's beauty
              ~XBOW01.ITM~   ~override~ // color
              ~XBOW02.ITM~   ~override~ // modify attacks per round
              ~XBOW03.ITM~   ~override~ // color
              ~XBOW07.ITM~   ~override~ // modify attacks per round
              ~XBOW08.ITM~   ~override~ // modify attacks per round
              ~XBOW17.ITM~   ~override~ // modify attacks per round
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x6a "fx_off"
    READ_SHORT 0x70 "fx_num"
    FOR (index = 0; index < "%fx_num%"; index = index + 1) BEGIN // searches through global effects
      WRITE_BYTE ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2 // instant/while equipped
      WRITE_LONG ("%fx_off%" + 0x0e + ("%index%" * 0x30)) 0 // duration
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// attack items used by summons should have actual strings instead of -1 or 'skull'
COPY_EXISTING ~basilg1.itm~  ~override~ // -1
              ~basilg2.itm~  ~override~ // -1
              ~basilg3.itm~  ~override~ // -1
              ~basill1.itm~  ~override~ // -1
              ~basill2.itm~  ~override~ // -1
              ~b1-6.itm~     ~override~ // 8777
              ~b1-8.itm~     ~override~ // 8777
              ~b1-8m1.itm~   ~override~ // 8777
              ~b1-10m2.itm~  ~override~ // 8777
              ~b1-12.itm~    ~override~ // 8777
              ~b1-12m3.itm~  ~override~ // 8777
              ~b1-20m3.itm~  ~override~ // -1
              ~b1-20m4.itm~  ~override~ // -1
              ~b2-16.itm~    ~override~ // 8777
              ~b3-24.itm~    ~override~ // -1
              ~b4-32.itm~    ~override~ // 8777
              ~b4-32m3.itm~  ~override~ // -1
              ~b4-32m4.itm~  ~override~ // -1
              ~catjag.itm~   ~override~ // 8777
              ~catlio.itm~   ~override~ // 8777
              ~carrio1.itm~  ~override~ // -1
              ~dogwawp.itm~  ~override~ // 8777
              ~elairl.itm~   ~override~ // 8777
              ~etterc1.itm~  ~override~ // -1
              ~etterc2.itm~  ~override~ // -1
              ~figspid.itm~  ~override~ // -1
              ~fireelel.itm~ ~override~ // 8777
              ~fireelem.itm~ ~override~ // 8777
              ~genscim.itm~  ~override~ // 8777
              ~ghast1.itm~   ~override~ // -1
              ~golfle.itm~   ~override~ // 8777
              ~golcla.itm~   ~override~ // -1
              ~golsto.itm~   ~override~ // -1
              ~jellmu1.itm~  ~override~ // 14182
              ~lacedo.itm~   ~override~ // -1
              ~mistpo.itm~   ~override~ // 8777
              ~nishruu.itm~  ~override~ // -1
              ~ogre1.itm~    ~override~ // -1
              ~p1-4.itm~     ~override~ // 8777
              ~p1-8.itm~     ~override~ // 8777
              ~p1-8m1.itm~   ~override~ // 8777
              ~p3-12m4.itm~  ~override~ // -1
              ~s1-8.itm~     ~override~ // 8777
              ~s1-10m4.itm~  ~override~ // 8777
              ~spidgi1.itm~  ~override~ // -1
              ~spidph1.itm~  ~override~ // -1
              ~spidsw1.itm~  ~override~ // -1
              ~stalkesu.itm~ ~override~ // 2898
              ~wolfwi1.itm~  ~override~ // -1
              ~wolfwi2.itm~  ~override~ // -1
              ~wraith1.itm~  ~override~ // -1
              ~wyvern1.itm~  ~override~ // -1
              ~wyvern2.itm~  ~override~ // -1
  SAY NAME1 #10966
  SAY NAME2 #10966
  BUT_ONLY_IF_IT_CHANGES

// elven sleep/charm immunity
COPY_EXISTING ~clck07.itm~   ~override~ // cloak of the nymph
              ~dagg13.itm~   ~override~ // pixie prick +3
              ~dwbolt01.itm~ ~override~ // drow bolt o' sleep
              ~gorwom1.itm~  ~override~ // undroppable nalmissra weapon - charm effect
              ~hgnymph.itm~  ~override~ // undroppable nymph weapon - charm effect
              ~misc2p.itm~   ~override~ // harp; appears unused
              ~misc9x.itm~   ~override~ // illithid control circlet
              ~psdclaw.itm~  ~override~ // ToB pseudodragon melee weapon
              ~regisamu.itm~ ~override~ // Ruby Pendant of Beguiling on Regis
              ~ring03.itm~   ~override~ // Ring of Animal Friendship
              ~ring30.itm~   ~override~ // Ring of Human Influence
              ~staf09.itm~   ~override~ // staff of command
              ~staf14.itm~   ~override~ // staff of the woodlands
              ~staf15.itm~   ~override~ // staff of air
              ~wand08.itm~   ~override~ // wand of sleep
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 39) OR ("%opcode%" = 5)) BEGIN // if there's a sleep or charm opcode
        READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
        READ_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob1"
        READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob2"
        PATCH_IF ("%opcode%" = 5) BEGIN // if charm
          SET "new_fx" = 14
        END ELSE BEGIN
          SET "new_fx" = 10
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        FOR (index4 = 2 ; index4 < 4 ; index4 = index4 + 1) BEGIN
          FOR (index3 = 0 ; index3 < (("%new_fx%" / 2)) ; index3 = index3 + 1) BEGIN
            INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
              WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177           // use eff file
              WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) "%target%"    // preserve target
              WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%index4%"    // elf or half elff
              WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4             // race.ids
              WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) ("%prob2%" + ((21 - ("%index4%" * 6)) * ("%prob1%" - "%prob2%") / 10)) // 90%
              WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * "%abil_fx_idx%")) "%prob2%"     // base prob
              WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~cdelfcm%index3%~    // eff file
            PATCH_IF ("%opcode%" = 39) BEGIN
              WRITE_ASCII ("%fx_off%" + 0x19 + (0x30 * "%abil_fx_idx%")) ~sl~ #2 // eff file
            END
          END
        END
        SET "index2" = "%index2%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// adds magical flag to a mess of undroppable items to prevent black dragon from taking them
COPY_EXISTING ~aeriebab.itm~ ~override~
              ~bearspir.itm~ ~override~
              ~bootdriz.itm~ ~override~
              ~clck18.itm~   ~override~
              ~dax1h01.itm~  ~override~
              ~famcat.itm~   ~override~
              ~famcat25.itm~ ~override~
              ~famdus25.itm~ ~override~
              ~famdust.itm~  ~override~
              ~famfai25.itm~ ~override~
              ~famfair.itm~  ~override~
              ~famfer.itm~   ~override~
              ~famfer25.itm~ ~override~
              ~famimp.itm~   ~override~
              ~famimp25.itm~ ~override~
              ~fampsd.itm~   ~override~
              ~fampsd25.itm~ ~override~
              ~famqua25.itm~ ~override~
              ~famquas.itm~  ~override~
              ~famrab.itm~   ~override~
              ~famrab25.itm~ ~override~
              ~helmskwa.itm~ ~override~
              ~kuobow.itm~   ~override~
              ~kuosper.itm~  ~override~
              ~lionspir.itm~ ~override~
              ~misc4g.itm~   ~override~
              ~misc84.itm~   ~override~
              ~plat98.itm~   ~override~
              ~plybass.itm~  ~override~
              ~plyfist.itm~  ~override~
              ~plymstar.itm~ ~override~
              ~plysala.itm~  ~override~
              ~plyspid.itm~  ~override~
              ~plywyvrn.itm~ ~override~
              ~snakspir.itm~  ~override~
              ~wolfspir.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE 0x18 "flags"
    PATCH_IF (("%flags%" BAND "0b00000100") = "0b00000000") BEGIN
      WRITE_BYTE "0x18" ("%flags%" BOR "0b01000000")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// missile weapons using wrong projectiles and being blocked by protection from normal missiles
COPY_EXISTING ~aegis.itm~    ~override~ // aegis fang
              ~arow02.itm~   ~override~ // arrows +1
              ~ax1h05.itm~   ~override~ // throwing axe +2
              ~ax1h06.itm~   ~override~ // throwing axe +2
              ~ax1h08.itm~   ~override~ // hangard's axe +2
              ~ax1h09.itm~   ~override~ // rifthome axe +3
              ~ax1h16.itm~   ~override~ // k'logarath +4
              ~hamm06.itm~   ~override~ // dwarven thrower
              ~wasling.itm~  ~override~ // sling of everard +5
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN
      READ_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) "proj"
      PATCH_IF ("%proj%" = 5) BEGIN // normal arrow projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 2 // magic arrow
      END ELSE
      PATCH_IF ("%proj%" = 10) BEGIN // normal axe projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 7 // magic axe
      END ELSE
      PATCH_IF ("%proj%" = 20) BEGIN // normal axe projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 17 // magic bullet
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// consistent +x/+y weapons, from G3 tweaks
COPY_EXISTING ~SW1H31.itm~ ~override~ // Daystar, strref #39453
  WRITE_LONG 0x60 4
  BUT_ONLY_IF_IT_CHANGES

// consistent +x/+y weapons, from G3 tweaks
COPY_EXISTING ~sw1h03.itm~ ~override~ // bastard sword +1/+3 vs shapeshifters, strref #7345
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES

// null-weight magically created items, from G3 Tweaks
COPY_EXISTING ~BOLT07.itm~   ~override~ // Jan's Flashers
              ~BRDFLUTE.itm~ ~override~ // bard flute
              ~ENMACE.itm~   ~override~ // Enchanted Weapon: Mace
              ~ENMORN.itm~   ~override~ // Enchanted Weapon: Morningstar
              ~ENSTAFF.itm~  ~override~ // Enchanted Weapon: Staff
              ~ENSW1H01.itm~ ~override~ // Enchanted Weapon: Long Sword
              ~ENSW1H02.itm~ ~override~ // Enchanted Weapon: Short Sword
              ~ENSW2H.itm~   ~override~ // Enchanted Weapon: Battle Axe
              ~MELFMET.itm~  ~override~ // Melf's Minute Meteors
              ~PLYMSTAR.itm~ ~override~ // Ogre's Morningstar from Polymorph Self
              ~PLYSALA.itm~  ~override~ // Salamander's Spear from Polymorph Self
              ~SHILLE.itm~   ~override~ // Shillegagh
              ~SORB.itm~     ~override~ // Sol's Searing Orb
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x4c 0
  END
  BUT_ONLY_IF_IT_CHANGES

// boots of speed, grandmaster armor haste > movement rate bonus fix
COPY_EXISTING ~boot01.itm~ ~override~
              ~leat24.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
      PATCH_IF( "%type%" = 16 ) BEGIN  // if haste effect
        WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 126 // change to movementrate bonus
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 200 // of 200%
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 2   // via set%
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amulet of shield not protecting against MM
COPY_EXISTING ~amul15.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) OR ("%opcode%" = 15)) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206          // protection from spell
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0xffffffff   // strref
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spwi112~ #8 // mage spell
        // insert display string
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139       // display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 14771     // 'shielded'
          WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/perm
          WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 0         // duration
        SET "fx_delta" = "%fx_delta%" + 2
        SET "abil_fx_num" = "%abil_fx_num%" + 2
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amul23 and amul24 have different BAMs than amul22
COPY_EXISTING ~amul23.itm~ ~override~
              ~amul24.itm~ ~override~
  WRITE_EVALUATED_ASCII 0x3a ~i%SOURCE_RES%~ #8
  WRITE_EVALUATED_ASCII 0x58 ~c%SOURCE_RES%~ #8
  BUT_ONLY_IF_IT_CHANGES

// aegis fang shouldn't display name while unidentified, wrong prof
COPY_EXISTING ~aegis.itm~  ~override~
              ~aegis2.itm~ ~override~
  WRITE_BYTE 0x31 97 // warhammer
  SAY 0x08 #6345
  BUT_ONLY_IF_IT_CHANGES

// adds +1 enchantment to acid arrows and Flasher Master Bruiser Mates (BD)
COPY_EXISTING ~arow04.itm~ ~override~
              ~bolt07.itm~ ~override~
              ~dart05.itm~ ~override~
  WRITE_LONG 0x60 1
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~arow06.itm~   ~override~ // arrows of detonation - explosion has power 3
              ~arow08.itm~   ~override~ // arrows of fire - fire damage has power 6
              ~arow09.itm~   ~override~ // arrows of ice - cold damage has power 6
              ~aurstaf.itm~  ~override~ // aurumach rilmani's undroppable staff - slow effects have power 6
              ~ax1h07.itm~   ~override~ // bala's axe - miscast magic effects have power 3
              ~blun20.itm~   ~override~ // ardulia's flail - slow effects have power 3
              ~bolt03.itm~   ~override~ // bolt of lightning - electrical damage has power 6
              ~bolt05.itm~   ~override~ // bolt of polymorphing - polymorph effects are power 6
              ~bonedag.itm~  ~override~ // bone dagger attack item - slow effects have power 2, all other effects 0
              ~chalcy2.itm~  ~override~ // undroppable weapon of cyric's chosen - blindness effect has power 1
              ~dart03.itm~   ~override~ // dart of stunning - stun effects have power 8
              ~dart04.itm~   ~override~ // dart of wounding - poison damage has power 0, poison portrait icon has power 8
              ~dart05.itm~   ~override~ // asp's nest - poison damage has power 0, poison portrait icon has power 8
              ~dartmel.itm~  ~override~ // melissan's bone daggers - slow and disease effects have power 8
              ~globblu1.itm~ ~override~ // blue globe - cold damage at power 5
              ~globred1.itm~ ~override~ // red globe - fire damage at power 4
              ~gorcamb.itm~  ~override~ // aesgearth's undroppable weapon - stun at power 6, str/con drain at power 8
              ~hamm03.itm~   ~override~ // ashideena - electrical damage has power 8
              ~hamm05.itm~   ~override~ // borok's fist - electrical damage has power 8
              ~hgber01.itm~  ~override~ // berren's undroppable weapon - slow and dex penalties at power 4
              ~hgnya01.itm~  ~override~ // nyalee's undroppable weapon - slow, entangle effects at power 4
              ~icetrl.itm~   ~override~ // blizzard trolls' undroppable weapon - stun, dex penalty at power 6
              ~killsw01.itm~ ~override~ // arkanis gath's insta-kill sword for crossing shadow thieves - all elemental damages at power 8
              ~kuobolt3.itm~ ~override~ // high level kuo-toa bolts - web/entangle effects at power 2
              ~misc5c.itm~   ~override~ // rift device - fire damage has power 100, all other effects are at 0
              ~mistcd.itm~   ~override~ // attack of crimson deaths - visual effect has power 1
              ~mistho.itm~   ~override~ // attack of mist horrors, swamp horrors - horror effects are at power 4
              ~mistice.itm~  ~override~ // attack of ice mists - horror effects are at power 4
              ~mistva.itm~   ~override~ // attack of vampiric mists - level drain at power 1
              ~mistva2.itm~  ~override~ // attack of vampiric wraiths - level drain at power 1
              ~mistwa.itm~   ~override~ // attack of wandering horrors - stun at power 4
              ~mound.itm~    ~override~ // attack of shambling mounds - slow, ac penalty, extra damage, entangle at power 1, play sound at power 2
              ~nebdag.itm~   ~override~ // neb's dagger - slow effect at power 2, poison at 0
              ~potn26.itm~   ~override~ // potion of explosions
              ~potn27.itm~   ~override~ // potion of firebreath
              ~quasclaw.itm~ ~override~ // attack of quasit familiars - dex drain has power 4
              ~ravag01.itm~  ~override~ // attack of ravager - one effect (visual) has power 3, all others 0
              ~ravag02.itm~  ~override~ // attack of ravager - stun has power 6, all others 0
              ~revent1.itm~  ~override~ // attack of revenants - paralyzation effects at power 1
              ~ring20.itm~   ~override~ // ring of energy
              ~rods03.itm~   ~override~ // rod of resurrection
              ~scrl03.itm~   ~override~ // protection from acid
              ~scrl04.itm~   ~override~ // protection from cold
              ~scrl05.itm~   ~override~ // protection from electricity
              ~scrl06.itm~   ~override~ // protection from fire
              ~scrl08.itm~   ~override~ // protection from poison
              ~scrl09.itm~   ~override~ // protection from undead
              ~scrl15.itm~   ~override~ // protection from petrification
              ~secret02.itm~ ~override~ // pulse ammo - magical damage for easter egg item at power 8
              ~sendai.itm~   ~override~ // sendai's flail - slow has power 6, other effects such as str drain and poison use 0
              ~shille.itm~   ~override~ // shillelagh - visual effect has power 1
              ~spermel.itm~  ~override~ // mellisan's spear.itm~   ~override~ // slow and stun at power 8, save penalties at power 6
              ~staf14.itm~   ~override~ // staff of the woodlands
              ~sw1h06.itm~   ~override~ // varscona - cold damage at power 8
              ~sw1h58.itm~   ~override~ // short sword of mask - some entangle effects at power 1, 2
              ~sw1h59.itm~   ~override~ // short sword of mask - some entangle effects at power 1, 2
              ~telslav.itm~  ~override~ // attack of slave wraiths - slay and finger of death animation at power 7
              ~trolltor.itm~ ~override~ // attack of tor'gal - slow and str drain at power 3
              ~wand12.itm~   ~override~ // wand of wonder - all effects at power 0 except visuals at 8
              ~wolfwi1.itm~  ~override~ // attack of winter wolves - cold damage at power 1
              ~wolfwi2.itm~  ~override~ // attack of winter wolves - cold damage at power 1
              ~xbow15.itm~   ~override~ // firetooth - fire damage at power 6
              ~xbow16.itm~   ~override~ // firetooth - fire damage at power 6
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // should bypass spell protections
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fire arrows have a spurious +2 thac0 bonus
COPY_EXISTING ~arow08.itm~   ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      WRITE_SHORT ("%abil_off%" + 0x14 + (0x38 * "%index%")) 0 // thac0 bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// miscast effects not accompanied by miscast icon
COPY_EXISTING ~ax1h07.itm~   ~override~ // 80% on hit, no icon
  SET "abil_length" = 0x38
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  READ_SHORT 0x70 "fx_num"   ELSE 0
  SET "fx_type" = 0
  SET "new_fx_1" = 0
  SET "new_fx_2" = 0
  SET "delta" = 0
  FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
    READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
    PATCH_IF ("%opcode%" = 60) BEGIN // miscast effect
      READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
      SET "new_fx_1" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
      SET "new_fx_2" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
      WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
    END
  END
  PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
    INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
      WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
      WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
      WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 105       // miscast magic
    SET "delta" = "%delta%" + 1
    SET "fx_num" = "%fx_num%" + 1
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    SET "new_fx_1" = 0 // reset for each loop through abilities
    SET "new_fx_2" = 0 // reset for each loop through abilities
    READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // miscast magic
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
      INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
        WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 105           // miscast magic
      SET "delta" = "%delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES
  
// Amkethran duplicate gem bag fix, part one of four (see amsmug01.sto amsmug02.sto, cdbag02i.sto, cdbag02j.sto)
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check
  COPY_EXISTING ~bag02i.itm~ ~override/cdbag02i.itm~
  COPY_EXISTING ~bag02i.itm~ ~override/cdbag02j.itm~
END

// black blade o' disaster using wrong power level for level drain
// black blade o' disaster is supposed to disintegrate, not slay
COPY_EXISTING ~blakblad.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 216) BEGIN  // level drain
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // power 9
      END
      PATCH_IF ("%opcode%" = 55) BEGIN // slay
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 238 // disintegrate
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// %$#*$&^ damage vs type opcode. remove global 'use eff' opcode; move to melee header (revised by Wisp)
// see macedisr.eff for second half of this fix
COPY_EXISTING ~blun12.itm~ ~override~
              deva.itm     override
              hamm10.itm   override
              hamm11.itm   override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    SET "fx_delta" = 0
    FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
      READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
      READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
      PATCH_IF (("%type%" = 177) AND ("macedisr" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
        DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
        SET "fx_num" = ("%fx_num%" - 1)
        SET "fx_delta" = ("%fx_delta%" - 1)
        SET "index" = ("%index%" - 1)
      END
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
      READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee ability check
        READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
        WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
        INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
          WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
          WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
          WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~cddisr~   // resref
        SET "fx_delta" = ("%fx_delta%" + 1)
      END
    END
  END
BUT_ONLY


// Azuredge fix (revised by Wisp and aVENGER)

COPY ~bg2fixpack/copy/ax1h10a.eff~  ~override~ // 1d6+4 extra damage vs. undead for Azuredge (slashing)
COPY ~bg2fixpack/copy/ax1h10b.eff~  ~override~ // 1d6+4 extra damage vs. undead for Azuredge (missile)

COPY_EXISTING ~ax1h10.itm~ ~override~
// first uncorrupt the item by fixing the misplaced indexes
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT 0x70 fx_num
  t_fx_num = fx_num
  CLEAR_ARRAY ab_array
  GET_OFFSET_ARRAY ab_array 0x64 4 0x68 2 0 0 0x38
  PHP_EACH ab_array AS int => goa_abil_off BEGIN
    CLEAR_ARRAY fx_array
    GET_OFFSET_ARRAY2 fx_array goa_abil_off 0x6a 4 0x1e 2 0x20 2 0x30
    PHP_EACH fx_array AS int => goa_fx_off BEGIN
      t_fx_num += 1
    END
  END
  PATCH_IF 0x72 + abil_num*0x38 + 0x30*t_fx_num < BUFFER_LENGTH BEGIN
    DELETE_BYTES 0x72 + abil_num*0x38 + 0x30*t_fx_num BUFFER_LENGTH - (0x72 + abil_num*0x38 + 0x30*t_fx_num)
  END
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EQEFFECT~ INT_VAR "opcode_to_delete" = "177" END              // delete the old, incorrect bonus damage effect
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR "opcode_to_delete" = "177" header = "-1" END  // delete the Baldurdash undead slaying effect
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR opcode_to_delete = "55" header = "-1" END     // delete the old, incorrect undead slaying effect
  // note: the extra damage and the "Undead Destroyed" string need to go before the death effect, otherwise they won't display in the combat log
  PATCH_FOR_EACH type IN 2 1 BEGIN
    PATCH_IF type = 1 BEGIN
      SPRINT damage ax1h10a        //Slashing damage for melee header
    END ELSE SPRINT damage ax1h10b //Missile damage for ranged header
    PATCH_FOR_EACH resref IN mesdie "%damage%" die BEGIN
      LPF ADD_ITEM_EFFECT
        INT_VAR
          type
          opcode = 177   //use eff  
          target = 2
          parameter1 = 4 //undead
          parameter2 = 3 //general.ids
          timing = 1
        STR_VAR
          resource = EVAL "%resref%"
      END
    END
  END
  FOR (i =  0; i < abil_num; ++i) BEGIN
    READ_BYTE abil_off + i * 0x38 abil_type
    PATCH_IF abil_type = 2 BEGIN                //ranged
      WRITE_SHORT abil_off + 0x18 1             //number of dice of damage (1d6)
      WRITE_BYTE  abil_off + 0x26 THIS BOR BIT0 //allow strength bonus
    END
  END
BUT_ONLY

// name fix for FoA +2
COPY_EXISTING ~blun14d.itm~ ~override~
              ~blun14e.itm~ ~override~
              ~blun14f.itm~ ~override~
  SAY NAME2 @125
  BUT_ONLY_IF_IT_CHANGES

// fixes wrong BAMs for cold-acid flail of ages
COPY_EXISTING ~blun14e.itm~ ~override~
  WRITE_ASCII 0x3a ~IBLUN14E~
  WRITE_ASCII 0x58 ~CBLUN14E~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "melee"
    PATCH_IF ("%melee%" = 1) BEGIN
      WRITE_ASCII ("%abil_off%" + 0x04 + (0x38 * "%abil_num%")) ~IBLUN14E~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// damage/thac0 bonuses mistargeted, may not be applying
COPY_EXISTING ~blun18.itm~ ~override~ // skullcrusher
              ~hamm04.itm~ ~override~ // hammer +1/+4 v giantkin
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
    PATCH_IF ("%opcode%" = 177) BEGIN
      WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * "%index2%")) 0 // any
      WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * "%index2%")) 2 // ea.ids
    END
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index3%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index3%" + "%abil_fx_idx%"))) 0 // any
        WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%index3%" + "%abil_fx_idx%"))) 2 // ea.ids
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Club +3, Blackblood had Mace Animation. change it to club
COPY_EXISTING ~blun22.itm~ ~override~
  WRITE_ASCII 0x22 ~CL~
  BUT_ONLY_IF_IT_CHANGES

// level drain now handled by batch fixes
// changes the icon from generic mace to MoD's one. Also see macedisu.eff.
// new for v4; fix ^&%&# damage v opcode no-die bug
COPY_EXISTING ~blun25.itm~ ~override~
  WRITE_ASCII 0x3a ~iblun12~ #8 // use MoD BAM
  WRITE_ASCII 0x44 ~gblun06~ #8 // use MoD BAM
  WRITE_ASCII 0x58 ~cblun12~ #8 // use MoD BAM
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("macedisr" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN // change use macedisr eff to colorglow pulse
      WRITE_SHORT ("%fx_off%"        + ("%index%" * 0x30)) 9    // colorglow pulse
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%index%" * 0x30)) 1    // target self
      WRITE_BYTE  ("%fx_off%" + 0x06 + ("%index%" * 0x30)) 202  // green
      WRITE_BYTE  ("%fx_off%" + 0x07 + ("%index%" * 0x30)) 255  // blue
      WRITE_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 21   // weapon head/blade minor
      WRITE_SHORT ("%fx_off%" + 0x0a + ("%index%" * 0x30)) 0x6e // cycle speed
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2    // instant/while equipped
      WRITE_LONG  ("%fx_off%" + 0x0e + ("%index%" * 0x30)) 0    // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%index%" * 0x30)) 100  // probability 1
      WRITE_LONG  ("%fx_off%" + 0x24 + ("%index%" * 0x30)) 0    // blank save, just in case
    END
  END
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) ("%abil_fx_idx%")
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      SET "eff_count" = 0
      WRITE_ASCII (0x04 + "%abil_off%" + ("%index2%" * 0x38)) ~iblun12~ #8 // use MoD BAM
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index3%") * 0x30)) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "resref"
        // first fix misordered effects bug
        PATCH_IF (("%opcode%" = 177) AND (("mesdie" STRING_COMPARE_CASE "%resref%" = 0) OR ("die" STRING_COMPARE_CASE "%resref%" = 0))) BEGIN
          PATCH_IF ("%eff_count%" = 0) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "mesdie" #8
            SET "eff_count" = 1
          END ELSE BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "die" #8
          END
          WRITE_LONG    ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index3%") * 0x30)) 0 // save handled by EFF
          WRITE_LONG    ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%index3%") * 0x30)) 0 // save handled by EFF
        END
      END
      // then add new effect for undead damage
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~macedisu~ // resref
      SET "fx_delta" = ("%fx_delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// club of detonation's 3 fire damage only occurring 20% of the time, instead of always
COPY_EXISTING ~blun26.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // melee ability check
        READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
          READ_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "damage"
          PATCH_IF (("%opcode%" = 12) AND ("%damage%" = 3)) BEGIN // changes it from regular to missile THAC0 bonus
            WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 100 // probability
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes upgraded club o detonation to use club paperdoll and not be a flail
COPY_EXISTING ~blun27.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x1c 17  // mace
    WRITE_ASCII 0x22 ~CL~  // club
  END
  BUT_ONLY_IF_IT_CHANGES

// some books were quick-slottable
COPY_EXISTING ~book05.itm~ ~override~
              ~book07.itm~ ~override~
              ~book08.itm~ ~override~
  WRITE_SHORT 0x1c 0
  BUT_ONLY_IF_IT_CHANGES
  
// fixes price for 2 books to make them sellable
COPY_EXISTING ~book27.itm~ ~override~
              ~book39.itm~ ~override~
  WRITE_LONG 0x34 2
  BUT_ONLY_IF_IT_CHANGES

// some books were not quick-slottable
COPY_EXISTING ~book32.itm~ ~override~
              ~book94.itm~ ~override~
              ~book95.itm~ ~override~
              ~book96.itm~ ~override~
  WRITE_SHORT 0x1c 37
  BUT_ONLY_IF_IT_CHANGES

// fixes enchantment, weight, icons, and prof of short bow +1
COPY_EXISTING ~bow06.itm~ ~override~
  WRITE_BYTE  0x31 105
  WRITE_ASCII 0x3a ~ibow06~ #8
  WRITE_LONG  0x4c 2
  WRITE_ASCII 0x58 ~cbow06~ #8
  WRITE_LONG  0x60 1
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // if abilities are present, need to adjust their effects index
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 4) BEGIN // launcher
      WRITE_ASCII (0x04 + "%abil_off%" + ("%abil_num%" * 0x38)) ~ibow06~ #8 // use shortbow BAM
      WRITE_SHORT (0x0e + "%abil_off%" + ("%abil_num%" * 0x38)) 75          // fixes range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes swapped icons
COPY_EXISTING ~bow01.itm~ ~override~
              ~bow03.itm~ ~override~
  WRITE_EVALUATED_ASCII 0x3a ~i%SOURCE_RES%~ #8
  BUT_ONLY_IF_IT_CHANGES

// fixes incorrect BAMs for several bows
COPY_EXISTING ~bow01.itm~    ~override~
              ~bow03.itm~    ~override~
              ~bow06.itm~    ~override~
              ~bow09.itm~    ~override~
              ~bow11.itm~    ~override~
              ~bow12.itm~    ~override~
              ~bow14.itm~    ~override~
              ~bow15.itm~    ~override~
              ~bow16.itm~    ~override~
              ~bow17.itm~    ~override~
              ~bow18.itm~    ~override~
              ~bow22.itm~    ~override~
              ~bow23.itm~    ~override~
              ~gorwom2.itm~  ~override~
              ~npbow.itm~    ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_ASCII 0x3a "bam"
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "abil_type"
      PATCH_IF (("%abil_type%" = 2) OR ("%abil_type%" = 4)) BEGIN
        WRITE_EVALUATED_ASCII ("%abil_off%" + 0x04 + (0x38 * "%abil_num%")) ~%bam%~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes to long bow prof
COPY_EXISTING ~bow07.itm~ ~override~
  WRITE_BYTE 0x31 104
  BUT_ONLY_IF_IT_CHANGES

// Heartseeker gives regular THAC0 instead of missile THAC0
COPY_EXISTING ~bow10.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 54) BEGIN // changes it from regular to missile THAC0 bonus
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 167
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~brac20.itm~ ~override~ // gloves of curing
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// changes to axe proficiency; enchantment level incorrect
COPY_EXISTING ~bruenaxe.itm~ ~override~
  WRITE_BYTE 0x31 92
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES
  
// totemic druid summons weapons; enchantment level incorrect
COPY_EXISTING ~bearspir.itm~ ~override~
              ~lionspir.itm~ ~override~
              ~snakspir.itm~ ~override~
              ~wolfspir.itm~ ~override~
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES

// disallows str bonus for magic bullets
COPY_EXISTING ~bull02.itm~   ~override~
              ~bull03.itm~   ~override~
              ~bull04.itm~   ~override~
              ~bull05.itm~   ~override~
              ~bull06.itm~   ~override~
              ~quiver05.itm~ ~override~
              ~quiver06.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    WHILE ("%abil_num%" > 0) BEGIN // looks for ranged ability header
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
        WRITE_BYTE  ("%abil_off%" + 0x26 + ("%abil_num%" * 0x38)) 0 // disallow strength bonus
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~bull06.itm~ ~override~ // bullet +4
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 35
  END
  BUT_ONLY_IF_IT_CHANGES

// blindness not adding portait icon or message
COPY_EXISTING ~chalcy2.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 74) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone blindness fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // blindness icon fx
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139       // display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 14674     // 'blinded'
          WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/perm
          WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 0         // duration
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // blindness icon fx
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142       // display portrait icon
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 8         // blindness icon
        SET "fx_delta" = "%fx_delta%" + 2
        SET "abil_fx_num" = "%abil_fx_num%" + 2
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes chan02 description
COPY_EXISTING ~chan02.itm~ ~override~
  SAY IDENTIFIED_DESC #16272
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~chan03.itm~ ~override~ // mail of the dead
  WRITE_SHORT 0x42 65
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~chan21.itm~ ~override~ // chain mail +3
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 75
  END  
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clck08.itm~ ~override~
  WRITE_ASCII 0x3a ~iclck08~ #8 // inventory icon
  BUT_ONLY_IF_IT_CHANGES

// mage robe of fire resistance uses a resist fire/cold icon insead of protection from fire
COPY_EXISTING ~clck10.itm~  ~override~ // mage robe of fire resistance
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "icon"
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 26)) BEGIN
      WRITE_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 16
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add protection to all lightning projectiles for cloak of reflection
COPY_EXISTING ~clck24.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 197) BEGIN // looks for physical mirror
      READ_ASCII ("%fx_off%" + ("%index%" * 0x30)) "clone" (0x30) // clones effect
      SET "index" = "%fx_num%" // kills loop
      SET "new_fx" = 11 // enables next loop
    END
  END
  PATCH_IF ("%new_fx%" > 0) BEGIN
    WRITE_SHORT  0x70 ("%fx_num%" + "%new_fx%")
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN // adding new effects
      INSERT_BYTES            ("%fx_off%") 0x30
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" #48
    END
    // first new effect is transformed into protection from electricity icon
    WRITE_SHORT ("%fx_off%"       ) 142 // opcode: display portrait icon
    WRITE_SHORT ("%fx_off%" + 0x08) 27  // icon: protection from electricity
    // all other effects remain phsical mirror; adding projectile references below
    WRITE_LONG ("%fx_off%" + 0x08 + ( 1 * 0x30))  80
    WRITE_LONG ("%fx_off%" + 0x08 + ( 2 * 0x30))  81
    WRITE_LONG ("%fx_off%" + 0x08 + ( 3 * 0x30))  82
    WRITE_LONG ("%fx_off%" + 0x08 + ( 4 * 0x30))  83
    WRITE_LONG ("%fx_off%" + 0x08 + ( 5 * 0x30))  84
    WRITE_LONG ("%fx_off%" + 0x08 + ( 6 * 0x30)) 205
    WRITE_LONG ("%fx_off%" + 0x08 + ( 7 * 0x30)) 206
    WRITE_LONG ("%fx_off%" + 0x08 + ( 8 * 0x30)) 212
    WRITE_LONG ("%fx_off%" + 0x08 + ( 9 * 0x30)) 219
    WRITE_LONG ("%fx_off%" + 0x08 + (10 * 0x30)) ("%cdbehbla%" - 1)
    FOR (index3 = 0 ; index3 < abil_num ; index3 = index3 + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) ("%abil_fx_idx%" + "%new_fx%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Cloak of Mirroring also missing many spell immunity effects
COPY_EXISTING ~clck26.itm~   ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG  0x64 "ho" ELSE 0x72
    READ_SHORT 0x68 "hc" ELSE 0x00
    READ_LONG  0x6a "eo" ELSE 0x72
    READ_SHORT 0x6e "gi" ELSE 0x00
    READ_SHORT 0x70 "gc" ELSE 0x00
    SET "no" = ("eo" + (0x30 * ("gi" + "gc")))
    SET "ad" = 0x10
    INSERT_BYTES    "no"   (0x30 * "ad")
      WRITE_ASCIIT ("no" + (0x30 * 0x00) + 0x14) ~sppr302~  // Call Lightning
      WRITE_ASCIIT ("no" + (0x30 * 0x01) + 0x14) ~sppr304~  // Glyph of Warding
      WRITE_ASCIIT ("no" + (0x30 * 0x02) + 0x14) ~sppr313~  // Holy Smite
      WRITE_ASCIIT ("no" + (0x30 * 0x03) + 0x14) ~sppr314~  // Unholy Blight
      WRITE_ASCIIT ("no" + (0x30 * 0x04) + 0x14) ~spwi313~  // Skull Trap
      WRITE_ASCIIT ("no" + (0x30 * 0x05) + 0x14) ~spwi502~  // Cloud Kill
      WRITE_ASCII  ("no" + (0x30 * 0x06) + 0x14) ~sppr603d~ // Blade Barrier
      WRITE_ASCIIT ("no" + (0x30 * 0x07) + 0x14) ~spwi614~  // Death Fog
      WRITE_ASCIIT ("no" + (0x30 * 0x08) + 0x14) ~sppr705~  // Fire Storm
      WRITE_ASCII  ("no" + (0x30 * 0x09) + 0x14) ~sppr725d~ // Globe of Blades
      WRITE_ASCIIT ("no" + (0x30 * 0x0a) + 0x14) ~spwi712~  // Delayed Blast Fireball
      WRITE_ASCIIT ("no" + (0x30 * 0x0b) + 0x14) ~spwi810~  // Incendiary Cloud
      WRITE_ASCIIT ("no" + (0x30 * 0x0c) + 0x14) ~spwi911~  // Meteor Swarm
      WRITE_ASCII  ("no" + (0x30 * 0x0d) + 0x14) ~spwish25~ // Wish Meteor Swarm
      WRITE_ASCII  ("no" + (0x30 * 0x0e) + 0x14) ~spwish32~ // Wish Horrid Wilting
    FOR ("i" = 0; "i" < "ad"; "i" += 1) BEGIN
      WRITE_SHORT  ("no" + (0x30 * "i") + 0x00) 0xce       // immunity to spell
      WRITE_SHORT  ("no" + (0x30 * "i") + 0x02) 0x01       // target: self
      WRITE_LONG   ("no" + (0x30 * "i") + 0x04) ` 0x00     // strref displayed
      WRITE_LONG   ("no" + (0x30 * "i") + 0x08) 0x00       // useless
      WRITE_BYTE   ("no" + (0x30 * "i") + 0x0c) 0x02       // mode: while equipped
      WRITE_BYTE   ("no" + (0x30 * "i") + 0x12) 0x64       // minimum prob 100%
    END
    WRITE_SHORT  ("no" + (0x30 * 0x0f)       ) 142 // display portrait icon
    WRITE_LONG   ("no" + (0x30 * 0x0f) + 0x04)   0 // unused
    WRITE_LONG   ("no" + (0x30 * 0x0f) + 0x08)  28 // protection from magic
    WRITE_SHORT 0x70 ("gc" + "ad")
    PATCH_IF ("hc" > 0) THEN BEGIN
      FOR ("j" = 0; "j" < "hc"; "j" += 1) BEGIN
        READ_SHORT  ("ho" + (0x38 * "j") + 0x20) "ei"
        WRITE_SHORT ("ho" + (0x38 * "j") + 0x20) (("ei" = 0) ? 0x00 : ("ei" + "ad"))
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// changes soultaker dagger to a dagger type
COPY_EXISTING ~dagg10.itm~ ~override~
  WRITE_SHORT 0x1c 16
  BUT_ONLY_IF_IT_CHANGES

// shadow thief dagger has ranged APR effect though a melee weapon
COPY_EXISTING ~dagg18.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index%")) "opcode"
    PATCH_IF ("%opcode%" = 1) BEGIN // set attacks per round
      WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * "%index%")) 0 // probability = 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// marks dagger of <CHARNAME> as magical
COPY_EXISTING ~dagg19.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000) // add magical flag
  WRITE_LONG 0x60 1 // enchantment
  BUT_ONLY_IF_IT_CHANGES

// adds proper number of attacks for dart01, disallows str bonus
COPY_EXISTING ~dart01.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 1
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // looks for modify attacks per round
      SET "new_fx" = 0
    END
  END
  WHILE ("%abil_num%" > 0) BEGIN // looks for ranged ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  (0x20 + "%abil_off%" + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT (0x20 + "%abil_off%" + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
      WRITE_SHORT ("%abil_off%" + 0x1c + ("%abil_num%" * 0x38)) 4 // missile damage type
      WRITE_BYTE  ("%abil_off%" + 0x26 + ("%abil_num%" * 0x38)) 0 // disallow strength bonus
    END
  END
  PATCH_IF ("%new_fx%" = 1) BEGIN // no effect found, add one
    WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
    INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
      WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 1   // modify attacks per round
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 3   // 3 attacks
      WRITE_BYTE  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 1   // set
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  END
  BUT_ONLY_IF_IT_CHANGES

// some effects on dispel magic subject to MR, though all other effects are not; see also sppr303 et al patch
COPY_EXISTING ~deva.itm~     ~override~ // deva weapon
              ~devaevil.itm~ ~override~ // deva weapon
              ~elemchan.itm~ ~override~ // chan weapon
              ~elemcryo.itm~ ~override~ // cryomix weapon
              ~elemhydr.itm~ ~override~ // cryomix weapon
              ~elemimix.itm~ ~override~ // imix weapon
              ~elemogre.itm~ ~override~ // ogremoch weapon
              ~elemsunn.itm~ ~override~ // sunnis weapon
              ~elemyanc.itm~ ~override~ // yan-c-bin weapon
              ~elemzaam.itm~ ~override~ // zaaman rul weapon
              ~planetar.itm~ ~override~ // planetar weapon
              ~ravag01.itm~  ~override~ // ravager weapon
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF (("%opcode%" = 58) OR ("%opcode%" = 77) OR      // dispel fx, cure fm,
                  ("%opcode%" = 215) OR ("%opcode%" = 240)) BEGIN // play 3d effect, remove icon opcodes
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~dwchan01.itm~ ~override~ // drow adamantie chain +5
              ~dwchan02.itm~ ~override~ // drow adamantie chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
  WRITE_SHORT 0x42 75
  BUT_ONLY_IF_IT_CHANGES

// removal of extraneous vocalize effect
COPY_EXISTING ~dwsw1h01.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 48) BEGIN // sets extraneous vocalize effect to 0% probability
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // 0% chance
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// drow whips not actually using animations
COPY_EXISTING ~dwwhip.itm~   ~override~
              ~dwwhip01.itm~ ~override~
  WRITE_ASCII 0x22 "FL" #2
  BUT_ONLY_IF_IT_CHANGES
  
// energy blades using wrong power level for electrical damage
COPY_EXISTING ~eneblade.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // power 9
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~ENMACE.ITM~ ~override~
  SAY 0x8 @116
  SAY 0xc @116

// string fixes
COPY_EXISTING ~ENMORN.ITM~ ~override~
  SAY 0x8 @117
  SAY 0xc @117

// string fixes
COPY_EXISTING ~ENSW1H01.ITM~ ~override~
  SAY 0x8 @118
  SAY 0xc @118

// string fixes
COPY_EXISTING ~ENSW1H02.ITM~ ~override~
  SAY 0x8 @119
  SAY 0xc @119

// string fixes
COPY_EXISTING ~ENSW2H.ITM~ ~override~
  SAY 0x8 #6694
  SAY 0xc #6694

// familiar icon restorations
COPY_EXISTING ~FAMPSD.ITM~   ~override~
              ~FAMPSD25.ITM~ ~override~
              ~FAMFAIR.ITM~  ~override~
              ~FAMFAI25.ITM~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x3a ~FAMPSD~ #8
  END
  BUT_ONLY_IF_IT_CHANGES
  
// per descript flame blade is non-magical, does 1d4 slashing damage plus 1d2 + 4 fire damage
// actual item is magical, does 1d2 + 4 slashing damage plus 1d4 fire, and has a spurious thac0 bonus
COPY_EXISTING ~fblade.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BAND 0b10111111) // removes magical flag
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x14 + ("%index%" * 0x38)) 0 // thac0 bonus
      WRITE_SHORT ("%abil_off%" + 0x16 + ("%index%" * 0x38)) 4 // dice size, melee damage
      WRITE_SHORT ("%abil_off%" + 0x1a + ("%index%" * 0x38)) 0 // fixed melee damage
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for fire damage
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        READ_SHORT ("%fx_off%" + 0x0a + (("%abil_fx_idx%" + "%index2%") * 0x30)) "damage_type"
        PATCH_IF (("%opcode%" = 12) AND ("%damage_type%" = 8)) BEGIN // fire damage
          WRITE_LONG ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 4 // fixed fire damage
          WRITE_LONG ("%fx_off%" + 0x20 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2 // dice size, fire damage
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// hammer does slashing damage
COPY_EXISTING ~giafir.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT ("%abil_off%" + 0x1c + ("%index%" * 0x38)) 2 // crushing
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// giants don't have s2 animation
COPY_EXISTING ~giants01.itm~ ~override~
  WRITE_ASCII 0x22 ~AX~ #2 
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~globred2.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 5 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// golem immunities: hold, charm, fear, poison, backstab, sleep
COPY_EXISTING ~golbra.itm~   ~override~
              ~golcla.itm~   ~override~
              ~golfle.itm~   ~override~
              ~golmag01.itm~ ~override~
              ~golstone.itm~ ~override~
              ~irongol.itm~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off" ELSE 0
    READ_SHORT  0x68 "abil_num" ELSE 0
    READ_LONG   0x6a "fx_off"   ELSE 0
    READ_SHORT  0x70 "fx_num"   ELSE 0
    SET "fx_delta" = 0
    SET "hold" = 0
    SET "charm" = 0
    SET "fear" = 0
    SET "poison" = 0
    SET "sleep" = 0
    SET "backstab" = 0
    FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        ("%index2%" * 0x30)) "opcode"
      READ_SHORT ("%fx_off%" + 0x04 + ("%index2%" * 0x30)) "param1"
      READ_SHORT ("%fx_off%" + 0x08 + ("%index2%" * 0x30)) "param2"
      PATCH_IF ("%opcode%" = 101) BEGIN // immunity to opcode...
        PATCH_IF (("%param2%" = 109) OR ("%param2%" = 175) OR ("%param2%" = 185)) BEGIN // hold
          SET "hold" = 1
        END ELSE
        PATCH_IF ("%param2%" = 5) BEGIN // charm
          SET "charm" = 1
        END ELSE
        PATCH_IF (("%param2%" = 23) OR ("%param2%" = 24) OR ("%param2%" = 106)) BEGIN // fear
          SET "hold" = 1
        END ELSE
        PATCH_IF ("%param2%" = 25) BEGIN // poison
          SET "poison" = 1
        END ELSE
        PATCH_IF (("%param2%" = 39) OR ("%param2%" = 217)) BEGIN // sleep
          SET "sleep" = 1
        END
      END
      PATCH_IF ("%opcode%" = 292) BEGIN // immunity to backstab...
        SET "backstab" = 1
      END
    END
    // just add absic immunity, let immunity effects batches handle the rest
    PATCH_IF ("%hold%" = 0) BEGIN // insert hold immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08) 109 // hold
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%charm%" = 0) BEGIN // insert charm immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)   5 // charm
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%fear%" = 0) BEGIN // insert fear immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08) 106 // morale failure
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%poison%" = 0) BEGIN // insert poison immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)  25 // poison
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%sleep%" = 0) BEGIN // insert sleep immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)  39 // sleep
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%backstab%" = 0) BEGIN // insert backstab immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 292 // opcode: immunity to backstab
        WRITE_LONG  ("%fx_off%" + 0x08)   1 // must be 1
      SET "fx_delta" = "%fx_delta%" + 1
    END
    FOR (index3 = 0 ; index3 < fx_delta ; index3 = index3 + 1) BEGIN // set extra parameters for new effects
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%index3%" * 0x30))   1 // target: self
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%index3%" * 0x30))   2 // timing: instant/while equipped
      WRITE_LONG  ("%fx_off%" + 0x12 + ("%index3%" * 0x30)) 100 // probability
    END
    // adjust indexes on abilities
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%fx_delta%")
    END
    WRITE_SHORT 0x70 ("%fx_num%" + "%fx_delta%")
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~halb03.itm~ ~override~ // halberd +2
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES
  
// blackmist casting blindness at wrong power level with wrong projectile
COPY_EXISTING ~halb06.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 263 // fixes projectile
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" != 141) BEGIN  // everything except lighting fx
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 8 // power 8 (pw:blind)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wave should kill salamanders; salas are flagged incorrectly (fixed in creature racial patches) and wear ring95 which
// prevents slay opcode. Change wave to use an eff with Kill Target opcode instead.
COPY_EXISTING ~halb09.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x38 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 55) BEGIN // slay effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 177        // use eff opcode
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~death~ #8 // death.eff
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// borok's fist should use its own, unique icon
COPY_EXISTING ~hamm05.itm~ ~override~
  WRITE_ASCII 0x3a ~ihamm05~ #8
  WRITE_ASCII 0x58 ~chamm05~ #8
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // get ability icons, too
    WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~ihamm05~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// dwarven thrower: changes thrown icon, and fixes melee damage
COPY_EXISTING ~hamm06.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT  ("%abil_off%" + 0x1a + ("%abil_num%" * 0x38)) 3 // plus damage
    END ELSE
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) ~ihamm05~ #8 // thrown icon
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add ability to kill ettins to Crom
COPY_EXISTING ~hamm09.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 55   // slay
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 199  // ettin from
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 4    // race.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hastring didn't actually, umm, work and stuff.
COPY_EXISTING ~hastring.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // modify attacks per round
      WRITE_SHORT  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 1 // + one attack
      WRITE_SHORT  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 0 // increase/decrease
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Helm of Brilliance Sunray fix, icons
COPY_EXISTING ~helm16.itm~ ~override~
  WRITE_ASCII 0x3a ~ihelm16~ #8 // inventory icon
  WRITE_ASCII 0x58 ~chelm16~ #8 // description image
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for cast spell effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "spell"
        PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr707" = 0) AND ("%type1%" = 146)) BEGIN // cast spell, sppr707
          WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // target self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// to avoid double immune messages, cast spell opcodes should all use power 0
COPY_EXISTING ~helm16.itm~  ~override~
              ~helm17.itm~  ~override~
              ~staf11.itm~  ~override~
              ~staf13.itm~  ~override~
              ~sw1h31.itm~  ~override~
              ~sw1h51.itm~  ~override~
              ~wa2helm.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN  // cast spell
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // remove double interaction with spell protections
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wong-fei using wrong regen icon
COPY_EXISTING ~helm34.itm~  ~override~
  READ_LONG  0x6a "fx_off" ELSE 0
  READ_SHORT 0x70 "fx_num" ELSE 0
  FOR (index = 0 ; index < fx_num; index = index + 1) BEGIN // searches through global effects
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "icon"
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 56)) BEGIN // display regeneration icon
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 87 // change to regenerating
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// familiar attacks lack icons
COPY_EXISTING ~imp.itm~      ~override~ // imp soa
              ~impclaw.itm~  ~override~ // imp tob
              ~impqua.itm~   ~override~ // quasit soa
              ~quasclaw.itm~ ~override~ // quasit tob
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN
    WRITE_ASCII 0x3a ~iwolf~ #8
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~iwolf~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//removes poison ability from imp and quasit attacks
COPY_EXISTING ~imp.itm~     ~override~
              ~impqua.itm~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee ability
        WRITE_SHORT ("%abil_off%" + 0x16 + ("%abil_num%" * 0x38)) 6 // sets dice size to 6
        READ_SHORT ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "fx_idx"
        WHILE ("%fx_num%" > 0) BEGIN // sets prob = 0 to any effects that go with it
          SET "fx_num" = ("%fx_num%" - 1)
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%fx_idx%" + "%fx_num%") * 0x30)) 0
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// overrides zero-byte files in the biffs, if not overridden already
ACTION_IF NOT FILE_EXISTS ~override/iplot01k.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot01k.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04g.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04g.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04h.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04h.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04i.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04i.itm~
END

// changes to ipsion, which provides psionic protections for Mordy swords and ToB boneblades
COPY_EXISTING ~ipsion.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "stun_dupe" = 0
  SET "hold_dupe" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 101) BEGIN // immunity to stun or hold
      READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "param"
      PATCH_IF ("%param%" = 45) BEGIN
        PATCH_IF ("%stun_dupe%" = 0) BEGIN // if first effect
          SET "stun_dupe" = 1
        END ELSE BEGIN // if dupe effect
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 5 // change to charm
        END
      END ELSE
      PATCH_IF ("%param%" = 175) BEGIN
        PATCH_IF ("%hold_dupe%" = 0) BEGIN // if first effect
          SET "hold_dupe" = 1
        END ELSE BEGIN // if dupe effect
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%hold_dupe%" * 0x30)) 19 // change to inteligence modification
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enchantment correction for kuo-toan bolts
COPY_EXISTING ~KuoBolt2.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x60 2
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~leat03.itm~ ~override~ // protector of the second
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~leat06.itm~ ~override~ // studded leather of missile attraction
  WRITE_SHORT 0x42 100
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~melfmet.itm~  ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = 0x00; "i" < ("hc" * 0x38); "i" += 0x38) BEGIN
      READ_SHORT  ("ho" + "i" + 0x20) "ei"
      WRITE_SHORT ("ho" + "i" + 0x20) ("ei" + 0x02)
    END
    INSERT_BYTES  ("eo" + ("gc" * 0x30) + 0x00) (0x30 * 0x02)
      FOR ("j" = ("gc" * 0x30); "j" < (("gc" + 0x02) * 0x30); "j" += 0x30) BEGIN
        WRITE_SHORT ("eo" + "j" + 0x00) 0xce // opcode: protection from spell
        WRITE_BYTE  ("eo" + "j" + 0x02) 0x01 // target: self
        WRITE_LONG  ("eo" + "j" + 0x04) `0x0 // string displayed
        WRITE_BYTE  ("eo" + "j" + 0x0c) 0x02 // timing mode: while equipped
        WRITE_BYTE  ("eo" + "j" + 0x12) 0x64 // minimum probability 100%
      END
      WRITE_ASCII ("eo" + ("gc" * 0x30) + 0x14) ~spcl521d~ // resource reference
      WRITE_ASCII ("eo" + ("gc" * 0x30) + 0x44) ~spcl741d~ // resource reference
    WRITE_SHORT   0x70  ("gc" + 0x02)
  END
BUT_ONLY_IF_IT_CHANGES
  
// monk fists are inconsistent w/ descript
COPY_EXISTING ~mfist3.itm~ ~override~
              ~mfist6.itm~ ~override~
  READ_LONG   0x60 "enchantment" ELSE 0
  READ_LONG   0x64 "abil_off"    ELSE 0
  READ_SHORT  0x68 "abil_num"    ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x14 + ("%index%" * 0x38)) "%enchantment%" // sets thac0 bonus
      WRITE_SHORT ("%abil_off%" + 0x1a + ("%index%" * 0x38)) "%enchantment%" // sets damage bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~MFIST4.ITM~ ~override~
  SAY 0x8 @120
  SAY 0xc @120

// string fixes
COPY_EXISTING ~MFIST5.ITM~ ~override~
  SAY 0x8 @121
  SAY 0xc @121

// string fixes
COPY_EXISTING ~MFIST6.ITM~ ~override~
              ~MFIST7.ITM~ ~override~
  SAY 0x8 @122
  SAY 0xc @122

// string fixes
ACTION_IF FILE_EXISTS_IN_GAME ~mfist8.itm~ THEN BEGIN
  COPY_EXISTING ~MFIST8.ITM~ ~override~
    SAY 0x8 @123
    SAY 0xc @123
END

// int drain string from mind flayers showing up 300 seconds after occurring
COPY_EXISTING ~mindflay.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 139) BEGIN // look for display string
          WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // instant/permanent
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // no duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// minhp1 is not protecting from all types of possible death
COPY_EXISTING ~minhp1.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 27
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
  END 
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14021 // String Ref - ~Intelligence Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14024 // String Ref - ~Dexterity Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14029 // String Ref - ~Constitution Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14034 // String Ref - ~Charisma Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14042 // String Ref - ~Strength Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14782 // String Ref - ~Confused~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14791 // String Ref - ~Rigid Thinking~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14047 // String Ref - ~Wisdom Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 32089 // String Ref - ~Devour Brain~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40968 // String Ref - ~Two Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40969 // String Ref - ~Three Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40979 // String Ref - ~Four Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 41495 // String Ref - ~One Level Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 41616 // String Ref - ~Five Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 6     // charisma modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 10    // constitution modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 15    // dexterity modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 19    // intelligence modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 23    // morale modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 39    // unconciousness
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 44    // strength modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 49    // wisdom modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 76    // feeblemind
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 165   // pause target
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 210   // stun 90hp
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 241   // control creature
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 246   // berserk
  FOR (index = 0 ; index < new_fx ; index = index + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x02 + ("%index%" * 0x30)) 1   // target: self
    WRITE_BYTE ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE ("%fx_off%" + 0x12 + ("%index%" * 0x30)) 100 // probability
  END

// figurines were using some screwy system of reappearing that broke; should be using charges
COPY_EXISTING ~misc3d.itm~ ~override~ // golden lion
              ~misc3e.itm~ ~override~ // black spider
              ~misc3f.itm~ ~override~ // jade hound
              ~misc7t.itm~ ~override~ // moon dog
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical ability
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches for certain opcodes and sets prob = 0
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 122) OR ("%opcode%" = 123) OR ("%opcode%" = 139)) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// methlid's harp bugs
COPY_EXISTING ~misc3o.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index +1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 3) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  3)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 240  // remove icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 55   // stun
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 163  // free action
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 46   // unstun
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      SET "delta" = ("%delta%" + 3)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// portal key should be droppable
COPY_EXISTING ~misc4g.itm~ ~override~
  READ_BYTE 0x18 "flags"
  WRITE_BYTE "0x18" ("%flags%" BOR "0b00000100")
  BUT_ONLY_IF_IT_CHANGES

// changes to bastard sword proficiency
COPY_EXISTING ~misc4q.itm~ ~override~
  WRITE_BYTE  0x31 90
  BUT_ONLY_IF_IT_CHANGES

// changes to dagger proficiency
COPY_EXISTING ~misc4u.itm~ ~override~
              ~misc75.itm~ ~override~
  WRITE_BYTE  0x31 96
  BUT_ONLY_IF_IT_CHANGES

// adds staff prof for kobold staff
COPY_EXISTING ~misc5t.itm~ ~override~
  WRITE_BYTE 0x31 102
  BUT_ONLY_IF_IT_CHANGES

// harper pin supposed to be usable only by Jaheira
COPY_EXISTING ~misc5x.itm~ ~override~
  WRITE_BYTE 0x26 15 // min str
  WRITE_BYTE 0x2a 10 // min int
  WRITE_BYTE 0x2c 17 // min dex
  WRITE_BYTE 0x2e 14 // min wis
  WRITE_BYTE 0x30 17 // min con
  WRITE_BYTE 0x32 15 // min chr
  BUT_ONLY_IF_IT_CHANGES

// claw of kazgaroth equipping effects are disspellable
COPY_EXISTING ~misc72.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0; index < "%fx_num%"; index = index + 1) BEGIN // searches through global effects
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index%" * 0x30)) 2 // not dispel/not bypass
  END
  BUT_ONLY_IF_IT_CHANGES

// make horn of kazgaroth a quickslot item
COPY_EXISTING ~misc73.itm~ ~override~
  WRITE_SHORT 0x1c 0
  BUT_ONLY_IF_IT_CHANGES

// Boo gets a quickslot icon
COPY_EXISTING ~misc84.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WRITE_SHORT 0x68 ("%abil_num%" + 1)
  READ_LONG   0x6a "fx_off"
  WRITE_LONG  0x6a ("%fx_off%" + 0x38)
  READ_SHORT  0x70 "fx_num"
  INSERT_BYTES "%abil_off%" 0x38 // new ability
    WRITE_BYTE  ("%abil_off%"       ) 3          // magical ability
    WRITE_BYTE  ("%abil_off%" + 0x02) 3          // item slots
    WRITE_ASCII ("%abil_off%" + 0x04) ~imisc84~  // boo icon
    WRITE_SHORT ("%abil_off%" + 0x20) "%fx_num%" // fx index
  BUT_ONLY_IF_IT_CHANGES

// duration for illithid control circlet charm effect
COPY_EXISTING ~misc9x.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for charm creature
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 5) BEGIN // charm
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1800
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// blackrazor missing many effects
COPY_EXISTING ~miscbc.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 2)
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "patched" = 0
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) ("%abil_fx_num%" +  4)
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for str bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 44) BEGIN // str bonus
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 15 // probability
        END
      END
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142  // display icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 21   // strength
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + ("%abil_fx_idx%" * 0x30)) 20   // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 139  // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 14022 // strref "healed"
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142  // display icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 38   // haste
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + ("%abil_fx_idx%" * 0x30)) 20   // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 139  // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 40979 // strref "4 levels drained"
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      SET "patched" = 1
    END
    PATCH_IF ("%patched%" = 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + 2)
    END ELSE BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + 6)
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 7) BEGIN  // set item color
      WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0 // no dispel/bypass
    END
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_LONG  ("%fx_off%" + 0x08) 87   // regeneration
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_LONG  ("%fx_off%" + 0x08) 52   // mind shield
  SET "loops" = 2
  WHILE ("%loops%" > 0) BEGIN
    SET "loops" = ("%loops%" - 1)
    WRITE_SHORT ("%fx_off%"        + ("%loops%" * 0x30)) 142  // display icon
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%loops%" * 0x30)) 1    // target: self
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%loops%" * 0x30)) 2    // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%loops%" * 0x30)) 100  // probability
  END

// cloning Neb's dagger to make a version with no charges
COPY_EXISTING ~nebdag.itm~ ~override/cdnebdag.itm~
  SAY DESC @106
  WRITE_SHORT 0x42 0 // sets lore to zero for instant ID
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x22 + ("%abil_num%" * 0x38)) 0 // charges
      WRITE_BYTE  ("%abil_off%" + 0x24 + ("%abil_num%" * 0x38)) 1 // vanishes
      WRITE_BYTE  ("%abil_off%" + 0x25 + ("%abil_num%" * 0x38)) 0 // unknown (0)
      WHILE ("%abil_fx_num%" > 0) BEGIN // disables all melee effects
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability: 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// altering Neb's dagger to change to cdnebdag when charges run out
COPY_EXISTING ~nebdag.itm~ ~override~
  WRITE_ASCII 0x10 ~cdnebdag~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WRITE_BYTE  ("%abil_off%" + 0x24 + ("%abil_num%" * 0x38)) 2 // replace with used up when drained
      WRITE_BYTE  ("%abil_off%" + 0x27 + ("%abil_num%" * 0x38)) 1 // item does not recharge
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for slow effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 40) BEGIN // slow effect
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability: 0
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// disables arcane spellcasting; charm now handled in effects batch below
COPY_EXISTING ~npchan.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 1)
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 145 // disable spellcasting
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target:self
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// adds min stat requirements to Keldorn's armor
COPY_EXISTING ~npplat.itm~ ~override~
  WRITE_BYTE 0x2a 2  // min int
  WRITE_BYTE 0x2e 16 // min wis
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~NPSW02.ITM~ ~override~
  SAY 0x8 @124
  SAY 0xc @124
  BUT_ONLY_IF_IT_CHANGES

// Valygar's katana
COPY_EXISTING ~npsw04.itm~ ~override~
  WRITE_BYTE 0x2e 14 // min wis
  BUT_ONLY_IF_IT_CHANGES

// by Bioware naming convention, this item should be 4 enchantment
COPY_EXISTING ~p3-12m4.itm~ ~override~
  WRITE_LONG 0x60 4
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~plat02.itm~ ~override~ // plate mail +1
  WRITE_SHORT 0x42 40
  BUT_ONLY_IF_IT_CHANGES

// both full plate +1 don't disable thieving button, one has bad min str
COPY_EXISTING ~plat05.itm~ ~override~
              ~plat14.itm~ ~override~
  READ_LONG  0x6a "fx_off" ELSE 0
  READ_SHORT 0x70 "fx_num" ELSE 0
  WRITE_BYTE 0x26 15 // correct min str
  SET "count" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "param"
    PATCH_IF (("%opcode%" = 144) AND ("%param%" = 0)) BEGIN // disable stealth button
      PATCH_IF ("%count%" = 0) BEGIN // if first time, leave alone
        SET "count" = 1
      END ELSE BEGIN // if second, change to disable thieving button
        WRITE_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 1 // thieving button
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// three sets of full plate have extraneous movement rate and THAC0 penalties
COPY_EXISTING ~plat19.itm~ ~override~
              ~plat22.itm~ ~override~
              ~plat23.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x6a "fx_off"
    READ_SHORT 0x70 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "icon"
      PATCH_IF (("%type%" = 54) OR ("%type%" = 126)) BEGIN // movement rate or THAC0
        WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
      END ELSE
      PATCH_IF (("%type%" = 142) AND ("%icon%" = 26)) BEGIN // display portrait icon; a patch for plat22
        WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 16 // change resist fire/cold to protection from fire
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~plat23.itm~ ~override~ // full plate +2
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 75
  END
  BUT_ONLY_IF_IT_CHANGES

// Potion of Storm Giant Strength mis-targeted
COPY_EXISTING ~potn07.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through effects
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 44) BEGIN // str bonus
          WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// thrown oil of fiery burning shouldn't say 'gulp!', fix power levels
// oil of fiery burning damage incorrect
COPY_EXISTING ~potn13.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE  ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // should bypass spell protections
      PATCH_IF ("%opcode%" = 139) BEGIN  // display string
        WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // probability 0
      END
      PATCH_IF ("%opcode%" = 12) BEGIN // as long as we're here, fix duration
        WRITE_BYTE ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index%") * 0x30)) 0 // instant/perm effects should have 0 duration
        READ_BYTE  ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index%") * 0x30)) "save"
        PATCH_IF ("%save%" = 0) BEGIN // if not subject to save
          WRITE_LONG  ("%fx_off%" + 0x1c + (("%abil_fx_idx%" + "%index%") * 0x30)) 2 // two rolls...
          WRITE_LONG  ("%fx_off%" + 0x20 + (("%abil_fx_idx%" + "%index%") * 0x30)) 6 // of 6-sided die
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// potion of magic blocking should only block up to level 5 spells, per description
COPY_EXISTING ~potn33.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN //magical ability
      READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for immunity to spell level
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "level"
        PATCH_IF (("%opcode%" = 102) AND ("%level%" > 5)) BEGIN // immunity to spell level > 5
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // probability
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix errors; full free action batch effects handled below
COPY_EXISTING ~potn45.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" +        (0x28 * "%index%")) "type"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability only
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "fx_type"
        READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "immunity"
        PATCH_IF (("%fx_type%" = 101) AND ("%immunity%" = 5)) BEGIN // change charm immunity to haste immunity
          WRITE_LONG ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 16
        END ELSE
        PATCH_IF (("%fx_type%" = 101) AND ("%immunity%" = 45)) BEGIN // change stun immunity to hold immunity
          WRITE_LONG ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 175
        END ELSE
        PATCH_IF (("%fx_type%" = 142) OR ("%fx_type%" = 163)) BEGIN // display portrait icon for free action
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 600 // duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fire/air/earth control ring has screwy charm effects; changed to use eff targeting on class fire/air/earth elemental
COPY_EXISTING ~ring27.itm~ ~override~
              ~ring28.itm~ ~override~
              ~ring29.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE  ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    READ_ASCII ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) "icon"
    PATCH_IF (("%type%" = 3) AND 
             (("%icon%" STRING_COMPARE_CASE "spwi104b" = 0) OR      // fire control charm
              ("%icon%" STRING_COMPARE_CASE "sppr204b" = 0))) BEGIN // air control charm
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_num%" * 0x38)) 2 // range
      WRITE_BYTE  ("%abil_off%" + 0x27 + ("%abil_num%" * 0x38)) 8 // recharges after rest
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for slow effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 5) BEGIN // charm > use eff
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 177 // use eff
          PATCH_IF ("ring27" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // fire control ring
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 187 // fire elemental
          END ELSE
          PATCH_IF ("ring28" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // air control
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 186 // air elemental
          END ELSE
          PATCH_IF ("ring29" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // earth control
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 188 // earth elemental
          END
          WRITE_SHORT ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 5   // class
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~cdcmelem~ // new eff
          WRITE_LONG  ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // save v spells
          WRITE_LONG  ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 2   // save bonus
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// air control ring, adding new effects
COPY_EXISTING ~ring28.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  SET "loops" = 0
  SET "fx_new" = 0
  WHILE ("%abil_num%" > "%loops%") BEGIN // finds insert point and adjusts indices
    READ_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) ("%abil_fx_idx%" + "%fx_new%")
    READ_ASCII  ("%abil_off%" + 0x04 + ("%loops%" * 0x38)) "icon"
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "spwi405b" = 0) BEGIN // invisibiity ability
      SET "fx_new" = 5
      SET "fx_insert" = ("%fx_off%" + ("%abil_fx_idx%" * 0x30))
      READ_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) ("%abil_fx_num%" + "%fx_new%")
    END
    SET "loops" = ("%loops%" + 1)
  END
  WHILE ("%fx_new%" > 0) BEGIN
    SET "fx_new" = ("%fx_new%" - 1)
    INSERT_BYTES  ("%fx_insert%"       ) 0x30       // new effect
      WRITE_SHORT ("%fx_insert%"       ) ("%fx_new%" + 33) // save bonuses
      WRITE_BYTE  ("%fx_insert%" + 0x02) 1     // target:self
      WRITE_BYTE  ("%fx_insert%" + 0x03) 0     // power
      WRITE_LONG  ("%fx_insert%" + 0x04) 4     // value
      WRITE_BYTE  ("%fx_insert%" + 0x0d) 2     // dispel/not bypass
      WRITE_LONG  ("%fx_insert%" + 0x0e) 60    // duration
      WRITE_BYTE  ("%fx_insert%" + 0x12) 100   // probability
  END
  BUT_ONLY_IF_IT_CHANGES

// disables erroneous save effects from earth control ring
COPY_EXISTING ~ring29.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF (("%type%" > 32) AND ("%type%" < 38)) BEGIN // save bonuses
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ring of gaxx displays wrong icon
COPY_EXISTING ~ring39.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // need to change existing icon display
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "icon"
    PATCH_IF (("%type%" = 142) AND ("%icon%" = 28)) BEGIN // display protection from magic icon
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 63 // change to magic resistance
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rods02 requires lore; however it would make it un-id'd every time you switched back to the rod.
// So, clone it with 0 lore and have other items create the clone instead of the original
COPY_EXISTING ~rods02.itm~ ~override/rods02a.itm~ // zero-lore copy
  WRITE_SHORT 0x42 0
  
COPY_EXISTING ~rods02.itm~ ~override~ // assign lore to original
  WRITE_SHORT 0x42 70
  BUT_ONLY_IF_IT_CHANGES

// rod of smiting golem damage not set properly, should be in melee ability not global fx
COPY_EXISTING ~rods04.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
    READ_ASCII ("%fx_off%" + 0x14 + (0x30 * "%index2%")) "eff_file"
    PATCH_IF (("%opcode%" = 177) AND ("%eff_file%" STRING_COMPARE_CASE "smitgol1" = 0)) BEGIN
      READ_ASCII   ("%fx_off%" + (0x30 * "%index2%")) "clone_fx" (0x30) // reads effect
      DELETE_BYTES ("%fx_off%" + (0x30 * "%index2%")) 0x30 // deletes it
      SET "fx_num" = "%fx_num%" - 1
      WRITE_SHORT 0x70 "%fx_num%" // adjusts global fx number
      SET "index" = "%fx_num%" // kills loop
      SET "delta" = "%delta%" - 1
    END
  END
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%" // writes in cloned effect
        WRITE_BYTE            ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE            ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 0    // no dispel/bypass
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// change rod-created items to reference clone instead of original
COPY_EXISTING ~rodmace.itm~  ~override~
              ~rodspear.itm~ ~override~
              ~rodsword.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks through headers
    READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for create item effect
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "item"
      PATCH_IF (("%opcode%" = 122) AND ("%item%" STRING_COMPARE_CASE "rods02" = 0)) BEGIN // create rods02
        WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) ~rods02a~
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fix  
COPY_EXISTING ~rodspear.itm~ ~override~
  SAY 0x8 #7807
  SAY 0xc #7807

// string fix, color change
COPY_EXISTING ~rodsword.itm~ ~override~
  SAY 0x8 @115
  SAY 0xc @115
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 7) BEGIN // looks for set item color effect
      WRITE_LONG ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 115 // turns sword flaming
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fix
COPY_EXISTING ~rodmace.itm~ ~override~
  SAY 0x8 #7413
  SAY 0xc #7413

// item requires lore
COPY_EXISTING ~rods06.itm~ ~override~ // rod of reversal
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 85
  END
  BUT_ONLY_IF_IT_CHANGES

// spell failure effects not accompanied by spell failure icon
COPY_EXISTING ~scrl11.itm~   ~override~ // 100%, cursed scroll
  SET "abil_length" = 0x38
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  READ_SHORT 0x70 "fx_num"   ELSE 0
  SET "fx_type" = 0
  SET "new_fx_1" = 0
  SET "new_fx_2" = 0
  SET "delta" = 0
  FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
    READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
    PATCH_IF ("%opcode%" = 60) BEGIN // entangle overlay
      READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
      SET "new_fx_1" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
      SET "new_fx_2" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
      WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
    END
  END
  PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if spell failure effect but no icon
    INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
      WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
      WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
      WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 83        // spell failure
    SET "delta" = "%delta%" + 1
    SET "fx_num" = "%fx_num%" + 1
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    SET "new_fx_1" = 0 // reset for each loop through abilities
    SET "new_fx_2" = 0 // reset for each loop through abilities
    READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // miscast effects
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
      INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
        WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 83            // spell failure
      SET "delta" = "%delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// big batch o' scroll fixes (thanks devSin)        \\\\\
/////                                                  \\\\\

// scroll fixes: casting opcode
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
              ~scrla1.itm~ ~override~ // wizard eye
              ~scrla3.itm~ ~override~ // glitterdust
              ~scrla7.itm~ ~override~ // remove magic
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell (scroll)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: casting opcode
COPY_EXISTING ~scrl5b.itm~ ~override~ // defensive harmony
              ~scrl5d.itm~ ~override~ // protection from evil 10' radius
              ~scrlb4.itm~ ~override~ // wish
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell (scroll)
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 148) BEGIN // cast spell (scroll)
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 146 // opcode: cast spell
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: power
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl56.itm~ ~override~ // cure serious wounds
              ~scrl58.itm~ ~override~ // free action
              ~scrl59.itm~ ~override~ // neutralize poison
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl61.itm~ ~override~ // cure critical wounds
              ~scrl62.itm~ ~override~ // flame strike
              ~scrl63.itm~ ~override~ // raise dead
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0   // power
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: effects target
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl8y.itm~ ~override~ // protection from energy
              ~scrla8.itm~ ~override~ // contagion
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 1 // target: caster (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
              ~scrla1.itm~ ~override~ // wizard eye
              ~scrla3.itm~ ~override~ // glitterdust
              ~scrla7.itm~ ~override~ // remove magic
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // target: any point in range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl7m.itm~ ~override~ // true sight
              ~scrl80.itm~ ~override~ // shocking grasp
              ~scrlaj.itm~ ~override~ // farsight
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 5 // target: caster (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5c.itm~ ~override~ // protection from lightning
              ~scrl5k.itm~ ~override~ // spirit armor
              ~scrl9h.itm~ ~override~ // maze
              ~scrla8.itm~ ~override~ // contagion
              ~scrlak.itm~ ~override~ // remove curse
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 1 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl2f.itm~ ~override~ // cone of cold
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 12 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl70.itm~ ~override~ // color spray
              ~scrl8p.itm~ ~override~ // prismatic spray
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 15 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl8h.itm~ ~override~ // warding whip
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 20 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl6j.itm~ ~override~ // spell thrust
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 25 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl63.itm~ ~override~ // raise dead
              ~scrl76.itm~ ~override~ // infravision
              ~scrla1.itm~ ~override~ // wizard eye
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 30 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5f.itm~ ~override~ // chaotic commands
              ~scrl62.itm~ ~override~ // flame strike
              ~scrl6v.itm~ ~override~ // lower resistance
              ~scrla7.itm~ ~override~ // remove magic
              ~scrlAI.itm~ ~override~ // ray of enfeeblement
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 40 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5i.itm~ ~override~ // greater malison
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8c.itm~ ~override~ // stone to flesh
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 50 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrla6.itm~ ~override~ // spook
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 60 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from x scrolls not bypassing MR
COPY_EXISTING ~scrl03.itm~ ~override~
              ~scrl04.itm~ ~override~
              ~scrl05.itm~ ~override~
              ~scrl06.itm~ ~override~
              ~scrl08.itm~ ~override~
              ~scrl09.itm~ ~override~
              ~scrl15.itm~ ~override~
  SAY        0x08 #18094 // protection scroll
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  PATCH_IF ("%abil_num%" > 0) BEGIN // if abilities present, grabs last effect from last ability
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x38)) "last_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x38)) "last_fx_idx"
    SET "fx_num" = ("%last_fx_num%" + "%last_fx_idx%")
  END
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index%" * 0x30)) 3 // dispel/bypass resistance
  END
  BUT_ONLY_IF_IT_CHANGES

// dispel magic scroll uses priest description of spell
COPY_EXISTING ~scrl1e.itm~ ~override~
  SAY IDENTIFIED_DESC #45821 // mage dispel magic descript
  BUT_ONLY_IF_IT_CHANGES

// corrects BAM assignment for Conjure Lesser Fire Elemental scroll
COPY_EXISTING ~scrl6x.itm~ ~override~
  WRITE_ASCII 0x3a ~SPWI516A~  // inventory
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~SPWI516A~
  END
  BUT_ONLY_IF_IT_CHANGES

// melf's minute meteors' name
COPY_EXISTING ~scrla5.itm~ ~override~
  SAY NAME2 #38588
  BUT_ONLY_IF_IT_CHANGES

// misc spellhold scrolls should be category books, only allow 1 in stack
COPY_EXISTING ~scrla9.itm~  ~override~ // waneev's note
              ~scrlaa.itm~  ~override~ // waneev's note
              ~scrlab.itm~  ~override~ // monkey balls
              ~scrlac.itm~  ~override~ // amnish dragoon soup
              ~scrlad.itm~  ~override~ // baldur's delight
              ~scrlaf.itm~  ~override~ // ruby racks
              ~scrlag.itm~  ~override~ // crom faeyr scroll
              ~scrlhp.itm~  ~override~ // harper note
              ~scrlick.itm~ ~override~ // illithid correspndence
              ~scrlmz.itm~  ~override~ // note from Mazzy Fentan
  WRITE_SHORT 0x1c 37 // book
  WRITE_SHORT 0x38  1 // 1 max stack
  BUT_ONLY_IF_IT_CHANGES

// more crom faeyr changes: unique icon, make magical
COPY_EXISTING ~scrlAG.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
  WRITE_ASCII 0x3a ~IMISC6F~ #8
  WRITE_ASCII 0x58 ~CMISC6F~ #8

// ray of enfeeblement lacks casting icon due to typo
COPY_EXISTING ~scrlai.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 147) BEGIN // learn spell
        WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~spwi221a~ // icon (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// item requires lore
COPY_EXISTING ~shld17.itm~ ~override~ // buckler +1
  WRITE_SHORT 0x42 10
  BUT_ONLY_IF_IT_CHANGES

// small shields granting ac bonus v missiles and should not
COPY_EXISTING ~shld25.itm~  ~override~ // shield o' harmony
              ~shld28.itm~  ~override~ // small shield +2
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_BYTE  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "flag"
    PATCH_IF (("%opcode%" = 0) AND (("%flag%" BAND 0b00000010) = 0b00000010)) BEGIN
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%index%" * 0x30)) 0xfffffffd // -3
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shield of harmony stuff could be dispelled
COPY_EXISTING ~shld25.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0 // no dispel/bypass resistance
  END
  BUT_ONLY_IF_IT_CHANGES
  
// slay living using wrong power level for cosmetic visuals
COPY_EXISTING ~slaylive.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE  ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 141) BEGIN  // lighting effects
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~slng03.itm~ ~override~ // sling +3
  WRITE_SHORT 0x42 45
  BUT_ONLY_IF_IT_CHANGES

// spellhaunts have extraneous protection from spell effects
COPY_EXISTING ~spellh01.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    SET "delta" = 0
    FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
      PATCH_IF ("%opcode%" = 206) BEGIN
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * "%index2%")) "spell"
        PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr316" = 0) OR
                  ("%spell%" STRING_COMPARE_CASE "spwi315" = 0) OR
                  ("%spell%" STRING_COMPARE_CASE "spwi323" = 0)) BEGIN
          DELETE_BYTES ("%fx_off%" + (0x30 * "%index2%")) 0x30 // deletes it
          SET "fx_num" = "%fx_num%" - 1
          SET "delta" = "%delta%" - 1
          SET "index2" = "%index2%" - 1
        END
      END
    END
    WRITE_SHORT 0x70 "%fx_num%" // adjusts global fx number
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
      READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spear ranges
COPY_EXISTING ~sper02.itm~   ~override~ // spear +1
              ~sper03.itm~   ~override~ // spear +3 backbiter
              ~sper05.itm~   ~override~ // spear +2
              ~sper06.itm~   ~override~ // spear +3
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~sper08.itm~   ~override~ // spear +3 impaler
              ~sper09.itm~   ~override~ // spear +1 halcyon
              ~sper10.itm~   ~override~ // spear of withering +4
              ~sper11.itm~   ~override~ // ixil's nail +4
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spermel.itm~  ~override~ // melissan's spear
              ~tasloiil.itm~ ~override~ // spear
              ~waspear.itm~  ~override~ // spear of kuldahar +3
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 2 // range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~staf06.itm~ ~override~ // staff-mace
  WRITE_SHORT 0x42 25
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~staf07.itm~ ~override~ // staff-spear +2
  WRITE_SHORT 0x42 65
  BUT_ONLY_IF_IT_CHANGES

// disables erroneous save effects. healing bypass MR, and fixes enchanment
// fix power levels
COPY_EXISTING ~staf10.itm~ ~override~
  WRITE_LONG 0x60 1 // enchantment level
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // all healing effects should bypass MR
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 2 // power level
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 3 // dispel/bypass resistance
      END
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF (("%type%" > 32) AND ("%type%" < 38)) BEGIN // save bonuses
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// SotM needs a lot of rebuilding--dispel effects don't work in melee, several effects are
// mistargeted or dispellable, etc.
COPY_EXISTING ~staf11.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "loops" = "%fx_num%"
  WHILE ("%loops%" > 0) BEGIN
    SET "loops" = ("%loops%" - 1)
    READ_SHORT ("%fx_off%" +        ("%loops%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x08 + ("%loops%" * 0x30)) "icon"
    PATCH_IF ("%type%" != 20) BEGIN // everything except invisibility
      WRITE_BYTE ("%fx_off%" + 0x0d + ("%loops%" * 0x30)) 0 // no dispel/bypass resistance
    END
    PATCH_IF (("%type%" = 139) OR ("%type%" = 141)) BEGIN // lighting effects, display string
      WRITE_BYTE ("%fx_off%" + 0x02 + ("%loops%" * 0x30)) 1 // target: self
    END ELSE
    PATCH_IF (("%type%" = 142) AND ("%icon%" = 28)) BEGIN // display protection from magic icon
      WRITE_LONG ("%fx_off%" + 0x08 + ("%loops%" * 0x30)) 52 // mind shield
    END
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30
    WRITE_SHORT ("%fx_off%"       ) 100 // protection from creatue type
    WRITE_BYTE  ("%fx_off%" + 0x02) 1   // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 9   // summoned demon
    WRITE_LONG  ("%fx_off%" + 0x08) 7   // gender
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12) 100 // probability
  INSERT_BYTES  ("%fx_off%"       ) 0x30
    WRITE_SHORT ("%fx_off%"       ) 219 // protection from creatue type
    WRITE_BYTE  ("%fx_off%" + 0x02) 1   // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 3   // mask_evil
    WRITE_LONG  ("%fx_off%" + 0x08) 8   // from align.ids
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12) 100 // probability
  SET "delta" = 2
  WRITE_SHORT 0x70 ("%fx_num%" + "%delta%") // updates global fx total
  SET "loops" = 0
  WHILE ("%loops%" < "%abil_num%") BEGIN
    SET "delta1" = 0
    READ_BYTE  ("%abil_off%" +        ("%loops%" * 0x38)) "type"
    READ_ASCII ("%abil_off%" + 0x04 + ("%loops%" * 0x38)) "icon"
    READ_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
      SET "delta1" = (7 - "%abil_fx_num%")
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30   // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139    // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2      // target: preset target
        SAY         ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) #14056 // ~Dispel Effects~
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2      // not dispel/not bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1      // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100    // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 240  // remove icon 2
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 48   // feeblemind
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 77   // cure feeblemindedness
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215        // play 3d effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // play over target
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3          // dispel/bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spdispma~ // vvc file
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177        // use eff file
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 7          // illusionary
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 7          // gender
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1          // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2          // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~destself~ // eff file
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 58   // dispel effects
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2    // use specific level
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 141  // lighting effects
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4    // alteration: air
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
    END
    PATCH_IF (("%type%" = 3) AND ("%icon%" STRING_COMPARE_CASE "spwi902b" = 0)) BEGIN // magical, spell trap
      DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
      SET "delta1" = (1 - "%abil_fx_num%")
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30     // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146      // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1        // target: self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 9        // level
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 10       // cast at level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1        // cast instantly
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2        // not dispel/not bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 2400     // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100      // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~staf11~ // spell
    END
    SET "abil_fx_num" = ("%abil_fx_num%" + "%delta1%")
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "%abil_fx_num%"
    SET "delta" = ("%delta%" + "%delta1%")
    SET "loops" = ("%loops%" + 1)
  END

// Staff of Power should actually cast Globe of Invulnerability,
// not some shabby facsimile. Two icons also incorrect.
COPY_EXISTING ~staf12.itm~   ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_ASCIIT 0x3a ~istaf12~  // correcting inventory icon
    READ_LONG    0x64 "ho"
    READ_SHORT   0x68 "hc"
    READ_LONG    0x6a "eo"
    WRITE_ASCIIT ("ho" + (0x38 * 0x00) + 0x04) ~istaf12~ // melee icon
    WRITE_BYTE   ("ho" + (0x38 * 0x00) + 0x24) 0x00 // melee charges do not deplete
    FOR ("i" = 0; "i" < "hc"; "i" += 1) BEGIN
      READ_SHORT ("ho" + (0x38 * "i") + 0x1e) "ec"
      READ_SHORT ("ho" + (0x38 * "i") + 0x20) "ei"
      FOR ("j" = 0; "j" < "ec"; "j" += 1) BEGIN
        READ_SHORT ("eo" + (0x30 * ("j" + "ei")) + 0x00) "opcode"
        PATCH_IF (("opcode" = 0x66) AND ("ec" > 1)) THEN BEGIN
          SET "deleted" = ("ec" - 1)
          SET "ec" = 1
          WRITE_ASCII  ("ho" + (0x38 * "i" ) + 0x04)  ~spwi602b~ // Icon for Globe of Invulneribility
          WRITE_SHORT  ("ho" + (0x38 * "i" ) + 0x1e)  0x01 // one ability on this header
          DELETE_BYTES ("eo" + (0x30 * "ei") + 0x00)  (0x30 * "deleted")
          WRITE_SHORT  ("eo" + (0x30 * "ei") + 0x00)  0x92 // cast spell
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x04)  0x00 // use caster level
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x08)  0x00 // normal casting
          WRITE_BYTE   ("eo" + (0x30 * "ei") + 0x0c)  0x01 // timing: instant/permanent
          WRITE_BYTE   ("eo" + (0x30 * "ei") + 0x0d)  0x03 // dispel/bypass
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x0e)  0x00 // irrelevant duration
          WRITE_ASCIIT ("eo" + (0x30 * "ei") + 0x14)  ~spwi602~ // Globe of Invulneribility
          SET "k" = ("i" + 1)
          WHILE ("k" < "hc") BEGIN
            READ_SHORT  ("ho" + (0x38 * "k") + 0x20) "ci"
            WRITE_SHORT ("ho" + (0x38 * "k") + 0x20) ("ci" - "deleted")
            SET "k" += 1
          END // WHILE i3, repairing extended header indices
        END // PATCH_IF immunity to spell level located
      END // FOR index2, searching each header's abilities
    END // FOR index, searching extended headers
  END // PATCH_IF filesize sanity check
BUT_ONLY_IF_IT_CHANGES // no bad joke for the end of this patch

// stun on lightning-stun bypassing magical protections
COPY_EXISTING ~staf12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN  // cast spell
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // remove double interaction with spell protections
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 3 // power (lightning)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// staff of the woodlands
COPY_EXISTING ~staf14.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "new_fx" = 4
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) "icon"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%") // adding 4 global effects
    PATCH_IF (("%type%" = 3) AND ("%icon%" STRING_COMPARE_CASE "sppr204b" = 0)) BEGIN // magical, barkskin
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 142) BEGIN // display portrait icon
          WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // dispel/not bypass
        END
      END
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 0) BEGIN
      WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 16 // set base AC to 3
    END
  END
  WHILE ("%new_fx%" > 0) BEGIN
    SET "new_fx" = ("%new_fx%" - 1)
    INSERT_BYTES  ("%fx_off%"       ) 0x30       // new effect
      WRITE_SHORT ("%fx_off%"       ) ("%new_fx%" + 33) // save bonuses
      WRITE_BYTE  ("%fx_off%" + 0x02) 1     // target:self
      WRITE_LONG  ("%fx_off%" + 0x04) 1     // value
      WRITE_BYTE  ("%fx_off%" + 0x0c) 2     // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x0d) 2     // not dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12) 100   // probability
  END

// staff of the ram +6 missing listed 1d4 pierce damage
COPY_EXISTING ~staf22.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 12   // opcode: damage
        WRITE_BYTE            ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_SHORT           ("%fx_off%" + 0x0a + ("%abil_fx_idx%" * 0x30)) 16   // piercing damage
        WRITE_BYTE            ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE            ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
        WRITE_LONG            ("%fx_off%" + 0x1c + ("%abil_fx_idx%" * 0x30)) 1    // num dice
        WRITE_LONG            ("%fx_off%" + 0x20 + ("%abil_fx_idx%" * 0x30)) 4    // dice size
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~sw1h06.itm~ ~override~ // long sword +2 varscona
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES

// arbane's sword has extraneous effects and prevents the wrong string
COPY_EXISTING ~sw1h27.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "orig_fx" = "%fx_num%"
  SET "delta" = 0
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) "string"
    READ_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "parameter"
    PATCH_IF (
               ("%type%" = 296) OR // immunity to specific animation
               (
                 ("%type%" = 101) AND // immunity to stun, entangle, grease, web
                 (
                   ("%parameter%" =  45) OR
                   ("%parameter%" = 154) OR
                   ("%parameter%" = 157) OR
                   ("%parameter%" = 158)
                 )
               ) OR (
                ("%type%" = 169) AND // prevent stun, web portrait icons
                (
                  ("%parameter%" =  55) OR
                  ("%parameter%" = 129)
                )
               ) OR (
                ("%type%" = 267) AND ("%string%" = 1280) // disable display string: stunned
               )
             ) BEGIN
      DELETE_BYTES ("%fx_off%" + ("%fx_num%" * 0x30)) 0x30 // delete effect
      SET "delta" = ("%delta%" - 1)
    END
  END
  WRITE_SHORT 0x70 ("%orig_fx%" + "%delta%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%delta%")
  END
  BUT_ONLY_IF_IT_CHANGES
  
// dragonslayer missing regeneration portrait icon
COPY_EXISTING ~sw1h32.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "new_fx" = 1
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%") // adding new global effects
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_SHORT ("%fx_off%"       ) 142  // display icon
    WRITE_BYTE  ("%fx_off%" + 0x02) 1    // target:self
    WRITE_LONG  ("%fx_off%" + 0x08) 87   // regeneration
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2    // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x0d) 2    // not dispel/not bypass
    WRITE_BYTE  ("%fx_off%" + 0x12) 100  // probability

// adjatha's healing does not bypass MR and the sword has an incorrect strength requirement
COPY_EXISTING ~sw1h35.itm~ ~override~
  WRITE_BYTE 0x26 6
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // not dispel/bypass
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// flags wakizashi +1 as magical
COPY_EXISTING ~sw1h47.itm~ ~override~
  READ_BYTE "0x0018" "flags"
  WRITE_LONG "0x0018" (%flags% BOR 0b01000000)
  BUT_ONLY_IF_IT_CHANGES
  
// shazzelim's damage does not match description
COPY_EXISTING ~sw1h50.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT  ("%abil_off%" + 0x1a + ("%abil_num%" * 0x38)) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~sw1h51.itm~ ~override~ // celestial fury
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_ASCII  (0x04 + "%abil_off%" + ("%index%" * 0x38)) "icon"
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "spwi106b" = 0) BEGIN // blindness
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sw1h55.itm~ ~override~
  WRITE_ASCII 0x3a ~isw1h55~ #8 // inventory icon
  BUT_ONLY_IF_IT_CHANGES

// Habib's mighty scimitar
COPY_EXISTING ~sw1h57.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 111) BEGIN // create magical weapon
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 255 // create item in inventory
          WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // items in stack
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// foebane's LMD is bypassing MR
COPY_EXISTING ~sw1h63.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    SET "loops" = 0
    WHILE ("%loops%" < "%abil_num%") BEGIN
      SET "delta1" = 0
      READ_BYTE  ("%abil_off%" +        ("%loops%" * 0x38)) "type"
      READ_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
        SET "delta1" = (1 - "%abil_fx_num%")
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146        // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: self
          WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 1          // power
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 1          // cast at level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // cast instantly
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1          // dispel/not bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin104a~ // spell
      END
      SET "abil_fx_num" = ("%abil_fx_num%" + "%delta1%")
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "%abil_fx_num%"
      SET "delta" = ("%delta%" + "%delta1%")
      SET "loops" = ("%loops%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds party-friendly harbinger for c6eric and c6eric3
COPY_EXISTING ~sw2h07.itm~ ~override/cdsw2h07.itm~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "melee"
    PATCH_IF ("%melee%" = 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%fx_idx%" + "%fx_num%"))) "resource"
        PATCH_IF ((("%opcode%" = 146) AND ("spwi304" STRING_COMPARE_CASE "%resource%" = 0)) OR // cast fireball
                  (("%opcode%" = 174) AND ("misc_17b" STRING_COMPARE_CASE "%resource%" = 0))) BEGIN // play sound
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%fx_idx%" + "%fx_num%"))) 0 // sets probability to 0
        END
      END
    END
  END

// Soul Reaver's THAC0 drain should bypass MR
COPY_EXISTING ~sw2h08.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 54) BEGIN // THAC0 bonus
          WRITE_SHORT ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Carsomyr's dispel on hit effect is incorrect
COPY_EXISTING ~sw2h10.itm~ ~override~
              ~sw2h19.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
      READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        WRITE_BYTE  ("%abil_off%" + 0x01 + ("%index%" * 0x38)) 0  // no ID required for melee abilities
        WRITE_SHORT ("%abil_off%" + 0x16 + ("%index%" * 0x38)) 12 // sets dice size to 12
        DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
        SET "delta" = "%delta%" + 6 - "%abil_fx_num%"
        SET "abil_fx_num" = 6
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30   // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139    // display string
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2      // target: preset target
          SAY         ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) #14056 // ~Dispel Effects~
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2      // not dispel/not bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1      // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100    // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 240  // remove icon 2
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 48   // feeblemind
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 77   // cure feeblemindedness
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215        // play 3d effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // play over target
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3          // dispel/bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spdispma~ // vvc file
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177        // use eff file
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 7          // illusionary
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 7          // gender
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1          // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2          // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~destself~ // eff file
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 58   // dispel effects
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2    // use specific level
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      END ELSE
      PATCH_IF ("%type%" = 3) BEGIN // magic
        WRITE_BYTE  ("%abil_off%" + 0x01 + ("%index%" * 0x38)) 1  // ID required for magic abilities
        FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
          READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
          READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "spell"
          PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr303" = 0) AND ("%opcode%" = 146)) BEGIN // cast dispel magic
            WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell at point
            WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target self
            WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // change target on ability to any point in range
          END
        END
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// poison immunity for 'dead' trolls
COPY_EXISTING ~trolldie.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 2
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT (0x20 + "%abil_off%" + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
  END
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 101 // immunity to effect
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 25  // poison
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 173 // reduced damage from poison
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 100 // damage
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  BUT_ONLY_IF_IT_CHANGES

// Wand of heavens claims 8d6 damage; actually does 12d4; fix flame strike animation while we're here
COPY_EXISTING ~ttwand.itm~ ~override~
              ~wand11.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT  ("%abil_off%" + 0x1e + (0x38 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x38 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x38 * "%index%")) ("%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x2a + (0x38 * "%index%")) 1 // remove old flame strike projectile while we're here
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 12) BEGIN // damage
          WRITE_LONG ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // number of dice; only half since damage is split for save
          WRITE_LONG ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 6 // dice size
        END
        PATCH_IF ("%opcode%" = 215) BEGIN  // visuals should always play
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 5 // power (damage)
        END
      END
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "ttwand" = 0) BEGIN // wand11 already has play 3d effect opcodes
        SET "new_fx" = 2
        FOR (index3 = 0 ; index3 < new_fx ; index3 = index3 + 1) BEGIN
          INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
            WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215  // play 3d effect
            WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
            WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 4    // power = level
            WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent
            WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1    // dispel/not bypass
            WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
          PATCH_IF ("%index3%" = 0) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflast2~    // vvc file
          END ELSE BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflsrin~    // vvc file
          END
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + (0x38 * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sensate amulet should increase max HP and not current & max HP to close healing loophole
COPY_EXISTING ~wa2amu.itm~   ~override~
              ~waspear.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 18) BEGIN // max hp bonus
      WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 3 // increase max without increasing current
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Vhailor's simulcrum ability could fail on MR check
COPY_EXISTING ~wa2helm.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%fx_idx%" + "%fx_num%"))) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// since beholder lightning bolt is now a separate projectile, need to add protection in shield of balduran
COPY_EXISTING ~wa2shiel.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 197) BEGIN // looks for physical mirror
      READ_ASCII ("%fx_off%" + ("%index%" * 0x30)) "clone" (0x30) // clones effect
      SET "index" = "%fx_num%" // kills loop
      WRITE_SHORT  0x70 ("%fx_num%" + 1)
      INSERT_BYTES            ("%fx_off%"       ) 0x30
        WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%clone%" #48
        WRITE_LONG            ("%fx_off%" + 0x08) ("%cdbehbla%" - 1)
      FOR (index3 = 0 ; index3 < abil_num ; index3 = index3 + 1) BEGIN
        READ_SHORT  ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) "abil_fx_idx"
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) ("%abil_fx_idx%" + "%new_fx%")
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// jerrod's mace has incorrect eff assignments
COPY_EXISTING ~wamace.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // looking through effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT   ("%fx_off%" +        ("%fx_num%" * 0x30)) "opcode"
    READ_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) "eff"
    PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "wamacea" = 0)) BEGIN // use eff
      WRITE_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) ~damacea~ #8
    END ELSE
    PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "wamaceb" = 0)) BEGIN // use eff
      WRITE_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) ~damaceb~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wand o' heavens has no lore value
COPY_EXISTING ~wand11.itm~ ~override~
  WRITE_SHORT 0x42 50
  BUT_ONLY_IF_IT_CHANGES

// wand of wonder has incorrect max charges; causes it to be sold for 5x its value
COPY_EXISTING ~wand12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" +        ("%index%" * 0x38)) "abiltype"
    PATCH_IF ("%abiltype%" = 3) BEGIN // magical
      WRITE_SHORT ("%abil_off%" + 0x22 + ("%index%" * 0x38)) 50
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wand of cloudkill bypassing MR
COPY_EXISTING ~wand13.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 12) BEGIN // damage
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%fx_idx%" + "%fx_num%"))) 1 // dispel/not bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sling of everard is allowing strength bonus
COPY_EXISTING ~wasling.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
//      WRITE_SHORT ("%abil_off%" + 0x26 + (0x1a * "%abil_num%")) 3 // damage bonus
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x38 * "%abil_num%")) 0 // no strength bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// two xbows lacking min str requirements
COPY_EXISTING ~xbow15.itm~ ~override~
              ~xbow16.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x26 8
  END
  BUT_ONLY_IF_IT_CHANGES

//Comprehensive batch of weapon-speed fixes (Wisp)
ACTION_CLEAR_ARRAY fl#speed_item
ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#speed_item BEGIN
  AEGIS    => 1  //Aegis Fang
  AEGIS2   => 1  //Aegis Fang
  AX1H07   => 7  //Bala's Axe
  BOW25    => 4  //Long Bow +3
  DART01   => 2  //Dart
  MISC4U   => 2  //Embarl's Dagger
  MISC9Q   => 5  //Scimitar
  SPER03   => 6  //Spear +3, Backbiter
  SPER12   => 1  //Ixil's Spike +6
  STAF04   => 4  //Quarterstaff
  STAF05   => 1  //Staff of Striking
  STAF11   => 3  //Staff of the Magi
  STAF13   => 2  //Staff of Thunder and Lightning
  SW1H26   => 2  //Ilbratha +1
  SW1H53   => 4  //Sword of Flame +1
  SW1H69   => 1  //Spectral Brand +5
  SW2H03   => 10 //Cursed Berserking Sword +3
END

ACTION_PHP_EACH fl#speed_item AS item => speed BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%item%.itm" BEGIN
    COPY_EXISTING "%item%.itm" override
      READ_LONG 0x64 ao
      FOR (i=0;i<SHORT_AT 0x68;++i) BEGIN
        READ_BYTE ao + 0x38*i type
        PATCH_IF type = 1 OR type = 2 OR type = 4 BEGIN
          WRITE_SHORT ao + 0x38*i + 0x12 speed
        END
      END
    BUT_ONLY
  END
END

//Comprehensive (except for bow06) batch of item-weight fixes (Wisp)
ACTION_CLEAR_ARRAY fl#weight_item
ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#weight_item BEGIN
  BRAC15   => 2  //Bracers of Defense AC 3
  CLCK13   => 4  //Traveller's Robe
  DAGG05   => 1  //Throwing Dagger
  DWCHAN02 => 12 //Drow Adamantine Chain +5
  DWSHLD01 => 7  //Drow Shield +3
  SHLD23   => 3  //Fortress Shield +3
  SPER06   => 3  //Spear +3
  STAF04   => 4  //Quarterstaff
  STAF08   => 4  //Martial Staff +3
  STAF10   => 4  //Staff of Curing
  STAF11   => 4  //Staff of the Magi
  STAF13   => 4  //Staff of Thunder and Lightning
  STAF20   => 3  //Staff of Rynn +4
  SW1H15   => 4  //Scimitar +3, Frostbrand
  SW1H16   => 4  //Scimitar +5, Defender
  SW1H23   => 4  //Scimitar +2, Rashad's Talon
  SW1H32   => 3  //Dragonslayer
  SW2H03   => 15 //Cursed Berserking Sword +3
  SW2H12   => 10 //Flame Of The North
  SW2H15   => 15 //Silver Sword
END

ACTION_PHP_EACH fl#weight_item AS item => weight BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%item%.itm" BEGIN
    COPY_EXISTING "%item%.itm" override
      WRITE_LONG 0x4c weight
    BUT_ONLY
  END
END

/////                                                  \\\\\
///// spell fixes                                      \\\\\
/////                                                  \\\\\

// vamp touch fixes
COPY_EXISTING ~spin106.spl~ ~override/spin106a.spl~ // innate vamp touch
              ~spin106.spl~ ~override/spin106b.spl~ // innate vamp touch
              ~spin997.spl~ ~override/spin997a.spl~ // innate vamp touch
              ~spin997.spl~ ~override/spin997b.spl~ // innate vamp touch
              ~spwi314.spl~ ~override/spwi314a.spl~ // mage vamp touch
              ~spwi314.spl~ ~override/spwi314b.spl~ // mage vamp touch
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%DEST_RES%" STRING_COMPARE_REGEXP "^.+b$" = 0) BEGIN
    SET "self" = 1
  END ELSE BEGIN
    SET "self" = 0
  END
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = "%abil_fx_idx%" + "%fx_delta%"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%abil_num%")) 1 // removes projectile
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
      PATCH_IF ("%target%" = 2) BEGIN // preset target
        PATCH_IF ("%self%" = 0) BEGIN
          READ_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "dispel"
          PATCH_IF ("%dispel%" = 1) BEGIN // if dispel/not bypass
            WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3 // make dispel/bypass
          END ELSE
          PATCH_IF ("%dispel%" = 2) BEGIN // if not dispel/not bypass
            WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // make not dispel/bypass
          END
        END ELSE BEGIN
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "fx_delta" = "%fx_delta%" - 1
        END
      END ELSE
      PATCH_IF ("%target%" = 1) BEGIN // target: self
        PATCH_IF ("%self%" = 0) BEGIN // non-self spell
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "fx_delta" = "%fx_delta%" - 1
        END ELSE BEGIN
          READ_BYTE  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
          PATCH_IF ("%opcode%" = 206) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x1b + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~b~ // changes from spwi314 to spwi314b
          END
        END
      END
    END
    PATCH_IF ("%self%" = 0) BEGIN // if a, insert cast spell b
      INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0x30
        WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 146              // cast spell
        WRITE_BYTE   ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1                // target self
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "%min_lev%"      // cast at level
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1                // cast instantly
        WRITE_BYTE   ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 3                // dispel/bypass resistance
        WRITE_LONG   ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 300              // duration
        WRITE_BYTE   ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100              // probability
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) ~%SOURCE_RES%b~ // spell
      SET "abil_fx_num" = "%abil_fx_num%" + 1
      SET "fx_delta" = "%fx_delta%" + 1
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// larloch minor drain fixes
COPY_EXISTING ~spin104.spl~ ~override/spin104a.spl~ // innate LMD
              ~spwi119.spl~ ~override/spwi119a.spl~ // mage LMD
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
  READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
  SET "total_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%abil_num%")) 1 // removes projectile
  END
  WHILE ("%total_fx%" > 0) BEGIN
    SET "total_fx" = ("%total_fx%" - 1)
    READ_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) "dispel"
    PATCH_IF ("%dispel%" = 1) BEGIN // if dispel/not bypass
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) 3 // make dispel/bypass
    END ELSE
    PATCH_IF ("%dispel%" = 2) BEGIN // if not dispel/not bypass
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) 0 // make not dispel/bypass
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// innate LMD should do fixed damage of 4, not 1d4
COPY_EXISTING ~spin104a.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage opcode
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // fixed damage
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // number of dice
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes MR-checking "shell" spell that also eliminates self-cast exploit
COPY_EXISTING ~spin104.spl~ ~override~ // innate LMD
              ~spin106.spl~ ~override~ // innate vamp touch
              ~spin997.spl~ ~override~ // innate vamp touch
              ~spwi119.spl~ ~override~ // mage LMD
              ~spwi314.spl~ ~override~ // mage vamp touch
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  PATCH_IF ((~%SOURCE_RES%~ STRING_COMPARE_CASE "spin104" = 0) OR
            (~%SOURCE_RES%~ STRING_COMPARE_CASE "spwi119" = 0)) BEGIN
    SET "power" = 1
  END ELSE BEGIN
    SET "power" = 3
  END
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "level"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) 2
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) ("%abil_num%" * 2)
    DELETE_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%")  // deletes all effects
    INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // cast actual spell
      WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146             // cast spell
      WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2               // target: preset target
      WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) "%power%"       // power
      WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%level%"       // cast at level
      WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1               // cast instantly
      WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1               // instant/permanent
      WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1               // dispel/not bypass
      WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~ // spell
    INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // prevent self-casting
      WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206             // spell immunity
      WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1               // target: self
      WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 0               // power
      WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%~  // spell: self
  END
  PATCH_IF ("%fx_num%" > 0) BEGIN // eliminates global fx
    DELETE_BYTES "%fx_off%" (0x30 * "%fx_num%")
    WRITE_SHORT 0x70 0
  END
  BUT_ONLY_IF_IT_CHANGES

// spells using wrong power level
COPY_EXISTING ~sppr105.spl~ ~override~ // (entangle): one sound effect opcode is power 2.
              ~sppr210.spl~ ~override~ // (resist fire/cold): one display string at level 4 has power 0.
              ~sppr306.spl~ ~override~ // (protection from fire): The character color pulse effect at all levels is at power 1.
              ~sppr315.spl~ ~override~ // (cure medium wounds): remove intoxication is at power 0.
              ~sppr401.spl~ ~override~ // (cure serious wounds): remove intoxication is at power 0.
              ~sppr502.spl~ ~override~ // (cure critical wounds): remove intoxication at power 0, 'healed' string at power 6.
              ~sppr512.spl~ ~override~ // (greater command): visual effect on target at power 1
              ~sppr712.spl~ ~override~ // (resurrection): most of the 'remove spell' opcodes are at power 5.
              ~spwi106.spl~ ~override~ // (blindness): 'blinded' string at power 0
              ~spwi111.spl~ ~override~ // (infravision): 'infravision' string at power 0
              ~spwi113.spl~ ~override~ // (protection from evil): 'protected from evil' string at power 0
              ~spwi210.spl~ ~override~ // (resist fear): visual effect at power 1
              ~spwi223.spl~ ~override~ // (deafness): visual effects at power 1
              ~spwi224.spl~ ~override~ // (glitterdust): visual effect at power 4
              ~spwi410.spl~ ~override~ // (remove curse): save visual effect, all at power 3
              ~spwi414.spl~ ~override~ // (spirit armor): display string at power 3
              ~spwi613.spl~ ~override~ // (improved haste): all effects save one at power 3
              ~spwi711.spl~ ~override~ // (sphere of chaos): play sound at power 4
              ~spwi721.spl~ ~override~ // (mass invisibility): actual invisibility effects at power 4 (this error is propagated when the Fixpack clones this effect for its additional spell protections)
              ~spwi803.spl~ ~override~ // (protection from energy): visual effects at power 7
              ~spwi910.spl~ ~override~ // (imprisonment): visual effects at power 8
              ~spwi922.spl~ ~override~ // (dragon's breath): all effects at power 0
              ~spwi925.spl~ ~override~ // (comet): knockback at power 0, all others power 9
  READ_LONG  0x34 "level"    ELSE 0
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%level%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spells using wrong power level
COPY_EXISTING ~sppr303.spl~ ~override~ // (divine dispel magic) : all opcodes are power 0 except its visual effect and removing feeblemind, which are at 3. To work v. magic protections, all of these should be 0.
              ~spwi302.spl~ ~override~ // (remove magic): visual effect at power 3, all others at 0. Should add removal of feeblemind to this spell.
              ~spwi326.spl~ ~override~ // (arcane dispel magic) : all opcodes are power 0 except its visual effect and removing feeblemind, which are at 3. To work v. magic protections, all of these should be 0.
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// elven sleep/charm immunity
COPY_EXISTING ~beguile.spl~  ~override~ // beguiling gaze (demogorgon)
              ~demochm.spl~  ~override~ // demonic charm (demogorgon)
              ~spcl311.spl~  ~override~ // ranger charm animal
              ~spcl641.spl~  ~override~ // charm person or animal (unused?)
//            ~spcl751a.spl~ ~override~ // bard song (Jester kit)
              ~spin108.spl~  ~override~ // charm animal (elminster version)
              ~spin119.spl~  ~override~ // charm person (elminster version)
              ~spin553.spl~  ~override~ // nalmissra innate charm
              ~spin558.spl~  ~override~ // erinyes charm
//            ~spin775.spl~  ~override~ // psionic mind blast
//            ~spin802.spl~  ~override~ // mind cripple
              ~spin883.spl~  ~override~ // vampire domination
//            ~spin910.spl~  ~override~ // psionic domination
//            ~spin937.spl~  ~override~ // mephit color spray
//            ~spin940.spl~  ~override~ // mephit stinking cloud
              ~spin966.spl~  ~override~ // troll sleep
//            ~spin975.spl~  ~override~ // mind flayer domination
              ~spin980.spl~  ~override~ // beholder charm person
              ~spin985.spl~  ~override~ // beholder domination
              ~sppr102.spl~  ~override~ // command
              ~sppr204.spl~  ~override~ // charm person or mammal
//            ~sppr405.spl~  ~override~ // mental domination
              ~sppr512.spl~  ~override~ // greater command
              ~sppr982.spl~  ~override~ // dire charm (trap)
//            ~spwi004.spl~  ~override~ // stinking cloud (trap)
              ~spwi104.spl~  ~override~ // charm person
//            ~spwi105.spl~  ~override~ // color spray
              ~spwi116.spl~  ~override~ // sleep
//            ~spwi213.spl~  ~override~ // stinking cloud
              ~spwi316.spl~  ~override~ // dire charm
//            ~spwi411.spl~  ~override~ // emotion
              ~spwi506.spl~  ~override~ // domination
//            ~spwi711.spl~  ~override~ // sphere of chaos
              ~spwi929.spl~  ~override~ // succubus charm male
              ~spwi930.spl~  ~override~ // succubus charm female
              ~spwi943.spl~  ~override~ // sirine dire charm
              ~spwm179.spl~  ~override~ // wild surge charm
              ~spwm187.spl~  ~override~ // wild surge sleep
              ~urgekill.spl~ ~override~ // ravager charm
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x28
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 39) OR ("%opcode%" = 5)) BEGIN // if there's a sleep or charm opcode
        READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
        READ_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob1"
        READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob2"
        PATCH_IF ("%opcode%" = 5) BEGIN // if charm
          SET "new_fx" = 14
        END ELSE BEGIN
          SET "new_fx" = 10
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        FOR (index4 = 2 ; index4 < 4 ; index4 = index4 + 1) BEGIN
          FOR (index3 = 0 ; index3 < (("%new_fx%" / 2)) ; index3 = index3 + 1) BEGIN
            INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
              WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177           // use eff file
              WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) "%target%"    // preserve target
              WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%index4%"    // elf or half elf
              WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4             // race.ids
              WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) ("%prob2%" + ((21 - ("%index4%" * 6)) * ("%prob1%" - "%prob2%") / 10)) // 90%
              WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * "%abil_fx_idx%")) "%prob2%"     // base prob
              WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~cdelfcm%index3%~    // eff file
            PATCH_IF ("%opcode%" = 39) BEGIN
              WRITE_ASCII ("%fx_off%" + 0x19 + (0x30 * "%abil_fx_idx%")) ~sl~ #2 // eff file
            END
          END
        END
        SET "index2" = "%index2%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// spells to transform trolls back from dead to alive
COPY_EXISTING ~spin955.spl~ ~override/drshnl21.spl~
              ~spin955.spl~ ~override/eletro01.spl~
              ~spin955.spl~ ~override/kptrol13.spl~
              ~spin955.spl~ ~override/pptroll1.spl~
              ~spin955.spl~ ~override/sutroll.spl~
              ~spin955.spl~ ~override/torgal3.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 151) AND ("%eff_file%" STRING_COMPARE_CASE "troll01" = 0)) BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "%DEST_RES%" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// abazigal hurts himself when revelaing his dragon form due to bad targeting
COPY_EXISTING ~abzaway.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 8 // target: everyone except self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resurrection(s) trying to remove incorrect spell resource
COPY_EXISTING ~bhaal4a.spl~  ~override~
              ~spja01.spl~   ~override~
              ~sppr504.spl~  ~override~
              ~sppr712.spl~  ~override~
              ~sppr729.spl~  ~override~
              ~spwish10.spl~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spell"
      PATCH_IF (("%opcode%" = 172) AND ("%spell%" STRING_COMPARE_CASE "spwi126" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spin126"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// armor of faith not covering acid, cold, fire, electricity, doubles against missiles
COPY_EXISTING ~dgfaith.spl~ ~override~
              ~sppr111.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x28
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    SET "missile" = 0 // used to track dupe missile protection opcodes
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 89) AND ("%missile%" = 0)) BEGIN // first missile protection
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clones effect
        SET "missile" = 1
      END ELSE
      PATCH_IF ((("%opcode%" = 89) AND ("%missile%" = 1)) OR // dupe missile protection
                 ("%opcode%" = 84) OR                        // magic fire (unused)
                 ("%opcode%" = 85)) BEGIN                    // magic cold (unused)
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "delta" = ("%delta%" - 1)
          SET "index2" = ("%index2%" - 1)
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      END
    END
    FOR (index3 = 0 ; index3 < 4 ; index3 = index3 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) ~%clone%~         // use cloned missile resist
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (27 + "%index3%") // opcodes 27-30
    END
    SET "delta" = ("%delta%" + 4)
    SET "abil_fx_num" = ("%abil_fx_num%" + 4)
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon breath attacks missing vvc to play over victims
COPY_EXISTING ~drgrbrht.spl~ ~override~
              ~spin691.spl~  ~override~
              ~spin893.spl~  ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND 
                (("%resref%" STRING_COMPARE_CASE "spgdraim" = 0) OR
                 ("%resref%" STRING_COMPARE_CASE "spbdimsp" = 0))) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spsdimpa"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hallowed redeemer feedback should not summon CWs
COPY_EXISTING ~keldorn.spl~ ~override~
  WRITE_SHORT 0x1c 2 // priest spell
  READ_BYTE   0x1e "excl"
  WRITE_BYTE  0x1e ("%excl%" BAND 0b11111110) // removes conjurer flag to match regular fireshield
  WRITE_BYTE  0x22 0 // no casting animation
  WRITE_BYTE  0x27 2 // secondary type: specific protections
  BUT_ONLY_IF_IT_CHANGES

// tob spectator's geas missing sound
COPY_EXISTING ~senbehkd.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN // play sound
        WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// fixes expolit of casting restore on a simulcrum
COPY_EXISTING ~simulacr.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "loops" = 0
  SET "delta" = 0
  WHILE ("%loops%" < "%abil_num%") BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "abil_fx_idx"
    // first fix dispellability of existing effects
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x0d + (("%index2%" + "%abil_fx_idx%") * 0x30)) 0   // no dispel/bypass resistance
    END
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "%abil_fx_idx%"
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPWISH46~ #8 // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPWISH07~ #8 // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPPR713~ #8  // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPPR417~ #8  // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 101           // immunity to effect
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 224           // restoration
    FOR (index = 0x05; index > 0x00; index = index - 0x01) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x02 + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 1   // target: self
      WRITE_BYTE ("%fx_off%" + 0x0d + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 0   // no dispel/bypass resistance
      WRITE_LONG ("%fx_off%" + 0x0e + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 84  // duration
      WRITE_BYTE ("%fx_off%" + 0x12 + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 100 // probability
    END
    SET "delta1" = 5
    SET "delta" = ("%delta%" + "%delta1%")
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) ("%abil_fx_num%" + "%delta1%")
    SET "loops" = ("%loops%" + 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// many detect evil issues; new cddetevl projectile solves range issue; use a 'shell spell' trick to get proper MR checking
COPY ~bg2fixpack/spl/CDDETEVL.spl~ ~override~
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff

// miscast effects not accompanied by miscast icon
COPY_EXISTING ~spcl132.spl~  ~override~ // 25%, spell failure icon
              ~spin531.spl~  ~override~ // 90%, abazigal's shockwave
              ~sppr310.spl~  ~override~ // 80%, no icon
              ~sppr319.spl~  ~override~ // 50%, no icon
              ~sppr986.spl~  ~override~ // 80%, no icon
              ~spwish30.spl~ ~override~ // 80%, no icon
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    SET "abil_length" = 0x28
    READ_LONG  0x64 "abil_off" ELSE 0
    READ_SHORT 0x68 "abil_num" ELSE 0
    READ_LONG  0x6a "fx_off"   ELSE 0
    READ_SHORT 0x70 "fx_num"   ELSE 0
    SET "fx_type" = 0
    SET "new_fx_1" = 0
    SET "new_fx_2" = 0
    SET "delta" = 0
    FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
      READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // miscast effect
        READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
      INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
        WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
        WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 105       // miscast magic
      SET "delta" = "%delta%" + 1
      SET "fx_num" = "%fx_num%" + 1
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0 // reset for each loop through abilities
      SET "new_fx_2" = 0 // reset for each loop through abilities
      READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
        PATCH_IF ("%opcode%" = 60) BEGIN // miscast magic
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
          SET "new_fx_1" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 105           // miscast magic
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~spcl212.spl~ ~override~ // detect evil (paladin innate)
              ~spin120.spl~ ~override~ // detect evil (bhaalspawn innate)
//            ~spin696.spl~ ~override~ // moon dog sight
              ~sppr104.spl~ ~override~ // detect evil (cleric spell)
              ~spwi202.spl~ ~override~ // detect evil (mage spell)
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // loop through abilities
    WRITE_BYTE  ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 5            // target: caster
    WRITE_SHORT ("%abil_off%" + 0x26 + ("%index%" * 0x28)) "%CDDETEVL%" // custom projectile
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN // looks for effects for abilities
      READ_SHORT  ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 115) BEGIN // detect alignment
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 146        // opcode: cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2          // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0          // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1          // cast at level
        WRITE_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1          // cast instantly: yes
        WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) ~cddetevl~ // spell to cast
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// kit innate speed increases should not be prevented by free action
COPY_EXISTING ~spcl151.spl~ ~override~ // barbarian
              ~spcl812.spl~ ~override~ // monk i
              ~spcl813.spl~ ~override~ // monk ii
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 126) BEGIN // movement rate bonus
        WRITE_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 176
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// barbarian rage should be granting bonus to save v spell, not penalty
// removing stun icons & effects; see fx batches for the rest
COPY_EXISTING ~spcl152.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF ("%opcode%" = 37) BEGIN // save v magic
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone effect
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // should be a +2 bonus not -2 penalty
        SET "index2" = ("%abil_fx_num%" - 1) // kills loop, advances insert point to right before last effect
        FOR (index3 = 0 ; index3 < 2 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
            WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // use spell immunity as template
        END
        // write in opcodes and parameters for new effects
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%")))     46  // opcode: unstun
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%")))     1   // timing: instant/permanent
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 240 // opcode: remove icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 55  // icon: stun
        SET "fx_delta" = ("%fx_delta%" + 2)
        WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
 
// cavalier resist fear
COPY_EXISTING ~spcl222.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 3 // dispel/bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enrage's effects misordering prevents immunity to level drain strings; missing listed immunity to stun
COPY_EXISTING ~spcl321.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF (("%opcode%" = 206) AND ("%spell%" STRING_COMPARE_CASE "spcl321" = 0)) BEGIN // immunity to itself
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 240          // change to remove icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 55           // stun icon
        SET "index2" = "%abil_fx_num%" // kills loop, advances insert point to last effect
        FOR (index3 = 0 ; index3 < 4 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
            WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // use spell immunity as template
        END
        // write in opcodes and parameters for new effects
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 0))) 169 // opcode: prevent portrait icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 0))) 55  // icon: stun
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 45  // effect: stun
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 2))) 46  // opcode: unstun
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%" + 2))) 1   // timing: instant/permanent
        SET "fx_delta" = ("%fx_delta%" + 4)
        WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 4)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enrage cooldown--suppress name from dialogue window and making THAC0 penalty appear in the window
COPY_EXISTING ~spcl321d.spl~ ~override~
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "hitwindd" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 54  // thac0 bonus
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0xfffffffe // value (-2)
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // inc/dec
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 30  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
        SET "loops" = "%abil_fx_num%"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// all versions of ff should set variable
COPY_EXISTING ~spcl342.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 1)
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%" + 1)
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30       // new effect
    WRITE_SHORT ("%fx_off%"       ) 265        // set global
    WRITE_BYTE  ("%fx_off%" + 0x02) 1          // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 1          // value
    WRITE_BYTE  ("%fx_off%" + 0x0c) 1          // instant/perm
    WRITE_BYTE  ("%fx_off%" + 0x12) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x14) ~tutfam01~ // variable
  BUT_ONLY_IF_IT_CHANGES

// otilukes--use shell spell so all effects get applied; see also spcl415a.spl, spwi413a.spl
COPY_EXISTING ~spcl415.spl~ ~override~ // otiluke's sphere (special snare)
              ~spwi413.spl~ ~override~ // otiluke's sphere (arcane)
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BAND 0b11111011) // removes break invis flag
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "level"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    abil_fx_idx += fx_delta
    WRITE_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) abil_fx_idx
    PATCH_IF ((("%level%" = 16) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "spcl415" = 0)) OR // otilukes from snare
               ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi413" = 0)) BEGIN                   // otilukes from arcana
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_delta" = ("%fx_delta%" - "%abil_fx_num%" + 1)
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 1 // number of effects
      DELETE_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%")  // deletes all effects
      INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // cast actual spell
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146             // cast spell
        WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2               // target: preset target
        WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 4               // power
        WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0               // cast at level
        WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1               // cast instantly
        WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1               // instant/permanent
        WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1               // dispel/not bypass
        WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~ // spell
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// otiluke spell shell; see also spcl415.spl, spwi413.spl, spwi413a.spl
COPY_EXISTING ~spwi413a.spl~ ~override/spcl415a.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 42
    END
  END

// assassin and skald thac0 bonuses not displaying in character record
COPY_EXISTING ~spcl421.spl~  ~override~
              ~spcl541.spl~  ~override~
  PATCH_IF (%SOURCE_SIZE%>0x71)                             THEN BEGIN
    READ_LONG   0x64 "abil_off"     // extended header offset
    READ_SHORT  0x68 "abil_num"     // extended header count
    READ_LONG   0x6a "fx_off"       // feature table offset
    FOR ("i" = 0 ; "%i%" < "%abil_num%" ; "i" += 1)                      BEGIN
      READ_SHORT  ("%abil_off%" + (0x28 * "%i%") + 0x1e) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + (0x28 * "%i%") + 0x20) "abil_fx_idx"
      FOR ("j" = 0 ; "%j%" < "%abil_fx_num%" ; "j" += 1)                 BEGIN
        READ_SHORT ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%"))+0x00) "opcode"
        PATCH_IF ("%opcode%"=0xb1)                          THEN BEGIN
          WRITE_SHORT  ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x00) 0x116  // To-hit bonus
          WRITE_LONG   ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x04) 0x01   // modifier
          WRITE_LONG   ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x08) 0x00   // type: cumulative
          WRITE_ASCII  ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x14) ~~ #8 // nulling resref
        END //PATCH_IF use .eff file opcode located
      END // FOR j, scanning each header's abilities
    END // FOR i, scanning extended headers
  END // PATCH_IF filesize sanity check
  BUT_ONLY_IF_IT_CHANGES // COPY_EXISTING closed

// offensive spin fixes
COPY_EXISTING ~spcl521.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "hitplus2" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 54  // thac0 bonus
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // value
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // inc/dec
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 24  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
      END
      PATCH_IF ("%opcode%" = 16) BEGIN // replacing haste with immunity to haste
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 101 // immunity to effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // value
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 16  // haste
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 24  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
      END
    END
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 126 // movementrate bonus
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 200 // value
      WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2   // set to % of
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2   // not dispel/not bypass
      WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 24  // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100 // prob 1
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 1   // modify attacks per round
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 1   // 1 attack per 1 round
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2   // not dispel/not bypass
      WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 24  // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100 // prob 1
    SET "fx_delta" = ("%fx_delta%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// offensive spin/boon of lathander issues with MMM, part i, also see melfmet.itm
COPY_EXISTING ~spcl521.spl~  ~override/spcl521d.spl~
              ~spcl741.spl~  ~override/spcl741d.spl~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    SAY NAME1 #-1 SAY NAME2 #-1 // erase the name of the secondary spells to prevent feedback duplication
    WRITE_ASCIIT  0x10   ~~  // completion sound
    WRITE_SHORT   0x22  0x00 // casting graphics
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = "hc"; "i" > 0x00; "i" -= 0x01) BEGIN
      WRITE_LONG   ("ho" + (("i" - 0x01) * 0x28) + 0x12) 0x00 // casting time
      READ_SHORT   ("ho" + (("i" - 0x01) * 0x28) + 0x1e) "ec"
      READ_SHORT   ("ho" + (("i" - 0x01) * 0x28) + 0x20) "ei"
      WRITE_SHORT  ("ho" + (("i" - 0x01) * 0x28) + 0x1e) 0x02 //number of effects
      WRITE_SHORT  ("ho" + (("i" - 0x01) * 0x28) + 0x20) ("gc" + (("i" - 0x01) * 0x02))
      DELETE_BYTES ("eo" + ("ei" * 0x30) + 0x00) (("ec" - 0x02) * 0x30)
      WRITE_SHORT  ("eo" + ("ei" * 0x30) + 0x00) 0x01 // opcode: apr mod
      WRITE_BYTE   ("eo" + ("ei" * 0x30) + 0x02) 0x01 // target: self
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x04) 0x01 // modifier
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x08) 0x00 // type: cumulative
      WRITE_ASCIIT ("eo" + ("ei" * 0x30) + 0x14) ~~   // nulling resref
      WRITE_SHORT  ("eo" + ("ei" * 0x30) + 0x30) 0xce // opcode: protection from spell
      WRITE_BYTE   ("eo" + ("ei" * 0x30) + 0x32) 0x01 // target: self
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x34) `0x0 // string displayed
      WRITE_ASCIIT ("eo" + ("ei" * 0x30) + 0x44) ~spwi325~ // melf's meteors
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// offensive spin/boon of lathander issues with MMM, part ii, also see melfmet.itm
COPY_EXISTING ~spcl521.spl~  ~override/spcl521.spl~
              ~spcl741.spl~  ~override/spcl741.spl~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = 0x00; "i" < ("hc" * 0x28); "i" += 0x28) BEGIN
      READ_SHORT         ("ho" + "i" + 0x1e) "ec"
      READ_SHORT         ("ho" + "i" + 0x20) "ei"
      FOR  ("j" = ("ei" * 0x30); "j" < (("ei" + "ec") * 0x30); "j" += 0x30) BEGIN
        READ_SHORT       ("eo" + "j" + 0x00) "op"
        PATCH_IF (("op" = 0x10) OR ("op" = 0x01)) THEN BEGIN
          WRITE_SHORT    ("eo" + "j" + 0x00) 0x92 // opcode: cast spell
          WRITE_LONG     ("eo" + "j" + 0x04) 0x00 // cast at level
          WRITE_LONG     ("eo" + "j" + 0x08) 0x00 // cast normally
          WRITE_BYTE     ("eo" + "j" + 0x0c) 0x01 // timing mode: instant/permanent
          WRITE_LONG     ("eo" + "j" + 0x0e) 0x00 // duration
          PATCH_IF          (NOT "%SOURCE_RES%" STRING_COMPARE_CASE "spcl521") THEN BEGIN
            WRITE_ASCII  ("eo" + "j" + 0x14) ~spcl521d~ // resref
          END ELSE PATCH_IF (NOT "%SOURCE_RES%" STRING_COMPARE_CASE "spcl741") THEN BEGIN
            WRITE_ASCII  ("eo" + "j" + 0x14) ~spcl741d~ // resref
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// use shell spells for ApR modification to avoid issues with MMM; see melfmet.itm
COPY_EXISTING ~spcl521.spl~ ~override~ // offensive spin
              ~spcl741.spl~ ~override~ // boon of lathander
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
      PATCH_IF("%opcode%" = 1) BEGIN
        WRITE_SHORT  ("%fx_off%" +        (0x30 * "%index2%")) 146                // cast spell
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%index2%")) 1                  // cast instantly
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * "%index2%")) ~%SOURCE_RES%a~ #8 //resref
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// defensive spin fixes
COPY_EXISTING ~spcl522.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (loops = abil_fx_num ; loops > 0 ; loops = loops - 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) "opcode"
      PATCH_IF ("%opcode%" = 206) BEGIN // insert right before spell immunities
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
        SET "fx_delta" = ("%fx_delta%" + 1)
        INSERT_BYTES  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 0x30 // insert new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 101 // immunity to effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 1   // target self
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 126 // movement rate bonue
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 2   // not dispel/not bypass
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 24  // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 100 // prob 1
        SET "loops" = 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// greater/deathblow shouldn't be using quivering palm eff (allows spurious save)
COPY_EXISTING ~spcl902.spl~ ~override~ // deathblow
              ~spcl903.spl~ ~override~ // greater deathblow
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF ((("%opcode%" = 248) OR ("%opcode%" = 249)) AND ("%eff%" STRING_COMPARE_CASE "quivvis" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "%SOURCE_RES%a"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power attack not displaying string on ranged attacks
COPY_EXISTING ~spcl906.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 248) AND ("%eff_file%" STRING_COMPARE_CASE "spcl906b" = 0)) BEGIN // melee display string
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30)
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30             // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"     // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 249              // opcode
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hardiness missing high level headers
COPY_EXISTING ~spcl907.spl~  ~override~ // hardiness hla
              ~spwish12.spl~ ~override~ // hardiness via wish
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_SHORT ("%abil_off%" + 0x10 + (("%abil_num%" - 1) * 0x28)) "min_level" // min level of last ability header
    FOR (index = min_level + 2 ; index < 31 ; index = index + 2) BEGIN
      READ_ASCII ("%abil_off%" +        (("%abil_num%" - 1) * 0x28)) "abil_clone" (0x28) // reads last ability as block
      READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num" // reads number of fx from last ability
      READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx" // reads index of last effects from last ability
      // create effects for next level based off previous level effects
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // reads entire effect
        READ_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) "duration"        // duration
        INSERT_BYTES ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) "%clone_fx%" // clones effect
          PATCH_IF ("%duration%" > 5) BEGIN // if more than one round
            WRITE_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) ("%duration%" + 6) // duration + round
          END
      END
      // effects created, now add new ability
      INSERT_BYTES            ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28
        WRITE_EVALUATED_ASCII ("%abil_off%" +        ("%abil_num%" * 0x28)) "%abil_clone%" // clones last ability
        WRITE_SHORT           ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) "%index%"      // min level
        WRITE_SHORT           ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) ("%abil_fx_num%" + "%abil_fx_idx%") // corrects fx index
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = "%abil_num%" + 1
    END
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a "%fx_off%"
  END
  BUT_ONLY_IF_IT_CHANGES

// ranger tracking
COPY_EXISTING ~spcl922.spl~  ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 171) BEGIN // give innate
        READ_ASCII              ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%"
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 172 // remove spell
        SET "index2" = "%index2%" + 1
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// chromatic orb has a few incorrect targets and MR checks
COPY_EXISTING ~spdr101.spl~ ~override~ // chromatic orb, stalker version
              ~spwi118.spl~ ~override~ // chromatic orb, wiz version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%abil_num%")) 90 // corrects range
    PATCH_IF (("%min_lev%" = 1) OR ("%min_lev%" = 5) OR ("%min_lev%" = 10) OR ("%min_lev%" = 12)) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
        PATCH_IF (("%duration%" > 5) AND ("%min_lev%" = 1)) BEGIN // fix level 1 durations
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 6
        END
        PATCH_IF (("%duration%" > 5) AND ("%min_lev%" = 5)) BEGIN // fix level 5 durations, power
          WRITE_LONG  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%")))  1 // power
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 18 // duration
        END
        PATCH_IF ("%opcode%" = 0) BEGIN // armor class penalty
          WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2 // target: preset target
        END ELSE
        PATCH_IF (("%opcode%" = 139) OR ("%opcode%" = 142)) BEGIN // display portrait icon or display string
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // dispel/not bypass
        END ELSE
        PATCH_IF ("%opcode%" = 55) BEGIN // slay
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2 // not dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING /* ~spin101.spl~ ~override~ // clw, innate */
              ~sppr310.spl~ ~override~ // miscast magic
              ~sppr311.spl~ ~override~ // rigid thinking
              ~sppr403.spl~ ~override~ // free action
              ~sppr717.spl~ ~override~ // creeping doom
              ~spwi504.spl~ ~override~ // mon summoning iii
              ~spwi522.spl~ ~override~ // minor spell turning
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 5
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING /* ~spin103.spl~ ~override~ // duhm innate */
              /* ~spin105.spl~ ~override~ // innate horror */
              ~sppr104.spl~ ~override~ // detect evil
              ~spwi211.spl~ ~override~ // melf's acid arrow
              ~sppr214.spl~ ~override~ // duhm divine
              ~spwi505.spl~ ~override~ // shadow door
              ~spwi511.spl~ ~override~ // protection from normal weapons
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 2
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spin104.spl~ ~override~ // innate lmd
              ~spwi402.spl~ ~override~ // dimension door
              ~spwi408.spl~ ~override~ // stoneskin
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 1
  END
  BUT_ONLY_IF_IT_CHANGES

// removing horror's undocumented save bonus
COPY_EXISTING ~spin105.spl~  ~override~ // bhaalspawn innate horror
              ~spwi205.spl~  ~override~ // wizard spell horror
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index"=0 ; "%index%" < "%abil_num%" ; "index"= ("%index%" + 1)) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28*"%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28*"%index%")) "abil_fx_idx"
    FOR ("index2"=0 ; "%index2%" < "%abil_fx_num%" ; "index2" = ("%index2%" + 1)) BEGIN
      READ_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "savebonus"
      PATCH_IF  ("%savebonus%" != 0) BEGIN // saving throw bonus shouldn't be there
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0
      END // end PATCH_IF for saving throw bonus
    END // end FOR index2 for reading each ability
  END // end FOR index for reading each extended header
  BUT_ONLY_IF_IT_CHANGES

// summon dread wolf referring to non-existant BG reference
COPY_EXISTING ~spin114.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ( index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 67) BEGIN // summon creature
        WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~wolfdr01~ #8
        SET "index2" = "%abil_fx_num%" // kills fx loop
        SET "index" = "%abil_num%" // kills abil loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// abazigal's shockwave miscast effects
COPY_EXISTING ~spin531.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 60) BEGIN // if miscast magic
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 90
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hive mother anti-magic ray not affecting divine spellcasting
COPY_EXISTING ~spin550.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 60) BEGIN // if miscast magic
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 100
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// spell failure effects not accompanied by spell failure icon
COPY_EXISTING ~spin550.spl~  ~override~ // 100%, need to fix divine, includes innates
              ~spin646.spl~  ~override~ // 100%, anti-magic zone type
              ~spin689.spl~  ~override~ // 100%, has miscast
              ~spin712.spl~  ~override~ // 100%, sets attacks to 0
              ~spin731.spl~  ~override~ // 100%, party-wide
              ~spin779.spl~  ~override~ // 100%, already has spell failure icon
              ~spin992.spl~  ~override~ // 100%, no icon
              ~sppr517.spl~  ~override~ // 100%, no icon
              ~sppr717.spl~  ~override~ // 100%, no icon
              ~spwm128.spl~  ~override~ // 100%, no icon
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    SET "abil_length" = 0x28
    READ_LONG  0x64 "abil_off" ELSE 0
    READ_SHORT 0x68 "abil_num" ELSE 0
    READ_LONG  0x6a "fx_off"   ELSE 0
    READ_SHORT 0x70 "fx_num"   ELSE 0
    SET "fx_type" = 0
    SET "new_fx_1" = 0
    SET "new_fx_2" = 0
    SET "delta" = 0
    FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
      READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // entangle overlay
        READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if spell failure effect but no icon
      INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
        WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
        WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 83        // spell failure
      SET "delta" = "%delta%" + 1
      SET "fx_num" = "%fx_num%" + 1
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0 // reset for each loop through abilities
      SET "new_fx_2" = 0 // reset for each loop through abilities
      READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
        PATCH_IF ("%opcode%" = 60) BEGIN // miscast effects
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
          SET "new_fx_1" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 83            // spell failure
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// anti-magic should destroy magically created items
COPY_EXISTING ~spin550.spl~ ~override~ // hive mother anti-magic ray
              ~spin779.spl~ ~override~ // anti-magic zone
              ~spin992.spl~ ~override~ // beholder anti-magic ray
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "loops" = 0
    SET "delta" = 0
    WHILE ("%loops%" < "%abil_num%") BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "%abil_fx_idx%"
      FOR ("index" = "%abil_fx_num%" ; "%index%" > 0; "index" = ("%index%" - 1)) BEGIN // look for remove item opcode
        READ_SHORT ("%fx_off%" + (0x30 * (("%index%" - 1) + "%abil_fx_idx%"))) "opcode"
        PATCH_IF ("%opcode%" = 112) BEGIN
          READ_ASCII ("%fx_off%" + (0x30 * (("%index%" - 1) + "%abil_fx_idx%"))) "effect" (0x30)
          SET "new_fx"  = 17
          SET "index" = 0
        END
      END
      WHILE ("%new_fx%" > 0) BEGIN
        SET "new_fx"  = ("%new_fx%" - 1)
        INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%effect%"
      END
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"     ))) ~BLAKBLAD~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  1))) ~ENEBLADE~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  2))) ~ENMACE~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  3))) ~ENMORN~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  4))) ~ENSTAFF~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  5))) ~ENSW1H01~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  6))) ~ENSW1H02~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  7))) ~ENSW2H~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  8))) ~GBERRY~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  9))) ~GBERRY2~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 10))) ~GBERRY3~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 11))) ~GBERRY4~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 12))) ~GBERRY5~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 13))) ~GBERRY6~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 14))) ~GBERRY7~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 15))) ~PHANBLAD~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 16))) ~SHAKTI1~ #8
      SET "delta" = ("%delta%" + 17)
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) ("%abil_fx_num%" + 17)
      SET "loops" = ("%loops%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// change old lightning spbehbla.pro spells to new cdbehbla.pro projectile
COPY_EXISTING ~spin579.spl~ ~override~ // power_amp
              ~spin989.spl~ ~override~ // beholder_lightning_bolt
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) "%cdbehbla%"
  END
  BUT_ONLY_IF_IT_CHANGES

// imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spwi917.spl
COPY_EXISTING ~spin580.spl~ ~override~
              ~spin626.spl~ ~override~
              ~spin788.spl~ ~override~
              ~spwi910.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 211) BEGIN // imprisonment
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones imprisonment effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 177           // use eff file
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   6           // summoned (6)...
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   7           // from gender.ids
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~cdwi910~ #8  // eff resref
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// xp effect not being applied with correct timing
COPY_EXISTING ~spin607.spl~ ~override~
              ~spin640.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 104) BEGIN // xp bonus
        WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // timing mode
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// talons icon eff has different timing than other effects
COPY_EXISTING ~spin613.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 283) AND ("%eff_file%" STRING_COMPARE_CASE "deck613a" = 0)) BEGIN // use deck613a.eff as curse
        WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // timing mode
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// deck of many things, moon spell
COPY_EXISTING ~spin618.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          PATCH_IF ("%opcode%" = 18) BEGIN // max hp bonus
            WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // increase/decrease
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// deck of many things, emperor spell
COPY_EXISTING ~spin632.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          PATCH_IF (("%opcode%" = 101) OR ("%opcode%" = 174)) BEGIN // play sound or immunity
            WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 50400 // duration seven days
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// familiars and summons should be pushed back when hell door opens, part 2/2 (see cut85a.bcs)
COPY_EXISTING ~spin658.spl~ ~override~
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
    SET "fx_num" = ("%abil_fx_idx%" + "%abil_fx_num%")
  END ELSE BEGIN
    READ_SHORT 0x70 "fx_num"
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" + 0x02 + (0x30 * "%fx_num%")) "target"
    PATCH_IF ("%target%" = 2) BEGIN // change target: preset target to
      WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * "%fx_num%")) 4 // everyone
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// edwina > edwin fixes
COPY_EXISTING ~spin661.spl~ ~override~
              ~spin662.spl~ ~override~
              ~spin916.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 71) BEGIN // change sex
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// Edwin's Nether Scroll bonuses; removes spurious save check on play sound and changes effects to bypass MR
COPY_EXISTING ~spin664.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no dispel/bypass
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 174) BEGIN // play sound
          WRITE_LONG ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no save
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Anomen's title change; effects should be permanent and persist through resurrection
COPY_EXISTING ~spin678.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// entangle effects not setting entangle icon
COPY_EXISTING ~spin688.spl~ ~override~
              ~spwm111.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 154) BEGIN // entangle overlay
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones entangle effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 144           // entangled
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// fix icon for moon dog's true sight
COPY_EXISTING ~spin696.spl~ ~override~
  WRITE_ASCII 0x3a ~SPWI609C~ #8
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_ASCII ("%abil_off%" + 0x04 + (0x28 * "%abil_num%")) ~SPWI609B~ // icon fix
  END
  BUT_ONLY_IF_IT_CHANGES

// hell spell fixes; change alignment deferred to teardoor and ar2900 scripts and wrong timing on bonuses
COPY_EXISTING ~spin747.spl~ ~override~ // selfish, evil
              ~spin749.spl~ ~override~ // wrath, evil
              ~spin750.spl~ ~override~ // wrath, good
              ~spin751.spl~ ~override~ // pride, evil
              ~spin753.spl~ ~override~ // fear, evil
              ~spin755.spl~ ~override~ // greed, evil
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 57) BEGIN // change alignment
          WRITE_LONG ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // probability: zero
        END
        PATCH_IF (("%opcode%" = 6)  OR ("%opcode%" = 10)  OR ("%opcode%" = 44) // CHR/CON/STR bonus
               OR ("%opcode%" = 49) OR ("%opcode%" = 104) OR ("%opcode%" = 108)) BEGIN // WIS/XP bonus, rep change
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // timing: inst/perm
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hell selfish penalties should be schoolless, bypass MR
COPY_EXISTING ~spin765.spl~ ~override~ // hell_lose xp
              ~spin766.spl~ ~override~ // hell_lose_dex
              ~spin767.spl~ ~override~ // hell_lose_hp
              ~spin768.spl~ ~override~ // hell_dispell [sic]
//              ~spin769.spl~ ~override~ // hell_hold, next
              ~spin770.spl~ ~override~ // hell_explode
              ~spin771.spl~ ~override~ // hell_damage_half
  WRITE_SHORT 0x25 0 // no primary type
  WRITE_SHORT 0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // go through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0 // no dispel/bypass MR
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hell selfish penalties should be schoolless, bypass MR-- hold is special; needs to be dispellable by demon
COPY_EXISTING ~spin769.spl~ ~override~ // hell_hold
  WRITE_SHORT 0x25 0 // no primary type
  WRITE_SHORT 0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206       // play 3d effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2         // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/permanent
        WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3         // dispel/bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100       // probability
    END
    WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%"    ))) ~sppr303~ // priest dispel magic
    WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 1))) ~spwi326~ // mage dispel magic
    SET "fx_delta" = "%fx_delta%" + 2
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES
  
// fear spell in fear hell trial can generate spurious MR messages and not play sound at end of spell duration
COPY_EXISTING ~spin772.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN // damage
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // no dispel/bypass mr
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// slayer change - investigate further
// typo in resource references
COPY_EXISTING ~spin783.spl~ ~override~
              ~spin852.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND ("%resref%" STRING_COMPARE_CASE "sparmor" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spsarmor" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// use new flame strike animation, not the old one
COPY_EXISTING ~spin799.spl~  ~override~ // dace's flame strike
              ~sppr985.spl~  ~override~ // trap flamestrike
              ~spwi979.spl~  ~override~ // sarevok_strike
              ~spwm186.spl~  ~override~ // wild surge charm--was using flame strike anim
  READ_LONG  0x34 "level"
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    READ_SHORT  ("%abil_off%" + 0x26 + (0x28 * "%index%")) "proj" // check projectile
    PATCH_IF ("%proj%" = 67) BEGIN
      SET "new_fx" = 2
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove old flame strike projectile and use effects instead
      FOR (index3 = 0 ; index3 < new_fx ; index3 = index3 + 1) BEGIN
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215       // play 3d effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2         // target: preset target
          WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) "%level%" // power = level
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/permanent
          WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1         // dispel/not bypass
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100       // probability
        PATCH_IF ("%index3%" = 0) BEGIN
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflast2~    // vvc file
        END ELSE BEGIN
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflsrin~    // vvc file
        END
      END
      SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      SET "fx_delta" = ("%fx_delta%" + "%new_fx%")
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// City of Caverns party heal before ettin and Illithid/Ularthid heal failed due to poor MR checks
COPY_EXISTING ~spin923.spl~ ~override~ // City of Caverns party heal
              ~spin958.spl~ ~override~ // Illithid/Ularthid heal
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no dispel/bypass
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// cutscene petrification visual effect allows save
COPY_EXISTING ~spin950.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN // play 3d effect
        WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // no save
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// MF psionic blast only spell to use spflayer.vvc; changing to use spmindat.vvc--calls same BAM to be played plus sound
// changing this reduces having to add protection from animation: spflayer in a lot of other files
COPY_EXISTING ~spin974.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "anim"
      PATCH_IF (("%opcode%" = 215) AND ("%anim%" STRING_COMPARE_CASE "spflayer" = 0)) BEGIN // play 3d animation spflayer.vvc
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~spmindat~
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// slow shouldn't stack
COPY_EXISTING ~spin575.spl~  ~override~ // slow
              ~spin977.spl~  ~override~ // slow (golem)
              ~spin983.spl~  ~override~ // slow (innate)
              ~spwi312.spl~  ~override~ // slow (mage)
              ~spwish25.spl~ ~override~ // slow (wish)
              ~spwm164.spl~  ~override~ // slow (wild surge)
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
        PATCH_IF ("%opcode%" = 40) BEGIN // if slow opcode
          READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone_fx" (0x30) // read entire effect
          SET "index2" = "%abil_fx_num%" // kills loop
        END
      END
      FOR (index3 = 0 ; index3 < 6 ; index3 = index3 + 1) BEGIN
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30         // create new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%clone_fx%~ // clones slow effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 206          // spell immunity
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0xffffffff   // string to display
      END
      WRITE_EVALUATED_ASCII     ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 5))) ~%SOURCE_RES%~ #8 // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 4))) ~spin575~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 3))) ~spin983~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 2))) ~spwi312~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 1))) ~spwish25~ #8 // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 0))) ~spin977~ #8  // resref
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin575" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 4))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin983" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 3))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi312" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 2))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwish25" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 1))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin977" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 0))) ~spwm164~ #8  // resref
      END
      SET "delta" = "%delta%" + 6
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 6)
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// beholder death ray should be subject to MR
COPY_EXISTING ~spin991.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 13) BEGIN // kill target
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// typo in spl reference
COPY_EXISTING ~spinhum.spl~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhun" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spinhum" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Harper's Call not draining stats

/// DW: fix a typo in the CDSPJA files (spotted by Mike1072)

COPY_EXISTING 
	~cdspja00.eff~ ~override~
	~cdspja01.eff~ ~override~
	~cdspja02.eff~ ~override~
	~cdspja03.eff~ ~override~
	~cdspja04.eff~ ~override~
	~cdspja05.eff~ ~override~
		WRITE_LONG 0x20 0
BUT_ONLY_IF_IT_CHANGES
	

COPY_EXISTING ~spja01.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "new_fx" = 6
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + "%new_fx%")
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET         "abil_fx_idx" = ("%abil_fx_idx%" + ("%new_fx%" * "%index%"))
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index3%"))) "target"
        PATCH_IF ("%target%" = 2) BEGIN // preset target
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index3%"))) 0 // no dispel/bypass mr
        END
      END
      FOR (index2 = 0; index2 < new_fx; index2 = index2 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0x30
          WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 177              // use eff file
          WRITE_BYTE   ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // target: preset target
          WRITE_BYTE   ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 5                // power
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // pc...
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // from ea.ids
          WRITE_LONG   ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 60               // 60 seconds
          WRITE_BYTE   ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100              // probability
          WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) ~cdspja0%index2%~ // resref
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// entangle doesn't have its listed save bonus for target
COPY_EXISTING ~sppr105.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// barkskin AC bonus incorrect at higher levels
COPY_EXISTING ~sppr202.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_level"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 0) BEGIN // ac bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) (6 - ("%min_level%" / 4)) // ((6 - (caster level/4), per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// chant doesn't provide the listed save bonuses nor the penalties to opponents. Also shouldn't stack.
COPY_EXISTING ~sppr203.spl~  ~override~
  PATCH_IF (%SOURCE_SIZE%>0x71)                               BEGIN
    READ_LONG    0x64 "ho"                                    // extended header offset
    READ_SHORT   0x68 "hc"                                    // extended header count
    READ_LONG    0x6a "eo"                                    // feature table offset
    FOR ("i1"=0; "%i1%"<"%hc%"; "i1"+=1)                      BEGIN
      WRITE_BYTE    ("%ho%"+(0x28*"%i1%")+0x0c) 0x05          // target self
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x0e) 0x00          // range
      READ_SHORT    ("%ho%"+(0x28*"%i1%")+0x1e) "ec"          // effects for header i+1
      READ_SHORT    ("%ho%"+(0x28*"%i1%")+0x20) "ei"          // effect index for header i+1
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x26) 0x01          // projectile: none
      DELETE_BYTES  ("%eo%"+(0x30*"%ei%")+0x00) (0x30*"%ec%") // remove existing effects
      INSERT_BYTES  ("%eo%"+(0x30*"%ei%")+0x00) 0x60          // add two new effects
      WRITE_ASCII   ("%eo%"+(0x30*"%ei%")+0x14) ~sppr203d~ #8 // positive chant
      WRITE_ASCII   ("%eo%"+(0x30*"%ei%")+0x44) ~sppr203e~ #8 // negative chant
      FOR ("i2"=0; "%i2%"<2; "i2"+=1)                         BEGIN
        WRITE_SHORT ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x00) 0x92 // cast spell
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x02) 0x01 // target self
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x03) 0x00 // power
        WRITE_LONG  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x04) 0x00 // casting level
        WRITE_LONG  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x08) 0x01 // cast instantly
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x0c) 0x01 // instant/permanent
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x0d) 0x00 // resistability
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x12) 0x64 // min prob 100%
      END                                                     // FOR i2 effect fleshing
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x1e) 0x02          // effects for header i+1
      FOR ("i3"="%i1%" + 1; "%i3%"<"%hc%"; "i3"+=1)           BEGIN //i1 + 1, because we only want to update the later headers
        READ_SHORT  ("%ho%"+(0x28*"%i3%")+0x20) "ix"          // search later header indices
        WRITE_SHORT ("%ho%"+(0x28*"%i3%")+0x20) (("%ix%"-"%ec%")+0x02)
      END                                                     // FOR i3; rewriting ability effect indices
    END                                                       // FOR i1
  END                                                         // PATCH_IF filesize check
  BUT_ONLY_IF_IT_CHANGES                                        // COPY_EXISTING

// resist fire/cold has incorrect duration at level 20; stacking issue already covered below
COPY_EXISTING ~sppr210.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN // grabs last ability (lev 20)
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx"
    WHILE ("%abil_fx_num%" > 0) BEGIN
      SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
      PATCH_IF ("%duration%" = 200) BEGIN // incorrect duration
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 120 // corrects duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr301.spl~ ~override~ // animate dead - divine
              ~spwi501.spl~ ~override~ // animate dead - arcane
              ~sppr302.spl~ ~override~ // call lightning
              ~sppr506.spl~ ~override~ // iron skins
              ~sppr608.spl~ ~override~ // harm
              ~sppr720.spl~ ~override~ // earthquake
              ~sppr723.spl~ ~override~ // elemental summoning
              ~sppr724.spl~ ~override~ // greater elemental summoning
              ~spwi208.spl~ ~override~ // know alignment
              ~spwi214.spl~ ~override~ // strength
              ~spwi420.spl~ ~override~ // minor sequencer
              ~spwi617.spl~ ~override~ // contingency
              ~spwi710.spl~ ~override~ // spell sequencer
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 9
  END
  BUT_ONLY_IF_IT_CHANGES

// animate dead has several minor errors in effect headers and is missing headrs for levels 6-9
COPY_EXISTING ~sppr301.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "lev6_exist" = 0
  SET "lev7_exist" = 0
  SET "lev8_exist" = 0
  SET "lev9_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_ASCII ("%abil_off%" + 0x04 + (0x28 * "%index%")) ~sppr301b~ // consistent icon
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
          READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob_lo"
          PATCH_IF ("%prob_lo%" = 0) BEGIN
            WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3  // power
            WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 75 // probability
          END ELSE BEGIN
            WRITE_BYTE ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 76 // probability
          END
        END
      END
      READ_ASCII ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 6) BEGIN 
      SET "lev6_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 7) BEGIN
      SET "lev7_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 8) BEGIN
      SET "lev8_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 9) BEGIN
      SET "lev9_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 11) BEGIN // level 11 header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
          READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob_lo"
          PATCH_IF ("%prob_lo%" = 0) BEGIN
            WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 45 // probability
          END
        END
      END
    END
  END
  PATCH_IF ("%lev6_exist%" = 0) BEGIN
    SET "level" = 6
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev7_exist%" = 0) BEGIN
    SET "level" = 7
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev8_exist%" = 0) BEGIN
    SET "level" = 8
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev9_exist%" = 0) BEGIN
    SET "level" = 9
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
      PATCH_IF ("%min_lev%" > 9) BEGIN // if after new inserted effects
        READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
        WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%" + ("%new_abil%" * "%new_fx%"))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// some effects on dispel magic subject to MR, though all other effects are not; see also deva.itm et al patch
COPY_EXISTING ~spin866.spl~  ~override~ // FORCE_DISPEL_MAGIC
              ~sppr303.spl~  ~override~ // dispel magic (priest)
              ~spwi302.spl~  ~override~ // remove magic (mage)
              ~spwi326.spl~  ~override~ // dispel magic (mage)
              ~sw2h10dm.spl~ ~override~ // dispel magic (unused)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 58) OR ("%opcode%" = 77) OR ("%opcode%" = 215) OR ("%opcode%" = 240)) BEGIN // dispel fx, cure fm, play 3d effect, remove icon opcodes
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hold animal has incorrect casting time and has a spurious save penalty
COPY_EXISTING ~sppr305.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 5  // casting time
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr309.spl~ ~override~ // invisibility purge
              ~sppr502.spl~ ~override~ // cure crit wounds
              ~spwi609.spl~ ~override~ // true sight
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 8
  END
  BUT_ONLY_IF_IT_CHANGES

// holy smite missing level 20 abilities, a few effects mistargeted and/or wrong duration at lev 6, 7
COPY_EXISTING ~sppr313.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "orig_abil" = "%abil_num%"
  SET "delta" = 0
  SET "loops" = 0
  SET "min_lev" = 0
  WHILE ("%abil_num%" > 0) BEGIN // grabs last ability (lev 19) and does patching for lev 6, 7 abilities
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "level"
    PATCH_IF ("%min_lev%" = 0) BEGIN
      SET "min_lev" = "%level%" // sets min_lev to use last ability
    END
    PATCH_IF (("%level%" = 6) OR ("%level%" = 7)) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "eff_file"
        PATCH_IF ("%eff_file%" STRING_COMPARE_CASE "hitinvwa" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
        END ELSE
        PATCH_IF ("%eff_file%" STRING_COMPARE_CASE "blind" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // instant/limited
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 6 // duration
        END
      END
    END
  END
  PATCH_IF ("%min_lev%" < 20) BEGIN
    INSERT_BYTES "%fx_off%" 0x28
    SET "delta" = 1
    READ_ASCII ("%fx_off%" - 0x28) "abil_clone" (0x28) // reads entire ability as block
    READ_SHORT (("%fx_off%" - 0x28) + 0x1e) "abil_fx_num"
    READ_SHORT (("%fx_off%" - 0x28) + 0x20) "abil_fx_idx"
  END
  WHILE ("%delta%" > "%loops%") BEGIN // this clones the lev 19 abilities to the lev 20 one
    WRITE_EVALUATED_ASCII  (("%fx_off%" + (0x28 * "%loops%"))       ) "%abil_clone%"
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x10) ("%min_lev%" + 1 + "%loops%")
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x1e) "%abil_fx_num%"
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x20) ("%abil_fx_idx%" + (("%loops%" + 1) * "%abil_fx_num%"))
    SET "loops" = ("%loops%" + 1)
  END
  WRITE_SHORT 0x68 ("%orig_abil%" + "%delta%")
  SET "fx_off" = ("%fx_off%" + (0x28 * "%delta%"))
  WRITE_LONG  0x6a "%fx_off%"
  INSERT_BYTES ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) (0x30 * ("%delta%" * "%abil_fx_num%"))
  WHILE ("%delta%" > 0) BEGIN
    SET "loops" = "%abil_fx_num%"
    WHILE ("%loops%" > 0) BEGIN
      SET "loops" = ("%loops%" - 1)
      READ_ASCII  ("%fx_off%" + 0x00 + (0x30 * ("%loops%" + "%abil_fx_idx%"))) "clone" (0x30)
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x00 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) "%clone%"
      READ_ASCII  ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%"))) "eff_again"
      PATCH_IF ("%eff_again%" STRING_COMPARE_CASE "sp313l19" = 0) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) ~sp313l20~
      END ELSE BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) "%eff_again%"
      END
    END
    SET "delta" = ("%delta%" - 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// free action misc errors and missing lev 19, 20 headers
// all supplementary effects handled in effects batches below
COPY_EXISTING ~sppr403.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "basedur" = 96
  FOR (loops = abil_num; loops > 0; loops = loops - 0x01) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%loops%" - 1))) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%loops%" - 1))) "abil_fx_idx"
    WHILE ("%abil_fx_num%" > 0) BEGIN // first fix existing effects
      SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "immunity"
      PATCH_IF (("%opcode%" = 101) AND ("%immunity%" = 5)) BEGIN // immunity to charm
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 126 // movementrate bonus
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100 // percentage
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2   // set to %
      END
      PATCH_IF (("%opcode%" = 101) AND ("%immunity%" = 185)) BEGIN // immunity to hold 2 shouldn't be there, also targeted at self
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 169 // prevent portait icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2   // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 145 // grease
      END
    END
  END
  // read data from last ability
  READ_SHORT ("%abil_off%" + 0x10 + (0x28 * ("%abil_num%" - 1))) "min_lev"
  READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
  READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
  SET "abil_insert" = ("%abil_off%" + (0x28 * "%abil_num%"))
  PATCH_IF ("%min_lev%" < 20) BEGIN // if abilities don't go to lev 20
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    FOR ("index" = 20; "%index%" > "%min_lev%"; "index" = ("%index%" - 1)) BEGIN          // now extend headers
      INSERT_BYTES          ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) (60 + (6 * "%index%")) // corrects duration
        END
      END
      INSERT_BYTES          ("%abil_insert%"       ) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_insert%"       ) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_insert%" + 0x10) "%index%"   // minimum level
      WRITE_SHORT           ("%abil_insert%" + 0x1e) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_insert%" + 0x20) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - "%min_lev%")))
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  END

// neutralize poison failing to cure disease due to bad target
COPY_EXISTING ~sppr404.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 79) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// opcode has wrong target in death ward
COPY_EXISTING ~sppr409.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 282) BEGIN // damage opcode
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// holy power missing level 19, 20 abilities
COPY_EXISTING ~sppr412.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev19_exist" = 0
  SET "lev20_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%index%" = ("%abil_num%" - 1)) BEGIN // last header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
    END ELSE
    PATCH_IF ("%min_lev%" = 19) BEGIN
      SET "lev19_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 20) BEGIN
      SET "lev20_exist" = 1
    END
  END
  PATCH_IF ("%lev19_exist%" = 0) BEGIN
    SET "level" = 19
    INSERT_BYTES ("%fx_off%" + (0x30 * "%start_fx%")) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%start_fx%")) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%start_fx%"))) "opcode"
      PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) (21 - "%level%")
      END ELSE
      PATCH_IF ("%opcode%" = 18) BEGIN // hp bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) "%level%"
      END
      READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%index2%" + "%start_fx%"))) "timing"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) "duration"
      PATCH_IF (("%duration%" > 5) AND (("%timing%" = 0) OR ("%timing%" = 3))) BEGIN // for durations longer than a round, limited timing modes
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) (6 * "%level%")
      END
    END
    INSERT_BYTES            ("%fx_off%"       ) 0x28
      WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%abil_clone%"
      WRITE_SHORT           ("%fx_off%" + 0x10) "%level%"
    SET "new_abil" = "%new_abil%" + 1
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "start_fx" = ("%start_fx%" + "%new_fx%")
  END
  PATCH_IF ("%lev20_exist%" = 0) BEGIN
    SET "level" = 20
    INSERT_BYTES ("%fx_off%" + (0x30 * "%start_fx%")) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%start_fx%")) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%start_fx%"))) "opcode"
      PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) (21 - "%level%")
      END ELSE
      PATCH_IF ("%opcode%" = 18) BEGIN // hp bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) "%level%"
      END
      READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%index2%" + "%start_fx%"))) "timing"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) "duration"
      PATCH_IF (("%duration%" > 5) AND (("%timing%" = 0) OR ("%timing%" = 3))) BEGIN // for durations longer than a round, limited timing modes
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) (6 * "%level%")
      END
    END
    INSERT_BYTES            ("%fx_off%"       ) 0x28
      WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%abil_clone%"
      WRITE_SHORT           ("%fx_off%" + 0x10) "%level%"
    SET "new_abil" = "%new_abil%" + 1
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "start_fx" = ("%start_fx%" + "%new_fx%")
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a "%fx_off%"
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// champion's strength missing level 19,20 headers, wrong durations at levels 17,18
COPY_EXISTING ~sppr507.spl~  ~override~ // champion's strength
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT ("%abil_off%" + 0x10 + (("%abil_num%" - 1) * 0x28)) "min_level" // min level of last ability header
  FOR (index = min_level + 1 ; index < 21 ; index = index + 1) BEGIN
    READ_ASCII ("%abil_off%" +        (("%abil_num%" - 1) * 0x28)) "abil_clone" (0x28) // reads last ability as block
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num" // reads number of fx from last ability
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx" // reads index of last effects from last ability
    // create effects for next level based off previous level effects
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_ASCII     ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // reads entire effect
      INSERT_BYTES   ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) "%clone_fx%" // clones effect
    END
    // effects created, now add new ability
    INSERT_BYTES            ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28
      WRITE_EVALUATED_ASCII ("%abil_off%" +        ("%abil_num%" * 0x28)) "%abil_clone%" // clones last ability
      WRITE_SHORT           ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) "%index%"      // min level
      WRITE_SHORT           ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) ("%abil_fx_num%" + "%abil_fx_idx%") // corrects fx index
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = "%abil_num%" + 1
  END
  WRITE_SHORT 0x68 "%abil_num%"
  WRITE_LONG  0x6a "%fx_off%"
  // fixes durations for new abilities and levels 17,18
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 9
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // if more than one round
        WRITE_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) ("%min_lev%" * 18) // 3 rounds/level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// two durations are incorrect for righteous magic; stacking handled below
COPY_EXISTING ~sppr513.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    PATCH_IF ("%min_lev%" = 10) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 250) BEGIN // max damage per hit
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 60 // dispel/not bypass
        END
      END
    END ELSE
    PATCH_IF ("%min_lev%" = 20) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 142) BEGIN // display portrait icon
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 120 // dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power issue with false dawn
COPY_EXISTING ~sppr609.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // power
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// gate should be visual sight range
COPY_EXISTING ~sppr703.spl~ ~override~
              ~spwi905.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%index%")) 30
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr711.spl~ ~override~ // regeneration
              ~spwi723.spl~ ~override~ // improved chaos shield
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 7
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB
  // energy blades
  COPY_EXISTING ~sppr721.spl~ ~override~
                ~spwi920.spl~ ~override~
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_LONG  0x34 "level"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%level%" // power is wrong in effects
      END
    END
    BUT_ONLY_IF_IT_CHANGES
END

// grease fixes
COPY_EXISTING ~spwi101.spl~ ~override~
  WRITE_ASCII 0x3a ~spwi101c~ // fixes icon
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // first fix existing effects
    WRITE_SHORT ("%abil_off%" + index * 0x28 + 0x0e + ("%index%" * 0x28)) 30 // corrects range
    WRITE_SHORT ("%abil_off%" + index * 0x28 + 0x12 + ("%index%" * 0x28)) 1  // casting time
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (18 + (6 * "%min_lev%")) // corrects duration
      END
    END
  END
  PATCH_IF ("%min_lev%" < 20) BEGIN // if abilities don't go to lev 20
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    FOR ("index" = 20; "%index%" > "%min_lev%"; "index" = ("%index%" - 1)) BEGIN          // now extend headers
      INSERT_BYTES          ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) (18 + (6 * "%index%")) // corrects duration
        END
      END
      INSERT_BYTES          ("%abil_off%" + 0x28) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_off%" + 0x28) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_off%" + 0x38) ("%index%") // minimum level
      WRITE_SHORT           ("%abil_off%" + 0x46) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_off%" + 0x48) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - 1)))
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// armor fixes
COPY_EXISTING ~spwi102.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
    READ_SHORT  ("%abil_off%" + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%opcode%" = 215) BEGIN // play 3d effect opcode
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2             // corrects duration
      END
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2700 // corrects duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// burning hands fixes
COPY_EXISTING ~spwi103.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 5 // corrects range
    READ_SHORT  ("%abil_off%" + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 165) BEGIN // play 3d effect opcode
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2             // corrects duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// color spray fixes - range is wrong, removes undocumented save penalty
COPY_EXISTING ~spin937.spl~ ~override~ // mephit version
              ~spwi105.spl~ ~override~ // regular mage version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 30 // corrects range
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // set save bonus to 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// spell range as "visual range"
COPY_EXISTING ~spwi106.spl~ ~override~ // blindness
              ~spwi111.spl~ ~override~ // infravision
              ~spwi125.spl~ ~override~ // spook
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 60 // corrects range
  END
  BUT_ONLY_IF_IT_CHANGES

// friends fixes
// partially dropped because of multiple chr stacking. :(
COPY_EXISTING ~spwi107.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT  ("%abil_off%" + 0x48) "second_fx_idx"
  READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "last_fx_num"
  READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "last_fx_idx"
  DELETE_BYTES ("%fx_off%" + (0x30 * "%second_fx_idx%")) (0x30 * (("%last_fx_idx%" + "last_fx_num") - "%second_fx_idx%")) // eliminates all high lev effects
  DELETE_BYTES ("%abil_off%" + 0x28) (0x28 * ("%abil_num%" - 1)) // eliminates all abilities beyond the first
  SET "fx_off" = ("%fx_off%" - (0x28 * ("%abil_num%" - 1)))
  // now to patch effects at lev 1 before cloning
  READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
  READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
  READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
  READ_ASCII ("%abil_off%") "ability" (0x28)                                            // reads last ability
  FOR ("index" = 20; "%index%" > 1; "index" = ("%index%" - 1)) BEGIN                    // now extend headers
    INSERT_BYTES            ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) ("%duration%" + (6 * ("%index%" - 1))) // corrects duration
      END
    END
    INSERT_BYTES            ("%abil_off%" + 0x28) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_off%" + 0x28) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_off%" + 0x38) ("%index%") // minimum level
      WRITE_SHORT           ("%abil_off%" + 0x46) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_off%" + 0x48) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - 1)))
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = ("%abil_num%" + 1)
  END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 20
  BUT_ONLY_IF_IT_CHANGES

// magic missile damage fix
COPY_EXISTING ~spin685.spl~ ~override~ // Imoen/promenade cutscene version
              ~spin962.spl~ ~override~ // beholder version
              ~spwi003.spl~ ~override~ // trap wizard version
              ~spwi112.spl~ ~override~ // regular wizard version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 60 // corrects range
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage opcode
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // fixed damage
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // num dice
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // dice size
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// duration for protection from evil wrong at many levels
COPY_EXISTING ~spwi113.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // filter out brief and/or instant effects like playing sounds and animations
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" * 12)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// school fix for shield
COPY_EXISTING ~spwi114.spl~ ~override~ 
  WRITE_BYTE 0x22 15 // evocation
  BUT_ONLY_IF_IT_CHANGES
  
// range fixes
COPY_EXISTING ~spin104.spl~ ~override~ // innate LMD
              ~spwi116.spl~ ~override~ // sleep
              ~spwi119.spl~ ~override~ // mage LMD
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 90 // corrects range
  END
  BUT_ONLY_IF_IT_CHANGES
  
// find familiar casting time
COPY_EXISTING ~spwi123.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
  END
  BUT_ONLY_IF_IT_CHANGES

// nahal's reckless dweomer casting time, school
COPY_EXISTING ~spwi124.spl~ ~override~
  WRITE_BYTE  0x22 15 // invocation
  WRITE_SHORT 0x25 6  // invoker
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 5 // casting time
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi217.spl~ ~override~ // aganazzar's scorcher
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 3
  END
  BUT_ONLY_IF_IT_CHANGES

// remove magic not removing feeblemeind like dispel magic
COPY_EXISTING ~spwi302.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))  240 // opcode: remove portrait icon
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    2 // target: preset target
      WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%"))   48 // icon: feeblemind
      WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))    1 // instant/permanent
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%"))    2 // dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))   77 // opcode: remove feeblemind
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    2 // target: preset target
      WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))    1 // instant/permanent
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%"))    2 // dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    SET "fx_delta" = ("%fx_delta%" + 2)
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi309.spl~ ~override~ // mon summoning i
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 4
  END
  BUT_ONLY_IF_IT_CHANGES

// duration for monster summoning i, ii incorrect when cast at many levels
COPY_EXISTING ~spwi309.spl~ ~override~
              ~spwi407.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi309" = 0) THEN BEGIN
    SET "base_dur" = 12
    SET "open_lvl" = 5
  END ELSE BEGIN
    SET "base_dur" = 18
    SET "open_lvl" = 7
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) THEN BEGIN
      SET "min_lev" = "%open_lvl%"
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // filter out brief and/or instant effects like playing sounds and animations
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%base_dur%" + ("%min_lev%" * 6))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// skull trap has incorrect range
COPY_EXISTING ~spwi313.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%abil_num%")) 30 // range
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from fire and protection from cold missing lev 19, 20 abilities (revised by Wisp)
COPY_EXISTING ~spwi319.spl~ ~override~
              ~spwi320.spl~ ~override~
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  19p = 0
  20p = 0
  FOR (i = 0; i < abil_num; ++i) BEGIN                  //Find the insertion points
    READ_SHORT abil_off + 0x28 * i + 0x10 min_level
    PATCH_IF min_level = 18 BEGIN
      READ_ASCII abil_off + 0x28 * i        abil_clone (0x28)
      READ_SHORT abil_off + 0x28 * i + 0x1e num_fx
      READ_SHORT abil_off + 0x28 * i + 0x20 fx_idx
      READ_ASCII fx_off + 0x30 * fx_idx fx_block_clone (0x30 * num_fx)
      header_point = abil_off + 0x28 * (i + 1)          //+1, to get ahead of the level 18 header 
      fx_point = fx_off + 0x30 * (fx_idx + num_fx)
      FOR (j = abil_num - 1; j > 0; --j) BEGIN          //Verify that levels 19 and 20 are indeed missing; in this context j must always be positive, 
                                                        //since we know we have at least one header for level 18
        READ_SHORT abil_off + 0x28 * j + 0x10 check
        PATCH_IF check = 18 BEGIN                       //No point in going further; it ain't here
          j = 0
        END
        PATCH_IF check = 19 BEGIN
          19p = 1
          READ_SHORT abil_off + 0x28 * j + 0x1e 19num_fx
          READ_SHORT abil_off + 0x28 * j + 0x20 19fx_idx
          header_point = abil_off + 0x28 * (j + 1)      //If we have a level 19 header we need to update these
          fx_point = fx_off + 0x30 * (19num_fx + 19fx_idx)
        END
        PATCH_IF check = 20 BEGIN
          20p = 1
        END
      END
    END
  END
  PATCH_IF VARIABLE_IS_SET header_point BEGIN           //Insert new headers and effects, assuming nothing has gone wrong
    PATCH_FOR_EACH level IN 20 19 BEGIN                 //Reversed to minimise the bookkeeping
      PATCH_IF !EVAL "%level%p" BEGIN
        INSERT_BYTES header_point         0x28
        WRITE_ASCIIE header_point         "%abil_clone%"
        WRITE_SHORT  header_point + 0x10  level
        fx_idx += (num_fx * (level - 18))
        WRITE_SHORT  header_point + 0x20  fx_idx
        fx_off += 0x28
        fx_point += 0x28
        ++abil_num
        INSERT_BYTES fx_point             0x30 * num_fx
        WRITE_ASCIIE fx_point             "%fx_block_clone%"
        FOR (i = 0; i < num_fx; ++i) BEGIN              //Adjust the duration for the new effects, 1 turn/level, but not for the instant or
                                                        //near-instant effects
          WRITE_LONG fx_point + 0x30 * i + 0xe THIS < 5 ? THIS : 60 * level
        END
      END
    END
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off
  READ_SHORT  0x70 fx_idx                               //aka number of global effects
  FOR (i = 0; i < abil_num; ++i) BEGIN                  //Update fx_idx, in case there are headers for levels > 20
    WRITE_SHORT abil_off + 0x28 * i + 0x20 fx_idx
    fx_idx += SHORT_AT (abil_off + 0x28 * i + 0x1e)     //number of effects
  END
BUT_ONLY

// confusion (mage) missing -2 save penalty
COPY_EXISTING ~spwi401.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "saves"
      PATCH_IF ("%saves%" != 0) BEGIN // if save allowed
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0xfffffffe // should be a -2 penalty
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// poly other shouldn't have save bonuses
COPY_EXISTING ~spwi415.spl~ ~override~
              ~spwm183.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = abil_fx_num ; loops > 0 ; loops = loops - 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 0 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mage farsight has wonky durations
COPY_EXISTING ~spwi424.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "level"
    PATCH_IF ("%level%" = 1) BEGIN
      SET "level" = 7
    END
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // if longer than instant
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (6 * (3 + "%level%"))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cone of cold missing level 10 ability header, wrong range at level 9, inconsistent save v non-save damage split
COPY_EXISTING ~spwi503.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev10_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 9
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "save"
        PATCH_IF ("%save%" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (("%min_lev%" + 1) / 2) // damage
          WRITE_BYTE ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" / 2) // damage
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" / 2) // damage
          WRITE_BYTE ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (("%min_lev%" + 1) / 2) // damage
        END
      END
    END
    PATCH_IF ("%min_lev%" = 9) BEGIN // if first header
      WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%index%")) 12 // corrects range
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 10) BEGIN
      SET "lev10_exist" = 1
    END
  END
  PATCH_IF ("%lev10_exist%" = 0) BEGIN
    SET "level" = 10
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        READ_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x24 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "save"
        PATCH_IF ("%save%" = 0) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x04 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (("%level%" + 1) / 2) // damage
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x1c + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" / 2) // damage
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x04 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" / 2) // damage
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x1c + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (("%level%" + 1) / 2) // damage
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mon sum iii has wrong probabilities at level 1
COPY_EXISTING ~spwi504.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      SET "eff" = 3
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF (("%opcode%" = 177) AND ("%eff%" = 2)) BEGIN // last eff opcode
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100 // probability
          WRITE_BYTE ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 61  // probability
          SET "eff" = 0
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%eff%" = 3)) BEGIN // first or second eff
          SET "eff" = ("%eff%" - 1)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from acid has incorrect casting time
COPY_EXISTING ~spwi517.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // goes through all abilities and adjusts casting time
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%abil_num%")) 6
  END
  BUT_ONLY_IF_IT_CHANGES

 // minor spell turning reflecting spells of level 5-7; should only be 1-4
COPY_EXISTING ~spwi522.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "max_level"
      PATCH_IF (("%opcode%" = 200) AND ("%max_level%" > 4)) BEGIN // reflect spells of level 5+
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        SET "index2" = ("%index2%" - 1)
        SET "delta" = ("%delta%" - 1)
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// invisible stalkers only summoned for 8 hours, should be 9
COPY_EXISTING ~spwi601.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2700 // duration = 9 hours, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap
// see also statdesc.2da, states.bam, states2.bam
COPY_EXISTING ~spwi606.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 73)) BEGIN // display old pro-magic energy icon
        WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 123 // change to new pro-magic energy icon
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi608.spl~ ~override~ // pierce magic
              ~spwi802.spl~ ~override~ // spell deflection
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 6
  END
  BUT_ONLY_IF_IT_CHANGES

// conjure fire elemental should be restricted from diviners (spell school)
COPY_EXISTING ~spwi620.spl~ ~override~
  READ_BYTE  0x1f "school"
  WRITE_BYTE 0x1f ("%school%" BOR 0b00000001) // adds diviner flag
  BUT_ONLY_IF_IT_CHANGES

// conjure air/earth elemental missing level 12-14 ability headers
COPY_EXISTING ~spwi621.spl~ ~override~
              ~spwi622.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev12_exist" = 0
  SET "lev13_exist" = 0
  SET "lev14_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 12) BEGIN
      SET "lev12_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 13) BEGIN
      SET "lev13_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 14) BEGIN
      SET "lev14_exist" = 1
    END
  END
  PATCH_IF ("%lev12_exist%" = 0) BEGIN
    SET "level" = 12
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev13_exist%" = 0) BEGIN
    SET "level" = 13
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev14_exist%" = 0) BEGIN
    SET "level" = 14
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cacofiends summoned for 120s; should be 90
COPY_EXISTING ~spwi707.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 90 // duration = 15 rounds, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sphere of chaos sleep duration is off by a second
COPY_EXISTING ~spwi711.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
      READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 39) BEGIN // sleep
          WRITE_BYTE ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// delayed blast fireball should do 15d6 damage, not 14d6 + 15
COPY_EXISTING ~spwi712.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // no-save damage
        READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "saves"
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // fixed damage
        PATCH_IF ("%saves%" = 0) BEGIN
          WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 8 // number of dice, no save
        END ELSE BEGIN
          WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 7 // number of dice, save
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mordy sword should break invisibility
COPY_EXISTING ~spwi716.spl~ ~override~
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BOR 0b00000100) // adds break invis flag
  BUT_ONLY_IF_IT_CHANGES

// summon hakeshar missing lev 14, 15 headers
COPY_EXISTING ~spwi719.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev14_exist" = 0
  SET "lev15_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // use eff
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 126 // duration
        END
      END
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 14) BEGIN
      SET "lev14_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 15) BEGIN
      SET "lev15_exist" = 1
    END
  END
  PATCH_IF ("%lev14_exist%" = 0) BEGIN
    SET "level" = 14
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ((8 + "%level%") * 6) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev15_exist%" = 0) BEGIN
    SET "level" = 15
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ((8 + "%level%") * 6) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell school fix
COPY_EXISTING ~spwi721.spl~ ~override~ // mass invisibility
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_SHORT 0x25 5 // illusion
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speeds for mage symbol spells and spell trigger are incorrect
COPY_EXISTING ~spwi809.spl~ ~override~ // spell trigger
              ~spwi811.spl~ ~override~ // symbol fear (mage)
              ~spwi816.spl~ ~override~ // symbol stun (mage)
              ~spwi817.spl~ ~override~ // symbol death (mage)
              ~spwi897.spl~ ~override~ // symbol death (enemy mage version)
              ~spwi898.spl~ ~override~ // symbol stun (enemy mage version)
              ~spwi899.spl~ ~override~ // symbol fear (enemy mage version)
              ~spwm123.spl~ ~override~ // symbol fear (wild magic)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x28)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// lowest level casting of symbol, stun and symbol, fear have inconsistent sound effect; casting times fixed elsewhere
COPY_EXISTING ~spwi811.spl~ ~override~
              ~spwi816.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "sound"
      PATCH_IF (("%opcode%" = 174) AND ("%sound%" STRING_COMPARE_CASE "eff_m03" = 0)) BEGIN // sound to be replaced
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~eff_p04~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power word: blind should last 6 rounds, not 10
COPY_EXISTING ~spwi815.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" = 60) BEGIN // 10 rounds
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 36 // 6 rounds
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enemy versions of symbol spells missing casting sounds
COPY_EXISTING ~spwi897.spl~ ~override~
              ~spwi898.spl~ ~override~
              ~spwi899.spl~ ~override~
              ~spwm123.spl~ ~override~
  WRITE_ASCII 0x10 ~cas_m03~ #8
  BUT_ONLY_IF_IT_CHANGES

// typo in wav reference
COPY_EXISTING ~spwi995.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 174) AND ("%resref%" STRING_COMPARE_CASE "eff_m09 " = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "eff_m09" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// create custom spell trap for SotM
COPY_EXISTING ~spwi902.spl~ ~override/staf11.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx"
    SET "last_fx" = ("%abil_fx_num%" + "%abil_fx_idx%")
  END ELSE BEGIN
    READ_SHORT 0x70 "last_fx"
  END
  WHILE ("%last_fx%" > 0) BEGIN
    SET "last_fx" = ("%last_fx%" - 1)
    READ_BYTE ("%fx_off%" + 0x0c + ("%last_fx%" * 0x30)) "timing"
    READ_LONG ("%fx_off%" + 0x0e + ("%last_fx%" * 0x30)) "duration"
    PATCH_IF (("%timing%" = 0) AND ("%duration%" > 5)) BEGIN // if instant/limited for more than one round
      WRITE_LONG ("%fx_off%" + 0x0e + ("%last_fx%" * 0x30)) 2400
    END
  END

// pit fiends around for an extra two seconds
COPY_EXISTING ~spwi905.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 198 // duration = 33 rounds, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// absolute immunity has wrong duration
COPY_EXISTING ~spwi907.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
        PATCH_IF ("%duration%" = 28) BEGIN // wrong duration
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 24 // correct duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// energy drain lighting effect is not bypassing MR like all other effects
COPY_EXISTING ~spwi914.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 141) BEGIN // lighting effect
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
COPY_EXISTING ~spwi917.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 212) BEGIN // imprisonment
        SET "index2" = "%index2%" + 1 // make extra spellcast after freedom effect
        INSERT_BYTES  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 146 // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   1 // target self
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   0 // cast at level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   1 // cast instantly
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%")))   4 // delay/permanent
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%")))   2 // 2 second delay
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 100 // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~cdwi917a~ #8 // spell
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// bigby's crushing hand should be saving against paralyzation; some second round saves are incorrect
COPY_EXISTING ~spwi918.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 9 // power is inconsistent in effects
      READ_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "timing"
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      READ_BYTE ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "savetype"
      PATCH_IF (("%timing%" = 4) AND ("%duration%" = 12)) BEGIN // round 2 damage
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0  // no save penalty
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon's breath has spurious save penalty vs. sleep, missing sleep portrait icon
COPY_EXISTING ~spwi922.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 39) BEGIN // sleep
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0  // no save penalty
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones sleep effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 142 // display portrait icon
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 14  // sleep icon
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// time stop/imp alacrity from wish has wrong opcode for IA
COPY_EXISTING ~spwish17.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "sound"
          PATCH_IF ("%opcode%" = 189) BEGIN // increase casting speed
            WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 188 // increase spells/round
            WRITE_SHORT ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1   // unlimited
          END ELSE
          PATCH_IF ("%opcode%" = 139) BEGIN // increase casting speed
            WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0   // probability: 0
          END ELSE
          PATCH_IF (("%opcode%" = 174) AND ("%sound%" STRING_COMPARE_CASE "eff_m29" = 0)) BEGIN // sound
            WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 24   // duration
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wild surge: destroy gold is supposed to target self, not present target
COPY_EXISTING ~spwm117.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1   // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // mage HLAs should be schoolless
  COPY_EXISTING ~spwi920.spl~ ~override~ // energy blades
                ~spwi921.spl~ ~override~ // improved alacrity
                ~spwi922.spl~ ~override~ // dragon's breath
                ~spwi923.spl~ ~override~ // summon planetar
                ~spwi924.spl~ ~override~ // summon dark planetar
                ~spwi925.spl~ ~override~ // comet
    WRITE_SHORT 0x1e 0 // removes exclusion flags
    WRITE_SHORT 0x25 0 // removes primary type
    WRITE_BYTE  0x27 0 // removes secondary type
    BUT_ONLY_IF_IT_CHANGES

END

// improved invisibility and its %$^%&$# saves
// first make shell spells containing just the saves
COPY_EXISTING ~balth10.spl~ ~override/balth10a.spl~ // Shadow Stance!
              ~spdr401.spl~ ~override/spdr401a.spl~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override/spin544a.spl~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override/spin687a.spl~ // Create Shadows
              ~spin698.spl~ ~override/spin698a.spl~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override/spwi405a.spl~ // improved invis (mage)
              ~spwi505.spl~ ~override/spwi505a.spl~ // shadow door (mage)
              ~spwi607.spl~ ~override/spwi607a.spl~ // Mislead
              ~spwi721.spl~ ~override/spwi721a.spl~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG  0x08 0xffffffff // blanks spell name
    WRITE_ASCII 0x10 ~~ #8      // blanks casting sound
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    FOR (index = (abil_num - 1) ; index >= 0 ; index = index - 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 5
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) (5 * "%index%")
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove projectile, if any
      FOR (index2 = (abil_fx_num - 1) ; index2 >= 0 ; index2 = index2 - 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
      END
      FOR (index3 = 33 ; index3 < 38 ; index3 = index3 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%index3%" // save v X
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 4 // save bonus
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 0 // increase/decrease
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// next make shell spells containing just protection spells
COPY_EXISTING ~balth10.spl~ ~override/balth10b.spl~ // Shadow Stance!
              ~spdr401.spl~ ~override/spdr401b.spl~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override/spin544b.spl~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override/spin687b.spl~ // Create Shadows
              ~spin698.spl~ ~override/spin698b.spl~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override/spwi405b.spl~ // improved invis (mage)
              ~spwi505.spl~ ~override/spwi505b.spl~ // shadow door (mage)
              ~spwi607.spl~ ~override/spwi607b.spl~ // Mislead
              ~spwi721.spl~ ~override/spwi721b.spl~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG  0x08 0xffffffff // blanks spell name
    WRITE_ASCII 0x10 ~~ #8      // blanks casting sound
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    FOR (index = (abil_num - 1) ; index >= 0 ; index = index - 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 9
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) (9 * "%index%")
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove projectile, if any
      FOR (index2 = (abil_fx_num - 1) ; index2 >= 0 ; index2 = index2 - 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
      END
      FOR (index4 = 0 ; index4 < 9 ; index4 = index4 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206       // spell immunity
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0xffffffff // no string (silent fail)
//          SAY   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) @114 // no string (silent fail)
      END
      // resrefs for immunity spells
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%"    ))) ~balth10a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 1))) ~spdr401a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 2))) ~spin544a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 3))) ~spin687a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 4))) ~spin698a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 5))) ~spwi405a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 6))) ~spwi505a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 7))) ~spwi607a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 8))) ~spwi721a~ #8 // resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// improved invisibility is missing +4 save bonuses and should not be able to stack with itself
COPY_EXISTING ~balth10.spl~ ~override~ // Shadow Stance!
              ~spdr401.spl~ ~override~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override~ // Create Shadows
              ~spin698.spl~ ~override~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override~ // improved invis (mage)
              ~spwi505.spl~ ~override~ // shadow door (mage)
              ~spwi607.spl~ ~override~ // Mislead
              ~spwi721.spl~ ~override~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END ELSE
        PATCH_IF (("%opcode%" > 32) AND ("%opcode%" < 38)) BEGIN // if save bonuses present, remove them
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "delta" = "%delta%" - 1
        END
      END
      INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%clone%"
        WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 146       // cast spell
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0 // no string (silent fail)
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 1 // no string (silent fail)
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%SOURCE_RES%b~ #8 // resref
      INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
        WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146               // cast spell
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0                 // use caster level
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1                 // cast instantly
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~   // resref
      SET "abil_fx_num" = "%abil_fx_num%" + 2
      SET "delta" = "%delta%" + 2
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// many spells stack with themselves and should not
COPY_EXISTING ~dgfaith.spl~ ~override~ // armor of faith (abazigal)
              ~dgright.spl~ ~override~ // righteous magic (abazigal)
              ~spcl423.spl~ ~override~ // assassin poison weapon ability
              ~spcl907.spl~ ~override~ // hardiness hla
              ~spcl913.spl~ ~override~ // evasion hla
              ~spcl914.spl~ ~override~ // greater evasion hla
              ~spcl917.spl~ ~override~ // avoid death hla
              ~spin943.spl~ ~override~ // blur (air mephit)
              ~sppr111.spl~ ~override~ // armor of faith (priest)
              ~sppr113.spl~ ~override~ // doom
              ~sppr210.spl~ ~override~ // resist fire/cold
              ~sppr306.spl~ ~override~ // protection from fire (priest)
              ~sppr406.spl~ ~override~ // defensive harmony
              ~sppr412.spl~ ~override~ // holy power
              ~sppr513.spl~ ~override~ // righteous magic (priest)
              ~spwi107.spl~ ~override~ // friends: special case, handled directly in its own patch // not anymore
              ~spwi201.spl~ ~override~ // blur (wizard)
              ~spwi209.spl~ ~override~ // luck
              ~spwi214.spl~ ~override~ // strength
              ~spwi319.spl~ ~override~ // protection from fire (wizard)
              ~spwi320.spl~ ~override~ // protection from cold
              ~spwi603.spl~ ~override~ // tenser's transformation
              ~spwi702.spl~ ~override~ // protection from the elements
              ~spwi703.spl~ ~override~ // projected image
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_LONG  0x34 "level"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "timing"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
        PATCH_IF (("%timing%" = 0) AND ("%duration%" > 5) AND // instant/limited and duration greater than a round
                  (("%opcode%" = 33) OR ("%opcode%" = 86) OR ("%opcode%" = 142))) BEGIN
          READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
          READ_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "power"
          READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "bypass"
          SET "index2" = "%abil_fx_num%" // kills WHILE loop
        END
      END
      INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
        WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 206            // spell immunity
        WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%target%"     // inherits target
        WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%power%"      // power
        SAY                   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) @114           // ~You cannot cast...~
        WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0              // instant/limited
        WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%bypass%"     // inherits dispel/MR
        WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%duration%"   // inherits duration
        WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 100            // probability
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%SOURCE_RES%~ // spell: self
      SET "delta1" = 1
      SET "delta" = ("%delta%" + "%delta1%")
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + "%delta1%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scriptable spells
COPY_EXISTING ~SPCL232.spl~ ~override~ // true sight
              ~SPCL412.spl~ ~override~ // set snare
              ~SPCL414.spl~ ~override~ // set special snare
              ~SPCL621.spl~ ~override~ // summon spirit animal
              ~SPCL721.spl~ ~override~ // storm shield
              ~SPCL722.spl~ ~override~ // lightning bolt
              ~SPCL731.spl~ ~override~ // seeking sword
              ~SPCL732.spl~ ~override~ // true sight
              ~SPCL741.spl~ ~override~ // boon of lathander
              ~SPCL742.spl~ ~override~ // hold undead
              ~SPCL910.spl~ ~override~ // set spike trap
              ~SPCL911.spl~ ~override~ // set exploding trap
              ~SPCL912.spl~ ~override~ // set time trap
              ~SPCL923.spl~ ~override~ // summon deva
              ~SPIN683.spl~ ~override~ // figurine_spider_web
              ~SPIN696.spl~ ~override~ // moon_dog_howl
              ~SPIN697.spl~ ~override~ // haste_self
              ~SPIN698.spl~ ~override~ // non_detection_self
              ~SPIN891.spl~ ~override~ // moon_dog_fear
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x34 1
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// store fixes                                      \\\\\
/////                                                  \\\\\

// Monster code for disabling infinite items.
COPY_EXISTING ~25spell2.sto~ ~override~
              ~arled.sto~    ~override~
              ~bdbart01.sto~ ~override~
              ~bernard2.sto~ ~override~
              ~ffbart.sto~   ~override~
              ~gorch.sto~    ~override~
              ~hgkar01.sto~  ~override~
              ~lehtinan.sto~ ~override~
              ~ppstor01.sto~ ~override~
              ~ribald.sto~   ~override~
              ~ribald2.sto~  ~override~
              ~ribald3.sto~  ~override~
              ~sartem01.sto~ ~override~
              ~shop03.sto~   ~override~
              ~shop07.sto~   ~override~
              ~thumb.sto~    ~override~
              ~trgeni01.sto~ ~override~
              ~trmer04.sto~  ~override~
              ~trmer04a.sto~ ~override~
              ~type2.sto~    ~override~
              ~uddrow23.sto~ ~override~
  READ_LONG 0x34 "itm_off" ELSE 0
  READ_LONG 0x38 "itm_num" ELSE 0
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x1c * "%itm_num%")) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl2h" = 0) AND ("25spell2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0xA  + (0x1c * "%itm_num%")) 1 // Set quantity/charges of item to 1
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x14 + (0x1c * "%itm_num%")) 2 // Set number in stock to 2
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h02" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "halb02" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("bdbart01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl8p" = 0) AND ("bernard2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("ffbart" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "blun21" = 0) AND ("gorch" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "blun31" = 0) AND ("hgkar01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("lehtinan" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "dart02" = 0) AND ("ppstor01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring28" = 0) AND ("ribald" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring03" = 0) AND ("ribald" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("ribald2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow10" = 0)  AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0xA  + (0x1c * "%itm_num%")) 0 // Set quantity/charges of item to 0
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
//    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl9z" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
//      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
//    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h09" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h11" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "miscau" = 0) AND ("sartem01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bull02" = 0) AND ("shop03" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "shld05" = 0) AND ("shop07" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("thumb" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h02" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "halb02" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("trmer04" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h11" = 0) AND ("trmer04a" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "chan05" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h07" = 0) AND ("uddrow23" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sell stacks of 1 throwing axe
COPY_EXISTING ~bshop02.sto~ ~override~
  ADD_STORE_ITEM + ~ax1h04~ #5 #0 #0 ~IDENTIFIED~ #3
  BUT_ONLY_IF_IT_CHANGES

// sell stacks of 1 throwing axe
COPY_EXISTING ~garlena.sto~ ~override~
              ~sahpr1.sto~  ~override~
              ~suelf10.sto~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x9a) BEGIN
    ADD_STORE_ITEM + ~ax1h04~ #5 #0 #0 ~IDENTIFIED~ #2
  END
  BUT_ONLY_IF_IT_CHANGES
  
// stores with dupe large shield +1 entries; should be normal large shields
COPY_EXISTING ~ribald.sto~ ~override~
              ~shop02.sto~ ~override~
  READ_LONG 0x34 "itm_off" ELSE 0
  READ_LONG 0x38 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        (0x1c * "%index%")) "item"
    READ_BYTE  ("%itm_off%" + 0x14 + (0x1c * "%index%")) "quantity"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "shld06" = 0) AND ("%quantity%" = 5)) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x1c * "%index%")) ~shld05~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // fix arcana archive name
  COPY_EXISTING ~25SPELL.STO~ ~OVERRIDE~
    SAY 0x0c #70882 // Arcana Archives
    BUT_ONLY_IF_IT_CHANGES

  // fix arcana archive name
  COPY_EXISTING ~25SPELL2.STO~ ~OVERRIDE~
    SAY 0x0c #73982 // Arcana Archives
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part two of four (see cdbag02i.itm, cdbag02j.itm, cdbag02i.sto, cdbag02j.sto)
  COPY_EXISTING ~amsmug01.sto~ ~override~
    READ_LONG 0x34 "4sale_off"
    READ_LONG 0x38 "4sale_num"
    WHILE ("%4sale_num%" > 0) BEGIN
      SET "4sale_num" = ("%4sale_num%" - 1)
      READ_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "bag02d" = 0) BEGIN
        WRITE_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "cdbag02i"
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part three of four (see cdbag02i.itm, cdbag02j.itm, cdbag02i.sto, cdbag02j.sto)
  COPY_EXISTING ~amsmug02.sto~ ~override~
    READ_LONG 0x34 "4sale_off"
    READ_LONG 0x38 "4sale_num"
    WHILE ("%4sale_num%" > 0) BEGIN
      SET "4sale_num" = ("%4sale_num%" - 1)
      READ_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "bag02d" = 0) BEGIN
        WRITE_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "cdbag02j"
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part four of four (see amsmug01.sto, amsmug02.sto, cdbag02i.itm, cdbag02j.itm)
  COPY_EXISTING ~bag02i.sto~ ~override/cdbag02i.sto~
  COPY_EXISTING ~bag02i.sto~ ~override/cdbag02j.sto~

  // starting ToB bags of holding have uncharged items
  COPY_EXISTING ~bag20.sto~ ~override~
                ~bag22.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag21.sto~ ~override~
    ADD_STORE_ITEM + ~BRAC16~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag23.sto~ ~override~
                ~bag24.sto~ ~override~
                ~bag25.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~SW1H27~ #0 #1 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag26.sto~ ~override~
    ADD_STORE_ITEM + ~BULL03~ #40 #0 #0 IDENTIFIED #2
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag27.sto~ ~override~
                ~bag28.sto~ ~override~
    ADD_STORE_ITEM + ~BULL03~ #40 #0 #0 IDENTIFIED #2
    ADD_STORE_ITEM + ~MISC3D~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag29.sto~ ~override~
    ADD_STORE_ITEM + ~DART04~ #40 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag30.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3D~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3M~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

END

// fixes markup issues at Sahuagin and Suldanesselar stores
COPY_EXISTING ~sahpr1.sto~  ~override~ // Sahuagin store
              ~suelf10.sto~ ~override~ // Suldanesselar markup adjustments
  WRITE_LONG 0x14 120
  WRITE_LONG 0x18 50
  BUT_ONLY_IF_IT_CHANGES

// items being under/over charged
COPY_EXISTING ~amsmug01.sto~ ~override~ // Amkethran Smugglers (Carras)
              ~amsmug02.sto~ ~override~ // Amkethran Smugglers (Carras)
              ~bag20.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag21.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag22.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag23.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag24.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag25.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag26.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag27.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag28.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag29.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag30.sto~    ~override~ // Thone of Bhaal Goodwill Bag
  // (unused) ~bdbart01.sto~ ~override~ // Five Flagons
              ~bshop01.sto~  ~override~ // Merchant (Cutpurse) (Bridge District)
              ~bshop02.sto~  ~override~ // Merchant (Storekeep) (Bridge District)
              ~garlena.sto~  ~override~ // Temple of Helm (Sister Garlena) (Watcher's Keep)
              ~ribald.sto~   ~override~ // Adventurers' Mart (Ribald)
  // (unused) ~ribald2.sto~  ~override~ // Adventurers' Mart
              ~ribald3.sto~  ~override~ // Adventurers' Mart (Ribald's special stock)
              ~sahpr1.sto~   ~override~ // Temple of Sekolah (Priestess of Sekolah)
              ~suelf10.sto~  ~override~ // Temple of Rillifane (Rierra)
              ~trcar04.sto~  ~override~ // Merchant (Caravan Merchant) (Trademeet Hut)
              ~trmer02.sto~  ~override~ // Merchant (Merchant) (Trademeet)
  // (unused) ~type1.sto~    ~override~ // Merchant
  // (unused) ~type2.sto~    ~override~ // Adventurers' Mart
              ~uddrow23.sto~ ~override~ // Merchant (Drow) (Ust Natha)
              ~uddrow24.sto~ ~override~ // Shop (Drow) (Ust Natha)
  PATCH_IF (%SOURCE_SIZE% > 0xb4) THEN BEGIN
    READ_LONG 0x34 "io"
    READ_LONG 0x38 "ic"
    FOR ("i1" = 0x00; "i1" < ("ic" * 0x1c); "i1" += 0x1c) BEGIN
      READ_ASCII    ("io" + "i1" + 0x00) "it"
      READ_SHORT    ("io" + "i1" + 0x0a) "c1"
      READ_SHORT    ("io" + "i1" + 0x0c) "c2"
      READ_SHORT    ("io" + "i1" + 0x0e) "c3"
      PATCH_IF          ((NOT "%it%" STRING_COMPARE_CASE "arow02" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Arrows +1
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "ax1h04" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x0a // Throwing Axe
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "boot12" ) AND ("c1"  < 0x02)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x02 // Gargoyle Boots
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "bow10"  ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Heartseeker +3
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "brac16" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Bracers of Blinding Strike
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "bull03" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Bullet +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "dart04" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Dart of Wounding
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3d" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Golden Lion Figurine
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3e" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Black Spider Figurine
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3i" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Silver Horn of Valhalla
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3m" ) AND ("c1"  < 0x03)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x03 // Harp of Discord
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "potn20" ) AND ("c1"  > 0x05)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x05 // Antidote
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "restore") AND ("c2"  > 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x00 // Restoration
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "ring28" ) AND (("c1" = 0x00) OR ("c2" = 0x00))) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Ring of Air Control
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "rods04" ) AND ("c1" != 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x00 // Rod of Smiting
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "rods06" ) AND ("c1"  > 0x0a)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x0a // Rod of Reversal
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "staf16" ) AND (("c2" < 0x1e) OR ("c3" < 0x1e))) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x1e // Staff of Earth +2
        WRITE_SHORT ("io" + "i1" + 0x0e) 0x1e
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "sw1h27" ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Arbane's Sword +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "sw1h33" ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Ras +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "wand05" ) AND ("c2"  < 0x32)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x32 // Wand of Fire
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// pro fixes                                        \\\\\
/////                                                  \\\\\

// color spray arc fix
COPY_EXISTING ~cspray.pro~ ~override~
  WRITE_SHORT 0x206 256
  BUT_ONLY_IF_IT_CHANGES

// power word blind should also affect party/allies
COPY_EXISTING ~holdsumm.pro~ ~override~
  READ_BYTE  0x200 "flags"
  WRITE_BYTE 0x200 ("%flags%" BAND 0b00001010) // removes ally/self exemptin flags
  BUT_ONLY_IF_IT_CHANGES

// missing shadow
COPY_EXISTING ~ICEGLYP.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BAND 0x7f
  BUT_ONLY_IF_IT_CHANGES

// meteor swarm should be 4 rounds, per descript
COPY_EXISTING ~metswarm.pro~ ~override~
  WRITE_BYTE 0x216 4 // should last 4 rounds per descript
  BUT_ONLY_IF_IT_CHANGES

// shadow/bam missing
COPY_EXISTING ~SPATTCK2.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_ASCII 0x010c ~SPSHADOW~ #8
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BOR 0x20
  WRITE_BYTE 0x0115 0x00
  BUT_ONLY_IF_IT_CHANGES

// another shadow
COPY_EXISTING ~SPGREORB.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_ASCII 0x010c ~SPCHRORB~ #8
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BOR 0x20
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// vvc fixes                                        \\\\\
/////                                                  \\\\\

// adds unused sequence
COPY_EXISTING ~SPATTCK1.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x02
  WRITE_LONG 0x6c 0x01
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~spauraff.vvc~ THEN BEGIN

  // wrong sounds for aura o' flamin' death
  COPY_EXISTING ~SPAURAFF.VVC~ ~OVERRIDE~
    WRITE_ASCII 0x78 ~EFF_P114~ #8
    WRITE_ASCII 0x80 ~AFT_P28~ #8
    BUT_ONLY_IF_IT_CHANGES
    
END

// play intro, then normal sequence
COPY_EXISTING ~spbldbtm.VVC~ ~OVERRIDE~
              ~spbldtop.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x02
  WRITE_LONG 0x6c 0x01
  WRITE_LONG 0x90 0x03
  BUT_ONLY_IF_IT_CHANGES

// should have three variations
COPY_EXISTING ~SPCLOUD1.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x03
  WRITE_LONG 0x6c 0x04
  BUT_ONLY_IF_IT_CHANGES

// enables outro in place of middle for smoother animation
COPY_EXISTING ~SPWOOD.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x01
  WRITE_LONG 0x6c 0x03
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// eff fixes                                        \\\\\
/////                                                  \\\\\

// bolt of glory should do same type of damage to all creatures
COPY_EXISTING ~boltund.eff~ ~override~
  WRITE_SHORT 0x22 128 // missile
  BUT_ONLY_IF_IT_CHANGES

// changes Flame o' North's damage bonus to CE from all E
COPY_EXISTING ~flamenor.eff~ ~override~
  WRITE_LONG 0x1c 51
  BUT_ONLY_IF_IT_CHANGES

// change from damage v type (179) to damage (12); see blun12.itm (revised by Wisp)
COPY_EXISTING ~macedisr.eff~ ~override/cddisr.eff~
  WRITE_LONG  0x10 12 // opcode: damage
  WRITE_LONG  0x1c  2 // fixed damage
  WRITE_SHORT 0x20  0 // straight butter, baby
  WRITE_SHORT 0x60  0 // param3 not needed
  BUT_ONLY_IF_IT_CHANGES

// changes bonus damage to undead for IMoD (blun25.itm) to 1d6 + 1 to bring total to 2d6 +4 (revised by Wisp)
COPY_EXISTING ~cddisr.eff~ ~override/macedisu.eff~
  WRITE_LONG 0x1c 1 // fixed damage

// Polymorph other was setting victim's attacks per round to zero; adjusted to one. See spwi415.spl for one other fix.
COPY_EXISTING ~plyrate.eff~ ~override~
  WRITE_LONG 0x1c 1
  BUT_ONLY_IF_IT_CHANGES

// new eff needed for level 20 holy smite
COPY_EXISTING ~SP313L19.EFF~ ~override/SP313L20.EFF~
  WRITE_LONG 0x38 20

// assassin poison should be a save v death, not save v everything
COPY_EXISTING ~SPCL422.EFF~ ~override~
  WRITE_LONG 0x40 0x4 // saving throw vs. death ONLY
  BUT_ONLY_IF_IT_CHANGES

// more assassin poison; damage is incorrect
COPY_EXISTING ~SPCL422A.EFF~ ~override~
  WRITE_LONG 0x1c 0x2 // +2 damage, not 1
  WRITE_LONG 0x20 0x02 // type is incorrect (Nythrun)
  BUT_ONLY_IF_IT_CHANGES

// deathblow has no save and doesn't affect >10 HD creatures
COPY_EXISTING ~QUIVVIS.EFF~ ~override/SPCL902A.EFF~
  WRITE_LONG  0x40 0x0   // no save
  WRITE_SHORT 0x58 0xa  // max HD 10

// greater deathblow has no save and doesn't affect >10 HD creatures
COPY_EXISTING ~QUIVVIS.EFF~ ~override/SPCL903A.EFF~
  WRITE_LONG  0x40 0x0   // no save
  WRITE_SHORT 0x58 0xc  // max HD 12

// display string effs with incorrect timing
COPY_EXISTING ~SPCL906B.EFF~ ~override~
              ~SPIN935D.EFF~ ~override~
              ~STUNSTRG.EFF~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    WRITE_LONG 0x24 0x1 // Instant/Permanent
  END
  BUT_ONLY_IF_IT_CHANGES

// greater earth elem (cleric) is hostile, should match summoner's allegiance
COPY_EXISTING ~SPEART3P.EFF~ ~override~
  WRITE_LONG 0x20 0x0 // set to Match target
  BUT_ONLY_IF_IT_CHANGES

// removing saves from effs; save chances are already handled by the spell file
COPY_EXISTING ~UDEAD66.EFF~  ~override~  // Sol's +6d6 deep-fry
              ~UNDCHSTR.EFF~ ~override~  // "Controlled" str
              ~UNDCHVIS.EFF~ ~override~  // SPNWCHRM for hold spells? L A Z Y
  WRITE_LONG 0x40 0x0
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// music fixes                                      \\\\\
/////                                                  \\\\\

// from remix, devsin
COPY_EXISTING ~music/bc1.mus~ ~music~
  REPLACE_TEXTUALLY ~J1 +B1 +@TAG +ZJ~ ~J1  BC1   B1        @TAG ZJ~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bc2.mus~ ~music~
  REPLACE_TEXTUALLY ~K1 +A2 +@TAG +Z~ ~K1  BC2   A2        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd1.mus~ ~music~
  REPLACE_TEXTUALLY ~E2 +B1 +@TAG +ZB~ ~E2  BD1   B1        @TAG ZB~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd2.mus~ ~music~
  REPLACE_TEXTUALLY ~F2 +B1 +@TAG +ZF~ ~F2  BD2   B1        @TAG ZF~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd2/bd2zg2.acm~ ~music/bd3/bd3zg2.acm~

COPY_EXISTING ~music/bd3.mus~ ~music~
  REPLACE_TEXTUALLY ~G2 +A2 +@TAG +ZG2~ ~G2  BD3   A2        @TAG ZG2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bf1.mus~ ~music~
  REPLACE_TEXTUALLY ~H2 +B1 +@TAG +Z~ ~H2  BF1   B1        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bf2.mus~ ~music~
  REPLACE_TEXTUALLY ~J3 +B1 +@TAG +ZJ3~ ~J3  BF2   B1        @TAG ZJ3~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bjr.mus~ ~music~
  REPLACE_TEXTUALLY "H2 +B1" "H2 BJR B1"
  REPLACE_TEXTUALLY ZA Z
  SET_2DA_ENTRY 11 2 3 ZB
BUT_ONLY  

COPY_EXISTING ~music/bm1.mus~ ~music~
  INSERT_2DA_ROW 11 3 "J1 @TAG ZA"
  INSERT_2DA_ROW 12 3 "J2 BM1 B1 @TAG ZB"
  REPLACE_TEXTUALLY ~H1 +B2~ ~H1~
  SET_2DA_ENTRY 1 0 1 13

COPY_EXISTING ~music/bm2.mus~ ~music~
  REPLACE_TEXTUALLY ~N2 +B1 +@TAG +ZA~ ~N2  BM2   B1        @TAG ZA~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bp1.mus~ ~music~
  REPLACE_TEXTUALLY ~H3 +B1 +@TAG +ZA~ ~H3  BP1   B1        @TAG ZA~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bp2.mus~ ~music~
  REPLACE_TEXTUALLY ~K1 +B1 +@TAG +Z~ ~K1  BP2   B1        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/brd.mus~ ~music~
  REPLACE_TEXTUALLY ~B2 +A1 +@TAG +ZB~ ~B2  BRD   A1        @TAG ZB~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bsd.mus~ ~music~
  REPLACE_TEXTUALLY ~F2A +A2 +@TAG +ZF2~ ~F2A  BSD  A2        @TAG ZF2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bst.mus~ ~music~
  REPLACE_TEXTUALLY ~J1 +C1 +@TAG +ZH2~ ~J1  BST   C1        @TAG ZH2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/harp_v2.mus~ ~music~
  SET_2DA_ENTRY 6 0 1 ~1C~ // the current entry, C (HARP_V2C.ACM), doesn't exist
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/harp_v6.mus~ ~music~
  REPLACE_TEXTUALLY ~^5~ ~6~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/mx0202.mus~ ~music/mxkalah.mus~
  REPLACE_TEXTUALLY ~0202~ ~KALAH~

COPY_EXISTING ~music/mx0202.mus~ ~music/mxkhali.mus~
  REPLACE_TEXTUALLY ~0202~ ~KHALI~

COPY_EXISTING ~music/mx0202.mus~ ~music/mxthief.mus~
  REPLACE_TEXTUALLY ~0202~ ~THIEF~

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  COPY_EXISTING ~music/dream2.mus~ ~music~
    REPLACE_TEXTUALLY ~DREAM~ ~COMBO~

  COPY_EXISTING ~music/mb.mus~ ~music~
    REPLACE_TEXTUALLY ~_F3 +_A2 +@TAG +_G1~ ~_F3  MB  _A2    @TAG _G1~
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~music/vb.mus~ ~music~
    REPLACE_TEXTUALLY ~_H2 +_B2 +@TAG +_I1~ ~_H2  VB    _B2        @TAG _I1~
    BUT_ONLY_IF_IT_CHANGES

END

/////                                                  \\\\\
///// immunity effects batch patches                   \\\\\
/////                                                  \\\\\

// basic idea: if you're protected from, say, confusion, confusion icon and 'confused' messages should also be suppressed

// include macros for batch processing
INCLUDE ~bg2fixpack/lib/macro_fx_batch_prep.tph~

// free action... ugh. just set up immunities, let other batches below fill in the other effects
// unlike others, generate this patch list manually--otherwise it'll turn a simple hold immunity into full-blown free aciton
COPY_EXISTING ~blun30.itm~  ~override~ // foa +5
              ~potn45.itm~  ~override~ // potion of freedom
              ~ring09.itm~  ~override~ // ring of free action
              ~sper12.itm~  ~override~ // ixil's spike +6
              ~sppr403.spl~ ~override~ // spell of free action
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_12" = 0
        SET "new_fx_15" = 0
        SET "new_fx_16" = 0
        SET "new_fx_17" = 0
        SET "new_fx_18" = 0
        SET "new_fx_19" = 0
        SET "new_fx_20" = 0
        SET "new_fx_21" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_12" = 1
        SET "new_fx_15" = 1
        SET "new_fx_16" = 1
        SET "new_fx_17" = 1
        SET "new_fx_18" = 1
        SET "new_fx_19" = 1
        SET "new_fx_20" = 1
        SET "new_fx_21" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      SET "new_fx_9" = 0
      SET "new_fx_10" = 0
      SET "new_fx_11" = 0
      SET "new_fx_13" = 0
      SET "new_fx_14" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        // first, effects to delete (mainly stun immunity)
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 45)) BEGIN // stun immunity
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 210)) BEGIN // pw stun immunity
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 185)) BEGIN // hold creature 2 immunity (hc2 is only used for special, non-defensible holds)
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 55)) BEGIN // prevent stun icon
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1280)) BEGIN // prevent stunned string 
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14043)) BEGIN // prevent stun string
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE

        // effects immunities
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 16)) BEGIN // haste immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 40)) BEGIN // slow immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // paralyzation immunity
          SET "new_fx_3" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 126)) BEGIN // movement rate bonus immunity
          SET "new_fx_4" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 154)) BEGIN // entangle overlay immunity
          SET "new_fx_5" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 157)) BEGIN // web immunity
          SET "new_fx_6" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 158)) BEGIN // grease immunity
          SET "new_fx_7" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 175)) BEGIN // hold immunity
          SET "new_fx_8" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        // one-time effects, other misc effects
        PATCH_IF ("%opcode%" = 46) BEGIN // unstun
          SET "new_fx_9" = 1
        END ELSE
        PATCH_IF ("%opcode%" = 162) BEGIN // remove paralysis
          SET "new_fx_10" = 1
        END ELSE
        PATCH_IF ("%opcode%" = 163) BEGIN // free action
          SET "new_fx_11" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 19)) BEGIN // display free action icon
          SET "new_fx_12" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 126) AND ("%param1%" = 100) AND ("%param2%" = 2)) BEGIN // set movement rate to 100%
          SET "new_fx_13" = 1
        END ELSE
        
        // spell immunities - don't like to explicitly block spells as most effects from these are already nullified
        // however, other effects due to the spells' primary effects would still get through unless whole spell blocked
        // i.e. haste spells can still make you fatigued; slow would still incur THAC0 and AC penalties, etc.
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spcl522" = 0)) BEGIN // protection from spell, defensive spin
          SET "new_fx_14" = 1
        END ELSE

        // remove portrait icons
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 13)) BEGIN // remove held icon
          SET "new_fx_15" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 38)) BEGIN // remove haste icon
          SET "new_fx_16" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 41)) BEGIN // remove slow icon
          SET "new_fx_17" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 55)) BEGIN // remove stun icon
          SET "new_fx_18" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 129)) BEGIN // remove web icon
          SET "new_fx_19" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 144)) BEGIN // remove entangled icon
          SET "new_fx_20" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 145)) BEGIN // remove grease icon
          SET "new_fx_21" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" + "%new_fx_2%" + "%new_fx_3%" + "%new_fx_4%" + "%new_fx_5%" + "%new_fx_6%" + "%new_fx_7%" + "%new_fx_8%" > 0) BEGIN
        // special, this one goes at end
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) 126          // movement rate change immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 16           // haste immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40           // slow immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // paralyzation immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 154          // entangle immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 157          // web immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 158          // grease immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 175          // hold immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 46           // unstun
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 162          // remove paralysis
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_11%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 163          // free action
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_12%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 19           // free action
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_13%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 126          // set movement rate
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // 100%
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 2            // set to
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_14%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spcl522~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_15%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 13           // held
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_16%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 38           // haste
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_17%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41           // slow
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_18%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_19%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 129          // web
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_20%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 144          // entangled
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_21%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 145          // grease
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// entangle
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~aldeth.itm~   ~override~ // ring of free action
              ~bazpatrg.itm~ ~override~ // ring
              ~beholder.itm~ ~override~ // ring
              ~blun30.itm~   ~override~ // flail of ages +5
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~dragring.itm~ ~override~ // ring
              ~freering.itm~ ~override~ // ring of free action
              ~fsspir.itm~   ~override~ // ring
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorchr.itm~   ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gorstalk.cre~ ~override~ // guardian of air
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~mage05.itm~   ~override~ // ring of free action
              ~mistpo01.cre~ ~override~ // poison mist
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~ring97.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~shalt01.itm~  ~override~ // ring
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~sppr403.spl~  ~override~ // free action
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~surehp1.itm~  ~override~ // ring
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 154)) BEGIN // entangle overlay immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 144)) BEGIN // prevent entangled icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin688" = 0)) BEGIN // protection from spell, plant growth
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "sppr105" = 0)) BEGIN // protection from spell, entangle
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm111" = 0)) BEGIN // protection from spell, plant growth
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdhgnya1" = 0)) BEGIN // protection from spell, nyalee
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdmound" = 0)) BEGIN // protection from spell, shambling mound
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdsw1h58" = 0)) BEGIN // protection from spell, ss of mask
          SET "new_fx_8" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 144          // entangled
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin688~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr105~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm111~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdhgnya1~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdmound~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdsw1h58~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// grease
COPY_EXISTING ~blun30.itm~   ~override~ // flail of ages +5
              ~jwsuper.itm~  ~override~ // ring of free action
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~rossring.itm~ ~override~ // ring of free action
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 158)) BEGIN // grease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 145)) BEGIN // prevent grease icon
          SET "new_fx_2" = 1
        END 
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 145          // grease
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// slow
COPY_EXISTING ~aldeth.itm~   ~override~ // ring of free action
              ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~bazpatrg.itm~ ~override~ // ring
              ~beholder.itm~ ~override~ // ring
              ~blun30.itm~   ~override~ // flail of ages +5
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~dragring.itm~ ~override~ // ring
              ~freering.itm~ ~override~ // ring of free action
              ~fsdragon.cre~ ~override~ // dragon
              ~fsspir.itm~   ~override~ // ring
              ~golstone.itm~ ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killmonk.cre~ ~override~ // monk
              ~killsw01.itm~ ~override~ // long sword +2
              ~kuoring.itm~  ~override~ // <invalid strref -1>
              ~mage05.itm~   ~override~ // ring of free action
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~npsw01.itm~   ~override~ // sword of arvoreen
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~ring97.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~senmonk.cre~  ~override~ // master bennon
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~sppr403.spl~  ~override~ // free action
              ~surehp1.itm~  ~override~ // ring
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
              ~tobpar03.cre~ ~override~ // long po
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      SET "new_fx_9" = 0
      SET "new_fx_10" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 40)) BEGIN // slow immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 41)) BEGIN // prevent slow icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm164" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin977" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin983" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwish25" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi312" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin575" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_8" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14000)) BEGIN // disable string "slow"
          SET "new_fx_9" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14668)) BEGIN // disable string "slowed"
          SET "new_fx_10" = 1
        END

      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41           // slow
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm164~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin977~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin983~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish25~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi312~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin575~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14000        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14668        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// confusion
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul17.itm~   ~override~ // greenstone amulet
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~elearb11.cre~ ~override~ // apparition
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~firlch01.cre~ ~override~ // fire lich
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~killsw01.itm~ ~override~ // long sword +2
              ~leat20.itm~   ~override~ // aeger's hide +3
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~maharper.itm~ ~override~ // master harper item
              ~mane01.itm~   ~override~ // ring
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn21.itm~   ~override~ // potion of clarity
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~ringkora.itm~ ~override~ // ring
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spcl542a.spl~ ~override~ // <invalid strref -1>
              ~spcl920a.spl~ ~override~ // <invalid strref -1>
              ~spin117.spl~  ~override~ // berserk
              ~spin632.spl~  ~override~ // emperor
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~susuneer.cre~ ~override~ // suneer
              ~sw1h54.itm~   ~override~ // the equalizer
              ~sw2h14.itm~   ~override~ // lilarcor
              ~sw2h21.itm~   ~override~ // psion's blade +5
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
              ~udsola01.cre~ ~override~ // solaufein
              ~umber01.itm~  ~override~ // attack
              ~umber02.itm~  ~override~ // attack
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
        SET "new_fx_3" = 1
        SET "new_fx_4" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 128)) BEGIN // confusion immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 2)) BEGIN // prevent rigid thinking icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 3)) BEGIN // prevent confused icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 47)) BEGIN // prevent chaos icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14782)) BEGIN // disable string "confused"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14791)) BEGIN // disable string "Rigid Thinking"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spconfus" = 0)) BEGIN // confusion visuals
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 2            // rigid thinking
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 3            // confused
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 47           // chaos
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14782        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14791        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spconfus~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// level drain
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~balth02.spl~  ~override~ // lunar stance!
              ~bazpatrg.itm~ ~override~ // ring
              ~bhaal3a.spl~  ~override~ // <invalid strref -1>
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~blun25.itm~   ~override~ // mace of disruption +2
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~deva.itm~     ~override~ // mace of disruption +2
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~famcat25.cre~ ~override~ // cat
              ~famdus25.cre~ ~override~ // dust mephit
              ~famfai25.cre~ ~override~ // fairy dragon
              ~famfer25.cre~ ~override~ // ferret
              ~famimp25.cre~ ~override~ // imp
              ~fampsd25.cre~ ~override~ // pseudo dragon
              ~famqua25.cre~ ~override~ // quasit
              ~famrab25.cre~ ~override~ // rabbit
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~hamm10.itm~   ~override~ // runehammer +4
              ~hamm11.itm~   ~override~ // runehammer +5
              ~holdring.itm~ ~override~ // ring
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~mel01.itm~    ~override~ // imoen's belt
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring97.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl242.spl~  ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl741.spl~  ~override~ // boon of lathander
              ~spcl917.spl~  ~override~ // avoid death
              ~spin117.spl~  ~override~ // berserk
              ~spin783.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~sppr413.spl~  ~override~ // negative plane protection
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h61.itm~   ~override~ // angurvadal +5
              ~sw1h69.itm~   ~override~ // spectral brand +5
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
              ~vvarkan.cre~  ~override~ // arkanis gath
              ~vvcat.cre~    ~override~ // shadow thief
              ~vvryokoi.cre~ ~override~ // ryokoi
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_3" = 0
        END ELSE BEGIN
          SET "new_fx_3" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 216)) BEGIN // level drain immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 90)) BEGIN // display npp icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 59)) BEGIN // prevent level drain icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 41495)) BEGIN // disable string "one level drained"
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40968)) BEGIN // disable string "two levels drained"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40969)) BEGIN // disable string "three levels drained"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40979)) BEGIN // disable string "four levels drained"
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 41616)) BEGIN // disable string "five levels drained"
          SET "new_fx_8" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 90           // npp
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 59           // level drain
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41495        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40968        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40969        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40979        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41616        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// hold
COPY_EXISTING ~aldeth.itm~   ~override~ // ring of free action
              ~amul17.itm~   ~override~ // greenstone amulet
              ~antiweb.itm~  ~override~ // <invalid strref -1>
              ~beholder.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~blun30.itm~   ~override~ // flail of ages +5
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demglab.cre~  ~override~ // glabrezu
              ~demglab2.cre~ ~override~ // glabrezu
              ~demglasu.cre~ ~override~ // glabrezu
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~enddem01.cre~ ~override~ // glabrezu
              ~enddem02.cre~ ~override~ // glabrezu
              ~enddem03.cre~ ~override~ // balor
              ~enddem04.cre~ ~override~ // nabassu
              ~enddem05.cre~ ~override~ // nabassu
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~freering.itm~ ~override~ // ring of free action
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jondem01.cre~ ~override~ // glabrezu
              ~jondem02.cre~ ~override~ // balor
              ~jondem03.cre~ ~override~ // glabrezu
              ~jondem04.cre~ ~override~ // balor
              ~jondem05.cre~ ~override~ // glabrezu
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~kuoring.itm~  ~override~ // <invalid strref -1>
              ~lich.itm~     ~override~ // ring
              ~mage05.itm~   ~override~ // ring of free action
              ~magiweb.itm~  ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~potn45.itm~  ~override~ // potion of freedom
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring09.itm~   ~override~ // ring of free action
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring97.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl233b.spl~ ~override~ // <invalid strref -1>
              ~spcl242.spl~  ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin117.spl~  ~override~ // berserk
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr403.spl~  ~override~ // free action
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h27.itm~   ~override~ // arbane's sword +2
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~torgal.cre~   ~override~ // torgal
              ~torgal2.cre~  ~override~ // torgal
              ~torgal3.cre~  ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~trollimm.itm~ ~override~ // ring
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF (("%cosmetic%" = 1) OR ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0)) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // hold immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 175)) BEGIN // hold creature type immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 185)) BEGIN // hold creature 2 immunity
          SET "new_fx_3" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 13)) BEGIN // prevent hold icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14102)) BEGIN // disable string "held"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spmindat" = 0)) BEGIN // disable held animation
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spflayer" = 0)) BEGIN // disable held animation
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1) OR ("%new_fx_3%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // hold immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 175          // hold creature type immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 13           // hold icon
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14102        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spmindat~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spflayer~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// fear
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amsmith.cre~  ~override~ // kerrick the smith
              ~amul17.itm~   ~override~ // greenstone amulet
              ~balth.cre~    ~override~ // balthazar
              ~bazdra02.cre~ ~override~ // draconis
              ~bazpatrg.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~brdflute.itm~ ~override~ // magic flute
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~clck30.itm~   ~override~ // cloak of bravery
              ~ddguard1.cre~ ~override~ // guardian
              ~ddguard2.cre~ ~override~ // guardian
              ~ddguard3.cre~ ~override~ // guardian
              ~ddguard4.cre~ ~override~ // guardian
              ~ddguard5.cre~ ~override~ // guardian
              ~ddguard6.cre~ ~override~ // guardian
              ~ddguard7.cre~ ~override~ // guardian
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~elemhydr.cre~ ~override~ // olhydra
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~firlch01.cre~ ~override~ // fire lich
              ~fsspir.itm~   ~override~ // ring
              ~golbra01.cre~ ~override~ // brain golem
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorcamb6.cre~ ~override~ // fell cat
              ~gorcamb7.cre~ ~override~ // fell cat
              ~gorchr.itm~   ~override~ // ring
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gorstalk.cre~ ~override~ // guardian of air
              ~hamm11.itm~   ~override~ // runehammer +5
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~helm14.itm~   ~override~ // kiel's helmet
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hgfel01.cre~  ~override~ // fell cat
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~holdring.itm~ ~override~ // ring
              ~igolem01.cre~ ~override~ // sewage golem
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~kaypal02.cre~ ~override~ // reynald de chatillon
              ~kaypal03.cre~ ~override~ // fallen paladin
              ~kaysmg01.cre~ ~override~ // rindus
              ~kaysmg02.cre~ ~override~ // smuggler
              ~kaysmg03.cre~ ~override~ // smuggler
              ~killsw01.itm~ ~override~ // long sword +2
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~maharper.itm~ ~override~ // master harper item
              ~mane01.itm~   ~override~ // ring
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~mdog1.itm~    ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~miscbc.itm~   ~override~ // blackrazor
              ~mistpo01.cre~ ~override~ // poison mist
              ~nofear.itm~   ~override~ // <invalid strref -1>
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~potn21.itm~   ~override~ // potion of clarity
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~ringkora.itm~ ~override~ // ring
              ~sarvie01.cre~ ~override~ // viekang
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl221.spl~  ~override~ // <invalid strref -1>
              ~spcl222.spl~  ~override~ // remove fear
              ~spcl321.spl~  ~override~ // enrage
              ~spcl542a.spl~ ~override~ // <invalid strref -1>
              ~spcl920a.spl~ ~override~ // <invalid strref -1>
              ~spcl921a.spl~ ~override~ // <invalid strref -1>
              ~spec01.itm~   ~override~ // ring
              ~spec02.itm~   ~override~ // <invalid strref -1>
              ~spin117.spl~  ~override~ // berserk
              ~spin676.spl~  ~override~ // invoke courage
              ~spin823.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin891.spl~  ~override~ // moon dog howl
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr108.spl~  ~override~ // remove fear
              ~spwi210.spl~  ~override~ // resist fear
              ~spwi411.spl~  ~override~ // emotion
              ~stalker.itm~  ~override~ // ring
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~surehp1.itm~  ~override~ // ring
              ~susuneer.cre~ ~override~ // suneer
              ~sw1h32.itm~   ~override~ // dragonslayer
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~torgal.cre~   ~override~ // torgal
              ~torgal2.cre~  ~override~ // torgal
              ~torgal3.cre~  ~override~ // torgal
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
              ~udgolem.cre~  ~override~ // brain golem
              ~udlesa.cre~   ~override~ // lasaonar
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_9" = 0
        SET "new_fx_10" = 0
        SET "new_fx_11" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_11" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_9" = 0
          SET "new_fx_10" = 0
        END ELSE BEGIN
          SET "new_fx_9" = 1
          SET "new_fx_10" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 23)) BEGIN // morale modifer immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 24)) BEGIN // horror immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 106)) BEGIN // morale break modifier immunity
          SET "new_fx_3" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF ("%opcode%" = 23) BEGIN // morale
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF ("%opcode%" = 161) BEGIN // cure horror
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 106) AND ("%param2%" = 1)) BEGIN // morale break modifier
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14007)) BEGIN // disable string "panic"
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 17427)) BEGIN // disable string "panic"
          SET "new_fx_8" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 36)) BEGIN // prevent panic icon
          SET "new_fx_9" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 36)) BEGIN // remove panic icon
          SET "new_fx_10" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 37)) BEGIN // display resist fear icon
          SET "new_fx_11" = 1
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1) OR ("%new_fx_3%" = 1)) BEGIN
        // put three immunities at end of effects, others first so immunities don't prevent other new/ existing effects
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 23           // modify morale imunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 24           // panic imunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 106          // morale break modifier immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 23           // modify morale
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param1
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param2
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 161          // cure horror
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param1
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param2
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 106          // morale break
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // param1
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // param2
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14007        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 17427        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 36           // panic icon
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 36           // panic icon
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_11%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 37           // resist fear icon
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// charm
COPY_EXISTING ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul17.itm~   ~override~ // greenstone amulet
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~c6guen.cre~   ~override~ // guenhwyvar
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chevil02.cre~ ~override~ // doppleganger
              ~chevil06.cre~ ~override~ // drow warrior
              ~chevil07.cre~ ~override~ // drow priestess
              ~chgood04.cre~ ~override~ // elven warrior
              ~chgood05.cre~ ~override~ // elven warrior
              ~chgood09.cre~ ~override~ // ellesime
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~cuphaer.cre~  ~override~ // phaere
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~dragring.itm~ ~override~ // ring
              ~drow05.cre~   ~override~ // drow
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~golbra01.cre~ ~override~ // brain golem
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorcamb6.cre~ ~override~ // fell cat
              ~gorcamb7.cre~ ~override~ // fell cat
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gorstalk.cre~ ~override~ // guardian of air
              ~helm06.itm~   ~override~ // helm of charm protection
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hgfel01.cre~  ~override~ // fell cat
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~killmonk.cre~ ~override~ // monk
              ~killsw01.itm~ ~override~ // long sword +2
              ~maharper.itm~ ~override~ // master harper item
              ~mane01.itm~   ~override~ // ring
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~mdog1.itm~    ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~miscbc.itm~   ~override~ // blackrazor
              ~mistpo01.cre~ ~override~ // poison mist
              ~npchan.itm~   ~override~ // corthala family armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn21.itm~   ~override~ // potion of clarity
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~reaver.itm~   ~override~ // unholy reaver
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~sendai.cre~   ~override~ // sendai
              ~sendai2.cre~  ~override~ // sendai
              ~sendai3.cre~  ~override~ // sendai
              ~sendai4.cre~  ~override~ // sendai
              ~sendai5.cre~  ~override~ // sendai
              ~sendai6.cre~  ~override~ // sendai
              ~sendai7.cre~  ~override~ // sendai
              ~sendai8.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~senmonk.cre~  ~override~ // master bennon
              ~shalt01.itm~  ~override~ // ring
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl221.spl~  ~override~ // <invalid strref -1>
              ~spcl233b.spl~ ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~spcl817.spl~  ~override~ // <invalid strref -1>
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~spin117.spl~  ~override~ // berserk
              ~spin121.spl~  ~override~ // protection from evil
              ~spin632.spl~  ~override~ // emperor
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~staf11.itm~   ~override~ // staff of the magi
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h35.itm~   ~override~ // adjatha the drinker +2
              ~sw1h54.itm~   ~override~ // the equalizer
              ~sw2h14.itm~   ~override~ // lilarcor
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tobpar03.cre~ ~override~ // long po
              ~torgal.cre~   ~override~ // torgal
              ~torgal2.cre~  ~override~ // torgal
              ~torgal3.cre~  ~override~ // torgal
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udgolem.cre~  ~override~ // brain golem
              ~udphae01.cre~ ~override~ // phaere
              ~udsola01.cre~ ~override~ // solaufein
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
        SET "new_fx_8" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_8" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_2" = 0
          SET "new_fx_3" = 0
          SET "new_fx_4" = 0
        END ELSE BEGIN
          SET "new_fx_2" = 1
          SET "new_fx_3" = 1
          SET "new_fx_4" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_9" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 5)) BEGIN // charm immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 0)) BEGIN // prevent charm icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 1)) BEGIN // prevent dire charm icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 43)) BEGIN // prevent domination icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14672)) BEGIN // disable string "charmed"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14780)) BEGIN // disable string "dire charmed"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spnwchrm" = 0)) BEGIN // disable charmed visuals
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 52)) BEGIN // display mind shield icon
          SET "new_fx_8" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 8364)) BEGIN // disable string "dominated"
          SET "new_fx_9" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // charm
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // dire charm
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 43           // domination
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14672        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14780        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spnwchrm~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 52           // mind shield
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8364         // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// haste
COPY_EXISTING ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~blun30.itm~   ~override~ // flail of ages +5
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~finmel01.cre~ ~override~ // melissan
              ~killmonk.cre~ ~override~ // monk
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~senmonk.cre~  ~override~ // master bennon
              ~spcl521.spl~  ~override~ // offensive spin
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~sppr403.spl~  ~override~ // free action
              ~tobpar03.cre~ ~override~ // long po
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 16)) BEGIN // haste immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 38)) BEGIN // prevent haste icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14023)) BEGIN // disable string "hasted"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin572" = 0)) BEGIN // protection from spell
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin828" = 0)) BEGIN // protection from spell
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spra301" = 0)) BEGIN // protection from spell
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi305" = 0)) BEGIN // protection from spell
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 38           // haste
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14023        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin572~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin828~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spra301~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi305~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// disease (revised by Wisp; reduced damage from poison is now in its own batch, since it is both immunity to disease as well as poison)
COPY_EXISTING ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~misc8j.itm~   ~override~ // boots of the west
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring39.itm~   ~override~ // ring of gaxx
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sword01.cre~  ~override~ // magical sword
              ~tstatue.itm~  ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      //SET "new_fx_5" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 78)) BEGIN // disease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 7)) BEGIN // prevent nauseated icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 39752)) BEGIN // disable string "stricken by a foul disease"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 54337)) BEGIN // disable string "diseased"
          SET "new_fx_4" = 1
        END //ELSE
        //PATCH_IF (("%opcode%" = 173) AND ("%param1%" = 100)) BEGIN // reduced damage from poison - 100%
        //  SET "new_fx_5" = 1
        //END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 7            // nauseated
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 39752        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 54337        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        //PATCH_IF ("%new_fx_5%" = 0) BEGIN
        //  INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
        //    WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
        //    WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 173          // reduced damage from poison
        //    WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // value
        //  SET "new_fx" = ("%new_fx%" + 1)
        //  SET "counter" = ("%counter%" + 1)
        //END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// poison resistance (immunity to both disease damage and poison damage)
COPY_EXISTING demogorg.itm override //<Invalid Strref -1>
              finmel01.itm override //<Invalid Strref -1>
              minhp1.itm   override //<Invalid Strref -1>
              ravag03.itm  override //<Invalid Strref -1>
              ring39.itm   override //Ring of Gaxx
              sengua04.itm override //<Invalid Strref -1>
              tstatue.itm  override //<Invalid Strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop); index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0; index2 < counter; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 78)) BEGIN // disease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 25)) BEGIN // poison immunity
          SET "new_fx_2" = 1
        END
        PATCH_IF (("%opcode%" = 173)) BEGIN // poison resistance
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1 AND new_fx_2 = 1 AND new_fx_3 = 0) BEGIN
        INSERT_BYTES   ("%fx_off%"                                 + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
        WRITE_ASCIIE ("%fx_off%"                                   + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
        WRITE_SHORT  ("%fx_off%"            + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 173          // reduced damage from poison
        WRITE_LONG   ("%fx_off%" + 0x04     + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // value
        SET "new_fx" = ("%new_fx%" + 1)
        SET "counter" = ("%counter%" + 1)
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
BUT_ONLY_IF_IT_CHANGES  

// poison
COPY_EXISTING ~amcst02.cre~  ~override~ // mercenary
              ~amcst03.cre~  ~override~ // mercenary
              ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk03.cre~ ~override~ // monk
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul22.itm~   ~override~ // periapt of proof against poison
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~barl.cre~     ~override~ // barl
              ~barlfl.itm~   ~override~ // flail
              ~bazdra02.cre~ ~override~ // draconis
              ~bazdra03.cre~ ~override~ // fll'yissetat
              ~bazmonk.cre~  ~override~ // monk
              ~bazpatrg.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demosum1.cre~ ~override~ // marilith
              ~deriny01.cre~ ~override~ // erinyes
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~dimp01.cre~   ~override~ // imp
              ~elemprin.itm~ ~override~ // <invalid strref -1>
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~fsdragon.cre~ ~override~ // dragon
              ~fsspir.itm~   ~override~ // ring
              ~golbra.itm~   ~override~ // brain golem item
              ~golbra01.cre~ ~override~ // brain golem
              ~golcla.itm~   ~override~ // clay golem item
              ~golcla01.cre~ ~override~ // clay golem
              ~golem01.cre~  ~override~ // clay golem
              ~golfle.itm~   ~override~ // flesh golem item
              ~golice01.cre~ ~override~ // ice golem
              ~goljug01.cre~ ~override~ // juggernaut golem
              ~golmag01.itm~ ~override~ // magic golem item
              ~golsan01.cre~ ~override~ // sand golem
              ~golsto01.cre~ ~override~ // stone golem
              ~golstone.itm~ ~override~ // stone golem item
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorbat2.cre~  ~override~ // erinyes
              ~gorbat3.cre~  ~override~ // cornugon
              ~gorbat4.cre~  ~override~ // imp
              ~gorcamb6.cre~ ~override~ // fell cat
              ~gorcamb7.cre~ ~override~ // fell cat
              ~gorfirg.itm~  ~override~ // ring
              ~gorgua01.cre~ ~override~ // aurumach rilmani
              ~gorgua02.cre~ ~override~ // ferrumach rilmani
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gormistp.itm~ ~override~ // ring
              ~gorwom01.cre~ ~override~ // nalmissra
              ~gorwom03.cre~ ~override~ // y'tossi
              ~gorwom04.cre~ ~override~ // ameralis zauviir
              ~helm30.itm~   ~override~ // thieves' hood
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hgfel01.cre~  ~override~ // fell cat
              ~holdring.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~irongol.itm~  ~override~ // iron golem item
              ~killmonk.cre~ ~override~ // monk
              ~mdog1.itm~    ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~melsum05.cre~ ~override~ // marilith
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~morsword.itm~ ~override~ // mordenkainen's sword
              ~nishrusu.cre~ ~override~ // nishruu
              ~objring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ppiron.cre~   ~override~ // clay golem
              ~pudden01.cre~ ~override~ // dense pudding
              ~pudden02.cre~ ~override~ // dense pudding
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring39.itm~   ~override~ // ring of gaxx
              ~ring46.itm~   ~override~ // ring of anti-venom
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~ringkora.itm~ ~override~ // ring
              ~scrl08.itm~   ~override~ // protection from poison
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~senmonk.cre~  ~override~ // master bennon
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl221.spl~  ~override~ // <invalid strref -1>
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl818.spl~  ~override~ // <invalid strref -1>
              ~spcl924.spl~  ~override~ // <invalid strref -1>
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
//              ~spwi413.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h34.itm~   ~override~ // albruin +1
              ~telimp1.cre~  ~override~ // imp
              ~telpit1.cre~  ~override~ // pit fiend
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tobpar03.cre~ ~override~ // long po
              ~tomegol2.cre~ ~override~ // clay golem
              ~tomegol3.cre~ ~override~ // stone golem
              ~trolldie.itm~ ~override~ // <invalid strref -1>
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udgolem.cre~  ~override~ // brain golem
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
        SET "new_fx_5" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_5" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_3" = 0
          SET "new_fx_4" = 0
        END ELSE BEGIN
          SET "new_fx_3" = 1
          SET "new_fx_4" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 25)) BEGIN // poison immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 6)) BEGIN // prevent poison icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 137)) BEGIN // prevent bleeding icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 30)) BEGIN // display protection from poison icon
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14662)) BEGIN // disable string "poisoned"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14017)) BEGIN // disable string "poison"
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 6            // poison
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 137          // bleeding
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 30           // protection from poison
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14662        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14017        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// web
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~bazpatrg.itm~ ~override~ // ring
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gortan3.cre~  ~override~ // yochlol
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~mistpo01.cre~ ~override~ // poison mist
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~potn45.itm~   ~override~ // potion of freedom
              ~rossring.itm~ ~override~ // ring of free action
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      // special block for WK statues
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "holdring" = 0) BEGIN // should still be vulnerable to opcode 109
        SET "new_fx_2" = 1
      END ELSE BEGIN
        SET "new_fx_2" = 0
      END
      SET "new_fx_1" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 157)) BEGIN // web immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // paralyze
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 129)) BEGIN // prevent webbed icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14102)) BEGIN // disable string "held"
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // paralyzation immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 129          // webbed
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14102        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// additional spell immunites
COPY_EXISTING ~aurstaf.itm~  ~override~ // staff of the ram +4
              ~balth.cre~    ~override~ // balthazar
              ~bazpatrg.itm~ ~override~ // ring
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~fsspir.itm~   ~override~ // ring
              ~golmag01.cre~ ~override~ // magic golem
              ~holdring.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~invulner.itm~ ~override~ // ring
              ~jwglobe.spl~  ~override~ // globe of invulnerability
              ~lich.itm~     ~override~ // ring
              ~mageamul.itm~ ~override~ // necklace
              ~misc73.itm~   ~override~ // the horn of kazgaroth
              ~potn33.itm~   ~override~ // potion of magic blocking
              ~rakring.itm~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~scrl07.itm~   ~override~ // protection from magic
              ~spcl415a.spl~ ~override~ // otiluke's resilient sphere
              ~spellh01.itm~ ~override~ // skull
              ~spwi406.spl~  ~override~ // minor globe of invulneribility
              ~spwi413a.spl~ ~override~ // otiluke's resilient sphere
              ~spwi602.spl~  ~override~ // globe of invulnerability
//              ~spwi954.spl~  ~override~ // selune's blessing
              ~spwm126.spl~  ~override~ // minor globe of invulneribility
              ~ucounter.cre~ ~override~ // <invalid strref -1>
              ~uhostile.cre~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
//  SET "debug" = 1
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1_0" = 0
      SET "new_fx_1_1" = 0
      SET "new_fx_2_0" = 0
      SET "new_fx_2_1" = 0
      SET "new_fx_2_2" = 0
      SET "new_fx_2_3" = 0
      SET "new_fx_3_0" = 0
      SET "new_fx_3_1" = 0
      SET "new_fx_3_2" = 0
      SET "new_fx_3_3" = 0
      SET "new_fx_3_4" = 0
      SET "new_fx_3_5" = 0
      SET "new_fx_4_0" = 0
      SET "new_fx_5_0" = 0
      SET "new_fx_5_1" = 0
      SET "new_fx_6_0" = 0
      SET "new_fx_6_1" = 0
      SET "new_fx_6_2" = 0
      SET "new_fx_7_0" = 0
      SET "new_fx_7_1" = 0
      SET "new_fx_7_2" = 0
      SET "new_fx_7_3" = 0
      SET "new_fx_7_4" = 0
      SET "new_fx_7_5" = 0
      SET "new_fx_7_6" = 0
      SET "new_fx_8_0" = 0
      SET "new_fx_8_1" = 0
      SET "new_fx_8_2" = 0
      SET "new_fx_8_3" = 0
      SET "new_fx_8_4" = 0
      SET "new_fx_9_0" = 0
      SET "new_fx_9_1" = 0
      SET "new_fx_9_2" = 0
      SET "new_fx_9_3" = 0
      SET "new_fx_9_4" = 0
      SET "new_fx_9_5" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        PATCH_IF ("%opcode%" = 102) BEGIN // immunity to spell level
          PATCH_IF ("%param1%" = 1) BEGIN
            SET "new_fx_1_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template1" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 2) BEGIN
            SET "new_fx_2_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template2" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 3) BEGIN
            SET "new_fx_3_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template3" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 4) BEGIN
            SET "new_fx_4_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template4" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 5) BEGIN
            SET "new_fx_5_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template5" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 6) BEGIN
            SET "new_fx_6_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template6" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 7) BEGIN
            SET "new_fx_7_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template7" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 8) BEGIN
            SET "new_fx_8_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template8" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 9) BEGIN
            SET "new_fx_9_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template9" ((0x30 + (0xd8 * "%fx_type%")))
          END
        END ELSE
        PATCH_IF ("%opcode%" = 206) BEGIN // immunity to spell
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr105" = 0) BEGIN
            SET "new_fx_1_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi215" = 0) BEGIN
            SET "new_fx_2_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi213" = 0) BEGIN
            SET "new_fx_2_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr211" = 0) BEGIN
            SET "new_fx_2_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi313" = 0) BEGIN
            SET "new_fx_3_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr314" = 0) BEGIN
            SET "new_fx_3_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr313" = 0) BEGIN
            SET "new_fx_3_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr304" = 0) BEGIN
            SET "new_fx_3_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr302" = 0) BEGIN
            SET "new_fx_3_5" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi502" = 0) BEGIN
            SET "new_fx_5_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi614" = 0) BEGIN
            SET "new_fx_6_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr603d" = 0) BEGIN
            SET "new_fx_6_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi712" = 0) BEGIN
            SET "new_fx_7_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr725d" = 0) BEGIN
            SET "new_fx_7_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr719" = 0) BEGIN
            SET "new_fx_7_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr718" = 0) BEGIN
            SET "new_fx_7_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr706" = 0) BEGIN
            SET "new_fx_7_5" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr705" = 0) BEGIN
            SET "new_fx_7_6" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi817" = 0) BEGIN
            SET "new_fx_8_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi816" = 0) BEGIN
            SET "new_fx_8_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi811" = 0) BEGIN
            SET "new_fx_8_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi810" = 0) BEGIN
            SET "new_fx_8_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish35" = 0) BEGIN
            SET "new_fx_9_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish32" = 0) BEGIN
            SET "new_fx_9_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish27" = 0) BEGIN
            SET "new_fx_9_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish25" = 0) BEGIN
            SET "new_fx_9_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi911" = 0) BEGIN
            SET "new_fx_9_5" = 1
          END
        END
      END
      PATCH_IF ("%new_fx_1_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_1_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template1%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr105~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_2_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_2_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi215~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi213~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr211~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_3_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_3_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi313~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr314~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr313~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr304~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr302~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_5_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_5_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template5%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi502~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_6_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_6_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template6%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi614~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template6%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr603d~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_7_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_7_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206           // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff    // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi712~ #8  // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206           // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff    // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr725d~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr719~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr718~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr706~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr705~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_8_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_8_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi817~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi816~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi811~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi810~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_9_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_9_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish35~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish32~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish27~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish25~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi911~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Game text update                                 \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @1000 DESIGNATED 1000 // GTU Light (by Wisp)
SUBCOMPONENT @1  // Game text update
REQUIRE_PREDICATE ("%LANGUAGE%" STRING_COMPARE_CASE "ENGLISH" = 0) @5

INCLUDE ~bg2fixpack/lib/gtul.tpa~


BEGIN @1001 DESIGNATED 1001 // GTU Classic (from Baldurdash, by Kevin Dorner)
SUBCOMPONENT @1  // Game text update
REQUIRE_PREDICATE ("%LANGUAGE%" STRING_COMPARE_CASE "ENGLISH" = 0) @5

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0001.g3~

INCLUDE ~bg2fixpack/lib/gtu.tph~

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// modder pack                                      \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @3 DESIGNATED 2 // modder pack

/////                                                  \\\\\
///// IDS/2DA changes                                  \\\\\
/////                                                  \\\\\

// expanded IDS entries; included as libraries so other modders can nab them
INCLUDE ~bg2fixpack/lib/ids_entries_animate.tph~
INCLUDE ~bg2fixpack/lib/ids_entries_anisnd.tph~
INCLUDE ~bg2fixpack/lib/ids_entries_gtimes.tph~
INCLUDE ~bg2fixpack/lib/ids_entries_shoutids.tph~
// INCLUDE ~bg2fixpack/lib/ids_entries_specific.tph~ // no one was happy with these entries
INCLUDE ~bg2fixpack/lib/ids_entries_spell.tph~

COPY_EXISTING ~damages.ids~ ~override~
  REPLACE_TEXTUALLY ~^0x0001 \(.+\)$~ 
~IDS V1.0
0x0001 \1~
  UNLESS ~^IDS V1\.0~

COPY_EXISTING ~happy.ids~ ~override~
  REPLACE_TEXTUALLY ~^-300 \(.+\)$~
~IDS V1.0
-300 \1~
  UNLESS ~^IDS V1\.0~

ACTION_IF NOT FILE_EXISTS_IN_GAME ~moraleai.ids~ THEN BEGIN
  COPY ~bg2fixpack/ids/moraleai.ids~ ~override~
END

COPY_EXISTING ~slots.ids~    ~override~
              ~soundoff.ids~ ~override~
  REPLACE_TEXTUALLY ~^0 \(.+\)$~ 
~IDS V1.0
0 \1~
  UNLESS ~^IDS V1\.0~

COPY_EXISTING ~state.ids~ ~override~
  REPLACE_TEXTUALLY ~^0x00000000 \(.+\)$~
~IDS V1.0
0x00000000 \1~
  UNLESS ~^IDS V1\.0~

// adds custom IsValidForPartyDialogue state
APPEND ~STATE.IDS~
  ~0x80101FEF CD_STATE_NOTVALID~
  UNLESS ~CD_STATE_NOTVALID~

// Due to there being a limit to the size of songlist.2da it has become common
// practice to replace the 0th entry with a blank song and then run a wav instead. mus file below.
COPY_EXISTING ~songlist.2da~ ~override/songlist.2da~
  SET_2DA_ENTRY 2 1 2 ~G3Blank~
  SET_2DA_ENTRY 2 2 2 ~G3Blank.mus~

/*
areas with non-conventional naming convention:
ar0021 - assigned ar0004.bcs (DNE), ar0021.bcs also DNE
ar0315 - assigned ar0006.bcs (DNE), ar0315.bcs also DNE
ar0316 - assigned ar0007.bcs (DNE), ar0316.bcs also DNE
ar0518 - assigned ar0517.bcs, ar0518.bcs DNE.
ar0519 - assigned ar0517.bcs, ar0519.bcs DNE.
ar0520 - assigned ar0517.bcs, ar0520.bcs DNE.
ar0521 - assigned ar0517.bcs, ar0521.bcs DNE.
  Fine; ar0517 - ar0521 are all planar prison sinkhole traps and area script just has a DisplayString head
ar0707 - assigned ar0003.bcs (DNE), ar0707.bcs also DNE
ar1107 - assigned ar1102.bcs, ar1107.bcs also exists
  ar1102 and ar1107 are the ranger cabin, pre- and post-stronghold. ar1107 jus moves globals from ar1102, so this should be fine
ar1603 - assigned ar0001.bcs (DNE), ar1603.bcs also DNE
ar1604 - assigned ar0609.bcs (DNE), ar1604.bcs also DNE
  copied from ar0609 in BG
ar1612 - assigned ar0005.bcs (DNE), ar0612.bcs also DNE
ar2001 - assigned ar0001.bcs (DNE) but ar2001.bcs is leftover from BG
*/

// assigns area scripts to areas with none assigned
COPY_EXISTING ~ar0061.are~ ~override~
              ~ar0082.are~ ~override~
              ~ar0086.are~ ~override~
              ~ar0206.are~ ~override~
              ~ar0302.are~ ~override~
              ~ar0303.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0306.are~ ~override~
              ~ar0310.are~ ~override~
              ~ar0331.are~ ~override~
              ~ar0332.are~ ~override~
              ~ar0333.are~ ~override~
              ~ar0335.are~ ~override~
              ~ar0412.are~ ~override~
              ~ar0503.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0509.are~ ~override~
              ~ar0527.are~ ~override~
              ~ar0528.are~ ~override~
              ~ar0712.are~ ~override~
              ~ar0713.are~ ~override~
              ~ar0714.are~ ~override~
              ~ar0805.are~ ~override~
              ~ar0806.are~ ~override~
              ~ar0807.are~ ~override~
              ~ar0810.are~ ~override~
              ~ar0811.are~ ~override~
              ~ar0812.are~ ~override~
              ~ar0813.are~ ~override~
              ~ar1010.are~ ~override~
              ~ar1101.are~ ~override~
              ~ar1103.are~ ~override~
              ~ar1201.are~ ~override~
              ~ar1203.are~ ~override~
              ~ar1610.are~ ~override~
              ~ar2014.are~ ~override~
              ~ar2015.are~ ~override~
              ~ar2016.are~ ~override~
              ~ar2018.are~ ~override~
              ~ar2210.are~ ~override~
              ~ar2810.are~ ~override~
              ~ar2811.are~ ~override~
              ~ar3003.are~ ~override~
              ~ar3006.are~ ~override~
              ~ar3010.are~ ~override~
              ~ar3014.are~ ~override~
              ~ar3018.are~ ~override~
              ~ar3022.are~ ~override~
              ~ar5501.are~ ~override~
              ~ar5502.are~ ~override~
              ~ar5503.are~ ~override~
              ~ar5506.are~ ~override~
              ~ar5508.are~ ~override~
              ~ar6012.are~ ~override~
              ~ar6111.are~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x11b) THEN BEGIN // protects against invalid files
    READ_ASCII 0x94 "script"
    PATCH_IF (("" STRING_COMPARE_CASE "%script%" = 0) OR ("None" STRING_COMPARE_CASE "%script%" = 0)) BEGIN
      WRITE_EVALUATED_ASCII 0x94 ~%SOURCE_RES%~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix common error of incorrect map note offsets
COPY_EXISTING ~ar0011.are~ ~override~
              ~ar0012.are~ ~override~
              ~ar0013.are~ ~override~
              ~ar0014.are~ ~override~
              ~ar0015.are~ ~override~
              ~ar0016.are~ ~override~
              ~ar0017.are~ ~override~
              ~ar0018.are~ ~override~
              ~ar0020.are~ ~override~
              ~ar0021.are~ ~override~
              ~ar0022.are~ ~override~
              ~ar0028.are~ ~override~
              ~ar0041.are~ ~override~
              ~ar0042.are~ ~override~
              ~ar0043.are~ ~override~
              ~ar0044.are~ ~override~
              ~ar0045.are~ ~override~
              ~ar0046.are~ ~override~
              ~ar0060.are~ ~override~
              ~ar0061.are~ ~override~
              ~ar0062.are~ ~override~
              ~ar0063.are~ ~override~
              ~ar0064.are~ ~override~
              ~ar0065.are~ ~override~
              ~ar0069.are~ ~override~
              ~ar0070.are~ ~override~
              ~ar0071.are~ ~override~
              ~ar0072.are~ ~override~
              ~ar0082.are~ ~override~
              ~ar0083.are~ ~override~
              ~ar0084.are~ ~override~
              ~ar0085.are~ ~override~
              ~ar0086.are~ ~override~
              ~ar0087.are~ ~override~
              ~ar0203.are~ ~override~
              ~ar0206.are~ ~override~
              ~ar0301.are~ ~override~
              ~ar0302.are~ ~override~
              ~ar0303.are~ ~override~
              ~ar0304.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0306.are~ ~override~
              ~ar0307.are~ ~override~
              ~ar0308.are~ ~override~
              ~ar0309.are~ ~override~
              ~ar0310.are~ ~override~
              ~ar0311.are~ ~override~
              ~ar0312.are~ ~override~
              ~ar0313.are~ ~override~
              ~ar0314.are~ ~override~
              ~ar0315.are~ ~override~
              ~ar0316.are~ ~override~
              ~ar0317.are~ ~override~
              ~ar0318.are~ ~override~
              ~ar0319.are~ ~override~
              ~ar0321.are~ ~override~
              ~ar0322.are~ ~override~
              ~ar0323.are~ ~override~
              ~ar0324.are~ ~override~
              ~ar0325.are~ ~override~
              ~ar0326.are~ ~override~
              ~ar0327.are~ ~override~
              ~ar0328.are~ ~override~
              ~ar0329.are~ ~override~
              ~ar0330.are~ ~override~
              ~ar0331.are~ ~override~
              ~ar0332.are~ ~override~
              ~ar0333.are~ ~override~
              ~ar0334.are~ ~override~
              ~ar0335.are~ ~override~
              ~ar0401.are~ ~override~
              ~ar0402.are~ ~override~
              ~ar0403.are~ ~override~
              ~ar0405.are~ ~override~
              ~ar0407.are~ ~override~
              ~ar0408.are~ ~override~
              ~ar0409.are~ ~override~
              ~ar0410.are~ ~override~
              ~ar0412.are~ ~override~
              ~ar0413.are~ ~override~
              ~ar0414.are~ ~override~
              ~ar0415.are~ ~override~
              ~ar0416.are~ ~override~
              ~ar0417.are~ ~override~
              ~ar0418.are~ ~override~
              ~ar0419.are~ ~override~
              ~ar0420.are~ ~override~
              ~ar0501.are~ ~override~
              ~ar0502.are~ ~override~
              ~ar0503.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0505.are~ ~override~
              ~ar0506.are~ ~override~
              ~ar0507.are~ ~override~
              ~ar0508.are~ ~override~
              ~ar0510.are~ ~override~
              ~ar0511.are~ ~override~
              ~ar0512.are~ ~override~
              ~ar0513.are~ ~override~
              ~ar0514.are~ ~override~
              ~ar0515.are~ ~override~
              ~ar0516.are~ ~override~
              ~ar0517.are~ ~override~
              ~ar0518.are~ ~override~
              ~ar0519.are~ ~override~
              ~ar0520.are~ ~override~
              ~ar0521.are~ ~override~
              ~ar0523.are~ ~override~
              ~ar0525.are~ ~override~
              ~ar0526.are~ ~override~
              ~ar0527.are~ ~override~
              ~ar0528.are~ ~override~
              ~ar0529.are~ ~override~
              ~ar0530.are~ ~override~
              ~ar0531.are~ ~override~
              ~ar0601.are~ ~override~
              ~ar0604.are~ ~override~
              ~ar0605.are~ ~override~
              ~ar0606.are~ ~override~
              ~ar0607.are~ ~override~
              ~ar0702.are~ ~override~
              ~ar0703.are~ ~override~
              ~ar0704.are~ ~override~
              ~ar0705.are~ ~override~
              ~ar0706.are~ ~override~
              ~ar0707.are~ ~override~
              ~ar0708.are~ ~override~
              ~ar0709.are~ ~override~
              ~ar0710.are~ ~override~
              ~ar0711.are~ ~override~
              ~ar0712.are~ ~override~
              ~ar0713.are~ ~override~
              ~ar0714.are~ ~override~
              ~ar0802.are~ ~override~
              ~ar0803.are~ ~override~
              ~ar0804.are~ ~override~
              ~ar0805.are~ ~override~
              ~ar0806.are~ ~override~
              ~ar0807.are~ ~override~
              ~ar0809.are~ ~override~
              ~ar0810.are~ ~override~
              ~ar0811.are~ ~override~
              ~ar0812.are~ ~override~
              ~ar0813.are~ ~override~
              ~ar0901.are~ ~override~
              ~ar0902.are~ ~override~
              ~ar0903.are~ ~override~
              ~ar0904.are~ ~override~
              ~ar0905.are~ ~override~
              ~ar0906.are~ ~override~
              ~ar0907.are~ ~override~
              ~ar1001.are~ ~override~
              ~ar1002.are~ ~override~
              ~ar1003.are~ ~override~
              ~ar1004.are~ ~override~
              ~ar1005.are~ ~override~
              ~ar1006.are~ ~override~
              ~ar1007.are~ ~override~
              ~ar1008.are~ ~override~
              ~ar1009.are~ ~override~
              ~ar1010.are~ ~override~
              ~ar1101.are~ ~override~
              ~ar1102.are~ ~override~
              ~ar1103.are~ ~override~
              ~ar1104.are~ ~override~
              ~ar1105.are~ ~override~
              ~ar1106.are~ ~override~
              ~ar1107.are~ ~override~
              ~ar1201.are~ ~override~
              ~ar1203.are~ ~override~
              ~ar1204.are~ ~override~
              ~ar1304.are~ ~override~
              ~ar1305.are~ ~override~
              ~ar1306.are~ ~override~
              ~ar1307.are~ ~override~
              ~ar1402.are~ ~override~
              ~ar1403.are~ ~override~
              ~ar1501.are~ ~override~
              ~ar1502.are~ ~override~
              ~ar1503.are~ ~override~
              ~ar1504.are~ ~override~
              ~ar1505.are~ ~override~
              ~ar1506.are~ ~override~
              ~ar1507.are~ ~override~
              ~ar1508.are~ ~override~
              ~ar1509.are~ ~override~
              ~ar1510.are~ ~override~
              ~ar1511.are~ ~override~
              ~ar1513.are~ ~override~
              ~ar1601.are~ ~override~
              ~ar1602.are~ ~override~
              ~ar1603.are~ ~override~
              ~ar1604.are~ ~override~
              ~ar1605.are~ ~override~
              ~ar1606.are~ ~override~
              ~ar1607.are~ ~override~
              ~ar1608.are~ ~override~
              ~ar1609.are~ ~override~
              ~ar1610.are~ ~override~
              ~ar1611.are~ ~override~
              ~ar1612.are~ ~override~
              ~ar1613.are~ ~override~
              ~ar1700.are~ ~override~
              ~ar1800.are~ ~override~
              ~ar1901.are~ ~override~
              ~ar1902.are~ ~override~
              ~ar1904.are~ ~override~
              ~ar1905.are~ ~override~
              ~ar2001.are~ ~override~
              ~ar2002.are~ ~override~
              ~ar2006.are~ ~override~
              ~ar2008.are~ ~override~
              ~ar2009.are~ ~override~
              ~ar2010.are~ ~override~
              ~ar2011.are~ ~override~
              ~ar2012.are~ ~override~
              ~ar2013.are~ ~override~
              ~ar2014.are~ ~override~
              ~ar2015.are~ ~override~
              ~ar2016.are~ ~override~
              ~ar2017.are~ ~override~
              ~ar2018.are~ ~override~
              ~ar2101.are~ ~override~
              ~ar2201.are~ ~override~
              ~ar2202.are~ ~override~
              ~ar2203.are~ ~override~
              ~ar2204.are~ ~override~
              ~ar2205.are~ ~override~
              ~ar2206.are~ ~override~
              ~ar2207.are~ ~override~
              ~ar2208.are~ ~override~
              ~ar2209.are~ ~override~
              ~ar2210.are~ ~override~
              ~ar2601.are~ ~override~
              ~ar2602.are~ ~override~
              ~ar2603.are~ ~override~
              ~ar2700.are~ ~override~
              ~ar2801.are~ ~override~
              ~ar2802.are~ ~override~
              ~ar2803.are~ ~override~
              ~ar2804.are~ ~override~
              ~ar2805.are~ ~override~
              ~ar2807.are~ ~override~
              ~ar2808.are~ ~override~
              ~ar2810.are~ ~override~
              ~ar2811.are~ ~override~
              ~ar2812.are~ ~override~
              ~ar2901.are~ ~override~
              ~ar2902.are~ ~override~
              ~ar2903.are~ ~override~
              ~ar2904.are~ ~override~
              ~ar2905.are~ ~override~
              ~ar2906.are~ ~override~
              ~ar3004.are~ ~override~
              ~ar3005.are~ ~override~
              ~ar3006.are~ ~override~
              ~ar3007.are~ ~override~
              ~ar3008.are~ ~override~
              ~ar3009.are~ ~override~
              ~ar3010.are~ ~override~
              ~ar3011.are~ ~override~
              ~ar3012.are~ ~override~
              ~ar3013.are~ ~override~
              ~ar3014.are~ ~override~
              ~ar3023.are~ ~override~
              ~ar4000.are~ ~override~
              ~ar5001.are~ ~override~
              ~ar5002.are~ ~override~
              ~ar5003.are~ ~override~
              ~ar5004.are~ ~override~
              ~ar5005.are~ ~override~
              ~ar5006.are~ ~override~
              ~ar5008.are~ ~override~
              ~ar5009.are~ ~override~
              ~ar5010.are~ ~override~
              ~ar5011.are~ ~override~
              ~ar5012.are~ ~override~
              ~ar5014.are~ ~override~
              ~ar5015.are~ ~override~
              ~ar5201.are~ ~override~
              ~ar5202.are~ ~override~
              ~ar5203.are~ ~override~
              ~ar5204.are~ ~override~
              ~ar5501.are~ ~override~
              ~ar5502.are~ ~override~
              ~ar5503.are~ ~override~
              ~ar5504.are~ ~override~
              ~ar5505.are~ ~override~
              ~ar5507.are~ ~override~
              ~ar5508.are~ ~override~
              ~ar5509.are~ ~override~
              ~ar6000.are~ ~override~
              ~ar6001.are~ ~override~
              ~ar6008.are~ ~override~
              ~ar6011.are~ ~override~
              ~ar6012.are~ ~override~
              ~ar6100.are~ ~override~
              ~ar6102.are~ ~override~
              ~ar6103.are~ ~override~
              ~ar6105.are~ ~override~
              ~ar6106.are~ ~override~
              ~ar6107.are~ ~override~
              ~ar6108.are~ ~override~
              ~ar6109.are~ ~override~
              ~ar6110.are~ ~override~
              ~ar6111.are~ ~override~
              ~ar6200.are~ ~override~
              ~ar6300.are~ ~override~
              ~ar6400.are~ ~override~
  READ_LONG  0xc0 "rest_off" ELSE 0
  READ_LONG  0xc4 "note_off" ELSE 0
  READ_LONG  0xc8 "note_num" ELSE 213
  PATCH_IF (("%note_num%" = 0) AND ("%note_off%" != ("%rest_off%" + 0xe4))) BEGIN
    WRITE_LONG 0xc4 ("%rest_off%" + 0xe4)
  END
  BUT_ONLY_IF_IT_CHANGES
  
// if trap is undetectable, undisarmable, and has no script, remove trapped flag
COPY_EXISTING ~ar0311.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x2c + ("%index%" * 0xc0)) "trap_detect"
    READ_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) "trap_remove"
    READ_SHORT ("%cont_off%" + 0x30 + ("%index%" * 0xc0)) "trapped"
    READ_ASCII ("%cont_off%" + 0x48 + ("%index%" * 0xc0)) "script"
    PATCH_IF ((("%script%" STRING_COMPARE_CASE "" = 0) OR ("%script%" STRING_COMPARE_CASE "None" = 0)) AND
              ("%trapped%" = 1) AND ("%trap_detect%" > 99) AND ("%trap_remove%" > 99)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2c + ("%index%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%index%" * 0xc0)) 0
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%index%" * 0xc0)) ~~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// removing spurious trap flags
COPY_EXISTING ~ar0327.are~ ~override~
              ~ar0417.are~ ~override~
              ~ar0510.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_ASCII ("%cont_off%" +        ("%index%" * 0xc0)) "name"
    PATCH_IF (
               (("%SOURCE_RES%" STRING_COMPARE_CASE "ar0327" = 0) AND ("%name%" STRING_COMPARE_CASE "Container 7" = 0)) OR
               (("%SOURCE_RES%" STRING_COMPARE_CASE "ar0417" = 0) AND ("%name%" STRING_COMPARE_CASE "Shelf 1" = 0)) OR
               (("%SOURCE_RES%" STRING_COMPARE_CASE "ar0417" = 0) AND ("%name%" STRING_COMPARE_CASE "Table 1" = 0)) OR
               (("%SOURCE_RES%" STRING_COMPARE_CASE "ar0510" = 0) AND ("%name%" STRING_COMPARE_CASE "Container 4" = 0))
             ) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2c + ("%index%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%index%" * 0xc0)) 0
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%index%" * 0xc0)) ~~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~aerbod01.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr102" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~alynar.cre~   ~override~
              ~bounha02.cre~ ~override~
              ~bounha03.cre~ ~override~
              ~cadril.cre~   ~override~
              ~crolus.cre~   ~override~
              ~demson.cre~   ~override~
              ~franco.cre~   ~override~
              ~hurgisr.cre~  ~override~
              ~irlana.cre~   ~override~
              ~jaerto1.cre~  ~override~
              ~jaerto2.cre~  ~override~
              ~jaerto4.cre~  ~override~
              ~jaertof.cre~  ~override~
              ~kayl1.cre~    ~override~
              ~kayl2.cre~    ~override~
              ~plgran01.cre~ ~override~
              ~plshkn01.cre~ ~override~
              ~plshkn02.cre~ ~override~
              ~vakg02.cre~   ~override~
              ~vakg04.cre~   ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "spin111" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "spin113" = 0)) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~amelm01.cre~  ~override~
              ~e35.cre~      ~override~
              ~jatermin.cre~ ~override~
  READ_LONG  0x2a0 "known_off" ELSE 0
  READ_LONG  0x2a4 "known_num" ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi108" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~ar18fam.cre~  ~override~
              ~elemep01.cre~ ~override~
              ~elemep02.cre~ ~override~
              ~elemep04.cre~ ~override~
              ~elemep05.cre~ ~override~
              ~elemep06.cre~ ~override~
              ~elemep07.cre~ ~override~
              ~elemep08.cre~ ~override~
              ~famcat.cre~   ~override~
              ~famcat25.cre~ ~override~
              ~famdust.cre~  ~override~
              ~famfair.cre~  ~override~
              ~famfer.cre~   ~override~
              ~famfer25.cre~ ~override~
              ~famfire.cre~  ~override~
              ~famimp.cre~   ~override~
              ~famimp25.cre~ ~override~
              ~famlight.cre~ ~override~
              ~fammist.cre~  ~override~
              ~famrab.cre~   ~override~
              ~famrab25.cre~ ~override~
              ~famrad.cre~   ~override~
              ~fsridd.cre~   ~override~
              ~gorimp01.cre~ ~override~
              ~gpfam1.cre~   ~override~
              ~imp01.cre~    ~override~
              ~impqua01.cre~ ~override~
              ~mddust.cre~   ~override~
              ~mepdus01.cre~ ~override~
              ~mepear01.cre~ ~override~
              ~mepfir01.cre~ ~override~
              ~mepice01.cre~ ~override~
              ~mepice02.cre~ ~override~
              ~meplig01.cre~ ~override~
              ~mepmag01.cre~ ~override~
              ~mepmag02.cre~ ~override~
              ~mepmin01.cre~ ~override~
              ~mepmis01.cre~ ~override~
              ~mepooz01.cre~ ~override~
              ~meprad01.cre~ ~override~
              ~meprad02.cre~ ~override~
              ~mepste01.cre~ ~override~
              ~obsfir02.cre~ ~override~
              ~obsfir03.cre~ ~override~
              ~obsice02.cre~ ~override~
              ~rumar03.cre~  ~override~
              ~sahimp01.cre~ ~override~
              ~sahimp02.cre~ ~override~
              ~sahimp03.cre~ ~override~
              ~sahimp04.cre~ ~override~
              ~sahimp05.cre~ ~override~
              ~sahimp06.cre~ ~override~
              ~sahimp07.cre~ ~override~
              ~telimp1.cre~  ~override~
              ~telqua1.cre~  ~override~
              ~telqua2.cre~  ~override~
              ~udimp.cre~    ~override~
  READ_LONG  0x2a0 "known_off" ELSE 0
  READ_LONG  0x2a4 "known_num" ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi201" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 1 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~bheye.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi605" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 5 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~cuardul.cre~  ~override~
              ~pries18c.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi602" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 1 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES


// known spells listed with incorrect level/type
COPY_EXISTING ~elemep03.cre~ ~override~
              ~mepsal01.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi201" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 1 // correct spell level
    END ELSE
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spin934" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~eyeded01.cre~ ~override~
  READ_LONG  0x2a0 "known_off" ELSE 0
  READ_LONG  0x2a4 "known_num" ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "spwi314" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "spwi501" = 0)) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 1 // correct spell type
    END ELSE
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr707" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr708" = 0)) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 0 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~mepsmo01.cre~ ~override~
              ~mepsmo02.cre~ ~override~
              ~obsfir04.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi206" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 1 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~merlin.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr731" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr732" = 0)) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END ELSE
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi108" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
    END ELSE
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spcl922" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 6 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~nalia18.cre~ ~override~
  READ_LONG  0x2a0 "known_off" ELSE 0
  READ_LONG  0x2a4 "known_num" ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi805" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 7 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~nalin.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spin102" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~pcapt06.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr315" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 2 // correct spell level
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~spidfgsu.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spin683" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// known spells listed with incorrect level/type
COPY_EXISTING ~udardul.cre~  ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi602" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 1 // correct spell type
    END ELSE
    PATCH_IF ("%resref%" STRING_COMPARE_CASE "spin698" = 0) BEGIN
      WRITE_SHORT ("%known_off%" + 0x08 + ("%index%" * 0x0c)) 0 // correct spell level
      WRITE_SHORT ("%known_off%" + 0x0a + ("%index%" * 0x0c)) 2 // correct spell type
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cleans up DLTCEP error messages
COPY_EXISTING ~BALSHLD.SPL~  ~override~
              ~BALTH03.SPL~  ~override~
              ~BALTH05.SPL~  ~override~
              ~BHAAL3A.SPL~  ~override~
              ~BHAAL4A.SPL~  ~override~
              ~CH3DRAIN.SPL~ ~override~
              ~DRGRBRHT.SPL~ ~override~
              ~JWFALL.SPL~   ~override~
              ~JWONEHIT.SPL~ ~override~
              ~JWSP02.SPL~   ~override~
              ~LICHTEL.SPL~  ~override~
              ~SAREVEFF.SPL~ ~override~
              ~SENSPISU.SPL~ ~override~
              ~spcl121.spl~  ~override~
              ~spcl133.spl~  ~override~
              ~spcl144.spl~  ~override~
              ~spcl235.spl~  ~override~
              ~spcl351.spl~  ~override~
              ~spcl423.spl~  ~override~
              ~spcl521.spl~  ~override~
              ~spcl522.spl~  ~override~
              ~spcl542.spl~  ~override~
              ~spcl613.spl~  ~override~
              ~spcl641.spl~  ~override~
              ~spcl731.spl~  ~override~
              ~spcl751.spl~  ~override~
              ~spcl751a.spl~ ~override~
              ~spcl811.spl~  ~override~
              ~spcl814.spl~  ~override~
              ~spcl820.spl~  ~override~
              ~spcl900.spl~  ~override~
              ~spcl901.spl~  ~override~
              ~spcl902.spl~  ~override~
              ~spcl903.spl~  ~override~
              ~spcl904.spl~  ~override~
              ~spcl905.spl~  ~override~
              ~spcl906.spl~  ~override~
              ~spcl907.spl~  ~override~
              ~spcl909.spl~  ~override~
              ~spcl910.spl~  ~override~
              ~spcl915.spl~  ~override~
              ~spcl916.spl~  ~override~
              ~spcl918.spl~  ~override~
              ~spcl919.spl~  ~override~
              ~spcl920.spl~  ~override~
              ~spcl921.spl~  ~override~
              ~spcl928.spl~  ~override~
              ~spcl929.spl~  ~override~
              ~spcl930.spl~  ~override~
              ~spdr101.spl~  ~override~
              ~spin104a.spl~ ~override~
              ~spin122.spl~  ~override~
              ~spin123.spl~  ~override~
              ~spin124.spl~  ~override~
              ~spin150.spl~  ~override~
              ~spin151.spl~  ~override~
              ~spin530.spl~  ~override~
              ~spin531.spl~  ~override~
              ~spin532.spl~  ~override~
              ~spin534.spl~  ~override~
              ~spin540.spl~  ~override~
              ~spin553.spl~  ~override~
              ~spin554.spl~  ~override~
              ~spin555.spl~  ~override~
              ~spin556.spl~  ~override~
              ~spin557.spl~  ~override~
              ~spin571.spl~  ~override~
              ~spin576.spl~  ~override~
              ~spin581.spl~  ~override~
              ~spin582.spl~  ~override~
              ~spin583.spl~  ~override~
              ~spin584.spl~  ~override~
              ~spin585.spl~  ~override~
              ~spin586.spl~  ~override~
              ~spin587.spl~  ~override~
              ~spin588.spl~  ~override~
              ~spin589.spl~  ~override~
              ~spin590.spl~  ~override~
              ~spin591.spl~  ~override~
              ~spin594.spl~  ~override~
              ~spin595.spl~  ~override~
              ~spin596.spl~  ~override~
              ~spin611.spl~  ~override~
              ~spin612.spl~  ~override~
              ~spin613.spl~  ~override~
              ~spin615.spl~  ~override~
              ~spin616.spl~  ~override~
              ~spin641.spl~  ~override~
              ~spin644.spl~  ~override~
              ~spin647.spl~  ~override~
              ~spin648.spl~  ~override~
              ~spin661.spl~  ~override~
              ~spin662.spl~  ~override~
              ~spin663.spl~  ~override~
              ~spin670.spl~  ~override~
              ~spin672.spl~  ~override~
              ~spin681.spl~  ~override~
              ~spin682.spl~  ~override~
              ~spin691.spl~  ~override~
              ~spin693.spl~  ~override~
              ~spin706.spl~  ~override~
              ~spin708.spl~  ~override~
              ~spin718.spl~  ~override~
              ~spin720.spl~  ~override~
              ~spin721.spl~  ~override~
              ~spin726.spl~  ~override~
              ~spin727.spl~  ~override~
              ~spin732.spl~  ~override~
              ~spin747.spl~  ~override~
              ~spin748.spl~  ~override~
              ~spin749.spl~  ~override~
              ~spin750.spl~  ~override~
              ~spin751.spl~  ~override~
              ~spin752.spl~  ~override~
              ~spin753.spl~  ~override~
              ~spin754.spl~  ~override~
              ~spin755.spl~  ~override~
              ~spin756.spl~  ~override~
              ~spin759.spl~  ~override~
              ~spin760.spl~  ~override~
              ~spin761.spl~  ~override~
              ~spin762.spl~  ~override~
              ~spin763.spl~  ~override~
              ~spin764.spl~  ~override~
              ~spin765.spl~  ~override~
              ~spin766.spl~  ~override~
              ~spin767.spl~  ~override~
              ~spin770.spl~  ~override~
              ~spin771.spl~  ~override~
              ~spin773.spl~  ~override~
              ~spin782.spl~  ~override~
              ~spin784.spl~  ~override~
              ~spin789.spl~  ~override~
              ~spin810.spl~  ~override~
              ~spin820.spl~  ~override~
              ~spin823.spl~  ~override~
              ~spin825.spl~  ~override~
              ~spin829.spl~  ~override~
              ~spin832.spl~  ~override~
              ~spin833.spl~  ~override~
              ~spin834.spl~  ~override~
              ~spin836.spl~  ~override~
              ~spin837.spl~  ~override~
              ~spin838.spl~  ~override~
              ~spin846.spl~  ~override~
              ~spin848.spl~  ~override~
              ~spin853.spl~  ~override~
              ~spin868.spl~  ~override~
              ~spin869.spl~  ~override~
              ~spin874.spl~  ~override~
              ~spin875.spl~  ~override~
              ~spin876.spl~  ~override~
              ~spin878.spl~  ~override~
              ~spin879.spl~  ~override~
              ~spin881.spl~  ~override~
              ~spin891.spl~  ~override~
              ~spin893.spl~  ~override~
              ~spin916.spl~  ~override~
              ~spin927.spl~  ~override~
              ~spin934.spl~  ~override~
              ~spin935.spl~  ~override~
              ~spin936.spl~  ~override~
              ~spin957.spl~  ~override~
              ~spin959.spl~  ~override~
              ~spin965.spl~  ~override~
              ~spin973.spl~  ~override~
              ~spin995.spl~  ~override~
              ~spinhum.spl~  ~override~
              ~sppr202.spl~  ~override~
              ~sppr203.spl~  ~override~
              ~sppr206.spl~  ~override~
              ~sppr313.spl~  ~override~
              ~sppr412.spl~  ~override~
              ~sppr515d.spl~ ~override~
              ~sppr599.spl~  ~override~
              ~sppr712.spl~  ~override~
              ~sppr713.spl~  ~override~
              ~sppr719.spl~  ~override~
              ~sppr731.spl~  ~override~
              ~sppr732.spl~  ~override~
              ~spwi108.spl~  ~override~
              ~spwi118.spl~  ~override~
              ~spwi124.spl~  ~override~
              ~spwi210.spl~  ~override~
              ~spwi211.spl~  ~override~
              ~spwi299.spl~  ~override~
              ~spwi303.spl~  ~override~
              ~spwi314a.spl~ ~override~
              ~spwi319.spl~  ~override~
              ~spwi320.spl~  ~override~
              ~spwi325.spl~  ~override~
              ~spwi411.spl~  ~override~
              ~spwi489.spl~  ~override~
              ~spwi490.spl~  ~override~
              ~spwi491.spl~  ~override~
              ~spwi517.spl~  ~override~
              ~spwi518.spl~  ~override~
              ~spwi607.spl~  ~override~
              ~spwi703.spl~  ~override~
              ~spwi712.spl~  ~override~
              ~spwi714.spl~  ~override~
              ~spwi804.spl~  ~override~
              ~spwi817.spl~  ~override~
              ~spwi818.spl~  ~override~
              ~spwi888.spl~  ~override~
              ~spwi897.spl~  ~override~
              ~spwi913.spl~  ~override~
              ~spwi915.spl~  ~override~
              ~spwi918.spl~  ~override~
              ~spwi921.spl~  ~override~
              ~spwi922.spl~  ~override~
              ~spwi924.spl~  ~override~
              ~spwi925.spl~  ~override~
              ~spwi941.spl~  ~override~
              ~spwi942.spl~  ~override~
              ~spwi944.spl~  ~override~
              ~spwi945.spl~  ~override~
              ~spwi946.spl~  ~override~
              ~spwi947.spl~  ~override~
              ~spwi949.spl~  ~override~
              ~spwi951.spl~  ~override~
              ~spwi961.spl~  ~override~
              ~spwi962.spl~  ~override~
              ~spwi963.spl~  ~override~
              ~spwi964.spl~  ~override~
              ~spwi965.spl~  ~override~
              ~spwi983.spl~  ~override~
              ~spwi987.spl~  ~override~
              ~spwi988.spl~  ~override~
              ~spwi990.spl~  ~override~
              ~spwi991.spl~  ~override~
              ~spwi992.spl~  ~override~
              ~spwi993.spl~  ~override~
              ~spwish11.spl~ ~override~
              ~spwish12.spl~ ~override~
              ~spwish13.spl~ ~override~
              ~spwish14.spl~ ~override~
              ~spwish16.spl~ ~override~
              ~spwish17.spl~ ~override~
              ~spwish46.spl~ ~override~
              ~spwm101d.spl~ ~override~
              ~spwm108.spl~  ~override~
              ~spwm109.spl~  ~override~
              ~spwm117.spl~  ~override~
              ~spwm159.spl~  ~override~
              ~spwm162.spl~  ~override~
              ~spwm188.spl~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_SHORT 0x70 "fx_num"
    PATCH_IF ("%abil_num%" > 0) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
      SET "fx_num" = ("%abil_fx_idx%" + "%abil_fx_num%")
    END
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_BYTE ("%fx_off%" + 0x0c + (0x30 * "%fx_num%")) "timing"
      PATCH_IF (("%timing%" = 1) OR ("%timing%" = 9)) BEGIN
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * "%fx_num%")) 0 // duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// detectable spells goes here--once it's done

//blank music file
COPY ~bg2fixpack/mus/G3Blank.mus~ ~music/G3Blank.mus~
  
// strips extraneous default(0) abiity headers from items to prevent nishruu eating
COPY_EXISTING ~amul18.itm~   ~override~
              ~amul27.itm~   ~override~
              ~belt04.itm~   ~override~
              ~belt05.itm~   ~override~
              ~belt07.itm~   ~override~
              ~belt08.itm~   ~override~
              ~belt10.itm~   ~override~
              ~bow19a.itm~   ~override~
              ~bow19b.itm~   ~override~
              ~brac01.itm~   ~override~
              ~brac02.itm~   ~override~
              ~brac03.itm~   ~override~
              ~brac08.itm~   ~override~
              ~brac11.itm~   ~override~
              ~brac13.itm~   ~override~
              ~brac14.itm~   ~override~
              ~brac18.itm~   ~override~
              ~btest1.itm~   ~override~
              ~chan01.itm~   ~override~
              ~chan02.itm~   ~override~
              ~chan03.itm~   ~override~
              ~chan06.itm~   ~override~
              ~chan07.itm~   ~override~
              ~chan08.itm~   ~override~
              ~chan12.itm~   ~override~
              ~chan13.itm~   ~override~
              ~clck01.itm~   ~override~
              ~clck03.itm~   ~override~
              ~clck05.itm~   ~override~
              ~clck10.itm~   ~override~
              ~clck11.itm~   ~override~
              ~clck12.itm~   ~override~
              ~clck13.itm~   ~override~
              ~clck14.itm~   ~override~
              ~clck15.itm~   ~override~
              ~clck16.itm~   ~override~
              ~clck17.itm~   ~override~
              ~clck18.itm~   ~override~
              ~clck19.itm~   ~override~
              ~clck22.itm~   ~override~
              ~clck23.itm~   ~override~
              ~clolth.itm~   ~override~
              ~demilich.itm~ ~override~
              ~dwchan01.itm~ ~override~
              ~finmel01.itm~ ~override~
              ~globblu3.itm~ ~override~
              ~globgre1.itm~ ~override~
              ~globpur3.itm~ ~override~
              ~globred4.itm~ ~override~
              ~halb09a.itm~  ~override~
              ~halb09b.itm~  ~override~
              ~hgwra02.itm~  ~override~
              ~jwsuper.itm~  ~override~
              ~key24.itm~    ~override~
              ~key27.itm~    ~override~
              ~key28.itm~    ~override~
              ~leat04.itm~   ~override~
              ~leat15.itm~   ~override~
              ~leat16.itm~   ~override~
              ~lich.itm~     ~override~
              ~mdk2ring.itm~ ~override~
              ~misc4y.itm~   ~override~
              ~misc5f.itm~   ~override~
              ~misc8u.itm~   ~override~
              ~misc97.itm~   ~override~
              ~misc9h.itm~   ~override~
              ~misca2.itm~   ~override~
              ~misca3.itm~   ~override~
              ~misca4.itm~   ~override~
              ~misca7.itm~   ~override~
              ~misca9.itm~   ~override~
              ~miscac.itm~   ~override~
              ~miscae.itm~   ~override~
              ~miscaf.itm~   ~override~
              ~miscag.itm~   ~override~
              ~miscah.itm~   ~override~
              ~miscaj.itm~   ~override~
              ~miscak.itm~   ~override~
              ~miscal.itm~   ~override~
              ~miscao.itm~   ~override~
              ~miscap.itm~   ~override~
              ~miscaq.itm~   ~override~
              ~miscar.itm~   ~override~
              ~miscas.itm~   ~override~
              ~miscat.itm~   ~override~
              ~miscb1.itm~   ~override~
              ~miscb2.itm~   ~override~
              ~miscb4.itm~   ~override~
              ~miscb5.itm~   ~override~
              ~miscb6.itm~   ~override~
              ~miscb7.itm~   ~override~
              ~miscb8.itm~   ~override~
              ~miscb9.itm~   ~override~
              ~miscba.itm~   ~override~
              ~miscbr.itm~   ~override~
              ~miscbs.itm~   ~override~
              ~npclck.itm~   ~override~
              ~plot02a.itm~  ~override~
              ~plot02b.itm~  ~override~
              ~plot02c.itm~  ~override~
              ~plot02d.itm~  ~override~
              ~plot02e.itm~  ~override~
              ~plot03a.itm~  ~override~
              ~plot03b.itm~  ~override~
              ~plot03c.itm~  ~override~
              ~plot03d.itm~  ~override~
              ~plot04i.itm~  ~override~
              ~plot05a.itm~  ~override~
              ~plot05b.itm~  ~override~
              ~plot05c.itm~  ~override~
              ~plot05d.itm~  ~override~
              ~potn44.itm~   ~override~
              ~ption2k.itm~  ~override~
              ~ption2l.itm~  ~override~
              ~ption2m.itm~  ~override~
              ~ption2n.itm~  ~override~
              ~ption41.itm~  ~override~
              ~ravag02.itm~  ~override~
              ~ravag03.itm~  ~override~
              ~ring02.itm~   ~override~
              ~ring04.itm~   ~override~
              ~ring21.itm~   ~override~
              ~ring23.itm~   ~override~
              ~ring25.itm~   ~override~
              ~ring37.itm~   ~override~
              ~ring38.itm~   ~override~
              ~rossring.itm~ ~override~
              ~sarbone.itm~  ~override~
              ~sarskel.itm~  ~override~
              ~sarskul.itm~  ~override~
              ~scaleb.itm~   ~override~
              ~scaler.itm~   ~override~
              ~scrla9.itm~   ~override~
              ~scrlaa.itm~   ~override~
              ~scrlac.itm~   ~override~
              ~scrlad.itm~   ~override~
              ~scrlae.itm~   ~override~
              ~sw1h54a.itm~  ~override~
              ~sw1h54b.itm~  ~override~
              ~sw2h15a.itm~  ~override~
              ~tbag01.itm~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    SET "fx_delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for default ability header
      READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
      PATCH_IF ("%type%" = 0) BEGIN // default ability check
        READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
        READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
        DELETE_BYTES ("%fx_off%" + (0x30 * ("%abil_fx_idx%" - "%fx_delta%"))) (0x30 * "%abil_fx_num%") // deletes all associated effects
        DELETE_BYTES ("%abil_off%" + ("%index%" * 0x38)) 0x38                                          // deletes ability itself
        SET "fx_delta" = ("%fx_delta%" + "%abil_fx_num%")
        SET "abil_num" = ("%abil_num%" - 1)
        SET "index" = ("%index%" - 1)
        SET "fx_off" = ("%fx_off%" - 0x38)
      END ELSE BEGIN // if non-melee ability, need to adjust effect indices
        READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
        WRITE_SHORT (0x20 + "%abil_off%" + ("%index%" * 0x38)) ("%abil_fx_idx%" - "%fx_delta%")
      END
    END
    WRITE_SHORT  0x68 "%abil_num%"
    WRITE_LONG   0x6a "%fx_off%"
  END
  BUT_ONLY_IF_IT_CHANGES

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// BETA Core Fixes                                  \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @20 DESIGNATED 3 // Beta Core Fixes

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0003.g3~

// allows us to regexp match tabs and newlines
INCLUDE ~bg2fixpack/lib/extra_regexp_vars.tph~

/////                                                  \\\\\
///// string fixes                                     \\\\\
/////                                                  \\\\\

ACTION_IF ("%LANGUAGE%" STRING_COMPARE_CASE "korean") THEN BEGIN // no korean translation for these strings

  STRING_SET 46589 @157 // prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr4.cre, sahpr2.dlg
  STRING_SET 46590 @158 // prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr4.cre, sahpr2.dlg

END

/////                                                  \\\\\
///// ids fixes                                        \\\\\
/////                                                  \\\\\


// Fix the BashDoor() entry in ACTION.IDS (Wounded_Lion)

COPY_EXISTING ~action.ids~ ~override~
 REPLACE_TEXTUALLY ~BashDoor(0:Object)~ ~BashDoor(O:Object)~
BUT_ONLY_IF_IT_CHANGES


// Fix the LeaveAreaLUAPanicEntry() entry in ACTSLEEP.IDS (Lu_ and aVENGER)

COPY_EXISTING ~actsleep.ids~ ~override~
PATCH_IF NOT FILE_CONTAINS_EVALUATED (~%SOURCE_FILE%~ ~LeaveAreaLUAPanicEntry(S\:Area\*\,S\:Entry\*\,P\:Point\*\,I\:Face\*)~) BEGIN
  REPLACE_TEXTUALLY EXACT_MATCH ~351 LeaveAreaLUAPanicEntry(S:Area*,S:Entry*,P:Point*,~ ~351 LeaveAreaLUAPanicEntry(S:Area*,S:Entry*,P:Point*,I:Face*)~
END
BUT_ONLY_IF_IT_CHANGES


/////                                                  \\\\\
///// misc 2da fixes                                   \\\\\
/////                                                  \\\\\

APPEND ~tooltip.2da~ // adds dupe book of infinite spells
  ~MISC3AA           6618         4731        -1~

/////                                                  \\\\\
///// mass compile/copy actions actions                \\\\\
/////                                                  \\\\\

COMPILE ~bg2fixpack/dlg/beta_soa-dlg.d~

<<<<<<<<inlined/dialogues/are/gauche/imoenfixtake2.d
REPLACE_STATE_TRIGGER imoenp 3 ~Global("ImoenRunning","LOCALS",1)~
SET_WEIGHT imoenp 3 #-1
>>>>>>>>

COMPILE ~inlined/dialogues/are/gauche/imoenfixtake2.d~
  
COPY ~bg2fixpack/wed/ar1900n.wed~ override

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // tob only

  COMPILE ~bg2fixpack/dlg/beta_tob-dlg.d~

  // celestial weapons turn opaque when attacking
  COPY_EXISTING ~masgg2bw.bam~ ~override/maslg2bw.bam~
                ~masgg2s1.bam~ ~override/maslg2s1.bam~
                ~msogg2bw.bam~ ~override/msolg2bw.bam~
                ~msogg2s1.bam~ ~override/msolg2s1.bam~
  
  // travel time fix for abazigal <--> WK
  COPY_EXISTING ~worldm25.wmp~ ~override~
    READ_LONG 0x0c "mos_off"
    READ_LONG ("%mos_off%" + 0x20) "area_num"
    READ_LONG ("%mos_off%" + 0x24) "area_off"
    READ_LONG ("%mos_off%" + 0x28) "link_off"
    FOR (index = 0 ; index < area_num ; index = index + 1) BEGIN
      READ_ASCII ("%area_off%" + 0x08 + ("%index%" * 0xf0)) "area"
      PATCH_IF ("%area%" STRING_COMPARE_CASE "ar3000" = 0) BEGIN // wk
        SET "wk" = "%index%"
      END ELSE
      PATCH_IF ("%area%" STRING_COMPARE_CASE "ar6000" = 0) BEGIN // abazigal
        SET "abazigal" = "%index%"
      END
    END
    // read links
    FOR (index2 = 0 ; index2 < 4 ; index2 = index2 + 1) BEGIN
      READ_LONG ("%area_off%" + 0x50 + ("%index2%" * 0x08) + ("%wk%" * 0xf0)) "link_idx"
      READ_LONG ("%area_off%" + 0x54 + ("%index2%" * 0x08) + ("%wk%" * 0xf0)) "link_num"
      FOR (index3 = 0 ; index3 < link_num ; index3 = index3 + 1) BEGIN
        READ_LONG ("%link_off%" +        (("%link_idx%" + "%index3%") * 0xd8)) "target"
        PATCH_IF ("%target%" = "%abazigal%") BEGIN
          WRITE_LONG ("%link_off%" + 0x24 + (("%link_idx%" + "%index3%") * 0xd8)) 9 // travel time
        END
      END
    END
    BUT_ONLY_IF_IT_CHANGES

END

/////                                                  \\\\\
///// dialogue fixes                                   \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// scripting fixes                                  \\\\\
/////                                                  \\\\\

// please don't cast chaotic commands on enemies
COPY ~scripts/cleric1.bs~ ~scripts/cleric1.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(CLERIC_CHAOTIC_COMMANDS)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// targets for the misc heals are poorly defined, can be mistargeted
COPY ~scripts/cleric2.bs~ ~scripts/cleric2.bs~
     ~scripts/cleric3.bs~ ~scripts/cleric3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(HPPercentLT(LastSeenBy(Myself),10)\)~ ~See([PC]) \1~
    REPLACE_TEXTUALLY ~\(HPPercentLT(Myself,90)[%tab% %lnl%%mnl%%wnl%]+HaveSpell(CLERIC_CURE_LIGHT_WOUNDS)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(MostDamagedOf(Myself),CLERIC_CURE_LIGHT_WOUNDS)~
    ~\1 Spell(Myself,CLERIC_CURE_LIGHT_WOUNDS)~
    REPLACE_TEXTUALLY ~MostDamagedOf(Myself)~ ~MostDamagedOf()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// please don't cast ray of enfeeblement on yourself
COPY ~scripts/mage3.bs~ ~scripts/mage3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Spell(Myself,WIZARD_RAY_OF_ENFEEBLEMENT)~ ~Spell(LastSeenBy(Myself),WIZARD_RAY_OF_ENFEEBLEMENT)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// stop (kuo-toan) archers and air elementals from charging across areas to engage party
EXTEND_TOP ~airele01.bcs~ ~bg2fixpack/baf/gparcher.baf~
EXTEND_TOP ~gparcher.bcs~ ~bg2fixpack/baf/gparcher.baf~
  
// multiple stringheads for thieves return fix; not paying thieves guild quota fix; see also baldur.bcs, joster.bcs, shthlt01.dlg
COPY_EXISTING ~ar0322.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("NotifyThiefHead","GLOBAL",0)~ ~~
    REPLACE_TEXTUALLY ~CreateCreature("SHTH05",\[691\.292\],2)~
      ~SetGlobal("CDJoster","AR0322",1) CreateCreature("SHTH05",[691.292],2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// bard playhouse issues--transition can be left open
COPY_EXISTING ~ar0522.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GlobalTimerExpired("MeetHiggin6a","GLOBAL")~
                      ~GlobalTimerExpired("MeetHiggin6a","GLOBAL") Global("BardPlot1","GLOBAL",40)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// bard playhouse issues--jenna not going to proper spot, meck sometimes not appearing upon completion
COPY_EXISTING ~ar0523.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("bdact03",MoveToPoint(\[1301\.453\]))~
                      ~ActionOverride("bdact03",MoveToPoint([1301.181]))~
    APPEND_FILE ~bg2fixpack/baf/ar0523.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// can still rest in lathander temple after stripped due to var scope issue
COPY_EXISTING ~ar0901.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"AR0902"~ ~"AR0901"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// paladin-firkraag journal entry not being set due to bad variable scope
COPY_EXISTING ~ar1202.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"AR1200"~ ~"AR1202"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// add extra trigger so this won't fire twice
COPY_EXISTING ~ar1600.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Dead("ppright")~  ~GlobalLT("AsylumPlot","GLOBAL",78) Dead("ppright")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// deirex killed during cutscene fix 1/2; see jarlich.cre
EXTEND_BOTTOM ~ar2207.bcs~ ~bg2fixpack/baf/ar2207.baf~

// prevent dupe CoC items; see also sahkng01.bcs, sahpr4.cre, sahpr2.dlg, string sets
EXTEND_BOTTOM ~ar2300.bcs~   ~bg2fixpack/baf/ar2300.baf~

// not paying thieves guild quota fix; see also ar0322.bcs, joster.bcs, shthlt01.dlg
COPY_EXISTING ~baldur.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\bGlobal("JosterLeave","GLOBAL",2)~ ~!Global("JosterLeave","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ch 6 allies check wrong drizzt DV
COPY_EXISTING ~c6arkan.bcs~ ~override~
              ~c6eric.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~("c6drizz")~ ~("c6drizz2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// many changes--clear actions, make uniterruptable, reorder textscreen, move saemon dialogue call here from ppsaem2.bcs
COPY_EXISTING ~cut41q.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId(Player1)~     ~CutSceneId(Player1) ClearAllActions() SetInterrupt(FALSE)~
    REPLACE_TEXTUALLY ~TextScreen("SCRTXT05")~  ~ActionOverride("ppsaem3",StartDialogueNoSet(Player1))~
    REPLACE_TEXTUALLY ~MultiPlayerSync()~       ~MultiPlayerSync() TextScreen("SCRTXT05")~
    REPLACE_TEXTUALLY ~Explore()~               ~Explore() SetInterrupt(TRUE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// clear actions, make uninterruptable
COPY_EXISTING ~cut41zf.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId(Player1)~                  ~CutSceneId(Player1) ClearAllActions() SetInterrupt(FALSE)~
    REPLACE_TEXTUALLY ~SetGlobal("AttackedGith","GLOBAL",1)~ ~SetGlobal("AttackedGith","GLOBAL",1) SetInterrupt(TRUE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// add a bit more time for sahuagin attack
COPY_EXISTING ~cut41zg.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobalTimer("GithTimer1","GLOBAL",5)~ ~SetGlobalTimer("GithTimer1","GLOBAL",10)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // tob

  COPY_EXISTING ~demnabsu.bcs~ ~override~
                ~dempitsu.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~See(\[ANYONE\])~ ~See([ANYONE]) CheckStatLT(LastSeenBy(Myself),1,169)~
    COMPILE_BAF_TO_BCS
    BUT_ONLY

END

COPY_EXISTING ~demglasu.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~See(\[ANYONE\])[%tab% %lnl%%mnl%%wnl%]+Global("Prep","LOCALS",1)~  ~See([ANYONE])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY

// script should check live and dead troll DV
COPY_EXISTING ~firamb01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\([^!]\)Dead("firamb05")~ ~\1OR(2) Dead("firamb03") Dead("firamb05")~
  COMPILE_BAF_TO_BCS

// don't interrupt lucette when she's kiling xzar
COPY_EXISTING ~harpass1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~FaceObject("Lyros")~ ~SetInterrupt(FALSE) DialogInterrupt(FALSE) FaceObject("Lyros")~
    REPLACE_TEXTUALLY ~StartDialog\(ue\)?NoSet(Player1)~ ~DialogInterrupt(TRUE) SetInterrupt(TRUE) StartDialogueNoSet(Player1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// not paying thieves guild quota fix; see also ar0322.bcs, baldur.bcs, shthlt01.dlg
EXTEND_BOTTOM ~joster.bcs~ ~bg2fixpack/baf/joster.baf~

// script fixes for anarg-smuggler battle; see also kaypal03.bcs, kaysmg04.bcs
COPY_EXISTING ~kaypal02.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~(\[NEUTRAL\.0\.HUMAN\.THIEF\])~ ~([NOTGOOD.0.0.CLERIC])~
   REPLACE_TEXTUALLY ~(\[ENEMY\.0\.HUMAN\.THIEF\])~   ~([NOTGOOD.0.0.THIEF]) Name("kaysmg",LastSeenBy(Myself))~
   REPLACE_TEXTUALLY ~AttackReevaluate(NearestEnemyOf(Myself),15)~
                     ~AttackReevaluate(LastSeenBy(Myself),15)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// script fixes for anarg-smuggler battle; see also kaypal02.bcs, kaysmg04.bcs
COPY_EXISTING ~kaypal03.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~AttackReevaluate(NearestEnemyOf(Myself),30)~ 
                     ~AttackReevaluate(LastSeenBy(Myself),30)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// script fixes for anarg-smuggler battle; see also kaypal02.bcs, kaypal03.bcs
COPY_EXISTING ~kaysmg04.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~\(HPPercentLT("kaysmgl",50)[%tab% %lnl%%mnl%%wnl%]+See("kaysmgl")\)~ ~\1 !Dead("kaysmgl")~
   REPLACE_TEXTUALLY ~HPPercentLT("kaysmg",30)[%tab% %lnl%%mnl%%wnl%]+See("kaysmg")~ 
                     ~See([NOTGOOD.0.0.THIEF]) HPPercentLT(LastSeenBy(Myself),30) Name("kaysmg",LastSeenBy(Myself))~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// flail of ages forge should still work after acquiring stronghold; wasn't due to bad variable scope
COPY_EXISTING ~kpforge.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~,"AR1302",~ ~,"GLOBAL",~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// tyrianna should disappear after conclusion of her quest
EXTEND_BOTTOM ~plgirl01.bcs~ ~bg2fixpack/baf/plgirl01.baf~

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// false block for saemon initiating dialogue (moved to cut41q.bcs); add block to make saemon hostile if attacked
COPY_EXISTING ~ppsaem2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("SaemInit1607","GLOBAL",0)~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/ppsaem2.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// trigger misordering causing folks to flee from party, not enemies
COPY_EXISTING ~runenemy.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(See(\[ENEMY\])\)[%tab% %lnl%%mnl%%wnl%]+\(!?Detect(\[PC\])\)~ ~\2 \1~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevent dupe CoC items; see also ar2300.bcs, sahpr4.cre, sahpr2.dlg, string sets
EXTEND_BOTTOM ~sahkng01.bcs~ ~bg2fixpack/baf/sahkng01.baf~

// habib shouldn't spawn if dead
COPY_EXISTING ~slilmat.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("SpawnHabib","GLOBAL",5)~
                      ~Global("SpawnHabib","GLOBAL",5) !Dead("Habib")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// new troll scripts to transform to dead versions at low HP
COPY_EXISTING ~troll01.bcs~  ~override/cdtroll1.bcs~
              ~trolsn01.bcs~ ~override/obsice11.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLSN02")~ ~ChangeAnimationNoEffect("obsice11")~
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLL02")~  ~ChangeAnimationNoEffect("cdtroll2")~
  COMPILE_BAF_TO_BCS

// new troll scripts to transform from dead to alive after time expires
COPY_EXISTING ~troll02.bcs~  ~override/cdtroll2.bcs~
              ~trolsn02.bcs~ ~override/obsice01.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_CHANGE)~      ~ReallyForceSpellRES("cdtroll1",Myself)~
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_SNOW_CHANGE)~ ~ReallyForceSpellRES("obsice01",Myself)~
  COMPILE_BAF_TO_BCS
  
// dialogue breaks in phaere's recue if Sola is invald for dialogue
EXTEND_TOP ~udphae01.bcs~ ~bg2fixpack/baf/udphae01.baf~

// prevent Yoshimo telling you to see Renal when you already have
COPY_EXISTING ~yoshimo.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("YoshimoMentionsRenal","LOCALS",0)~ ~Global("YoshimoMentionsRenal","LOCALS",0) Global("TalkedToRenal","GLOBAL",0)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Hendak should not randomly end up in some other part of the Copper Coronet if he performs a jump to arrive at Lehtinan's spot (Wisp)
COPY_EXISTING hendak.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY EXACT_MATCH "SetHomeLocation([32.120])" "SetHomeLocation([526.1193])"
    REPLACE_TEXTUALLY EXACT_MATCH "JumpToPoint([526.1193])" "SetHomeLocation([526.1193]) JumpToPoint([526.1193])"
  COMPILE_BAF_TO_BCS
BUT_ONLY
UNLESS // True unless there already is a SetHomeLocation before JumpToPoint.
~AC
261OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
0 526 1193 0 0"" "" AC
AC
48OB~

// Temple of Talos script can loop interminably if <CHARNAME> murders too wantonly (Nythrun and Wisp)
COPY_EXISTING ar0904.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~^ *Dead("talmiss")~
                                          ~  Dead("talmiss")  Exists("talmiss2")  !Dead("talmiss2")~
    REPLACE_TEXTUALLY ~^ *Dead("talmiss2")~
                                          ~  Dead("talmiss2")  Exists("talmiss")  !Dead("talmiss")~
  COMPILE_BAF_TO_BCS
BUT_ONLY
UNLESS ~16465 0 1 0 0 "talmiss[2]?" "" OB~

// Drow etc. guarding the way out of the Underdark start to stutter if they are charmed after you have made an enemy of the Ust Natha (Wisp)
COPY_EXISTING dwgates1.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY ~!Allegiance(Myself,ENEMY)~ ~!Allegiance(Myself,ENEMY) !StateCheck(Myself,STATE_CHARMED)~
  END
BUT_ONLY
UNLESS ~16439 8192 1 0 0 "" "" OB~ //UNLESS !StateCheck(Myself,STATE_CHARMED)

//Surface elves by the Underdark exit can bail out prematurely (Wisp)
COPY_EXISTING udelf1.bcs override
              udelf2.bcs override
              udelf3.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY "\(See(\[PC\])[%LNL%%TAB% ]*CombatCounter(0)\)" "\1 !Detect([ENEMY])"
  END
BUT_ONLY
UNLESS ~16500 0 1 0 0 "" "" OB%LNL%255 0 0 0 0 0 0 0 0 0 0 0 ""OB~ //UNLESS !Detect([ENEMY])

/////                                                  \\\\\
///// area fixes                                       \\\\\
/////                                                  \\\\\

//Unreferenced night tilesets (Nythrun)
//see also ar1900n.wed
COPY_EXISTING ar1900.are override
              ar2807.are override
  READ_SHORT   0x48 location_flags
  WRITE_SHORT  0x48 location_flags | 0x40
BUT_ONLY

/////                                                  \\\\\
///// creature file fixes                              \\\\\
/////                                                  \\\\\

// anomen specifics fix
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x274 0 //specifics
  END
  BUT_ONLY_IF_IT_CHANGES

// add sleeping flag to sleeping creatures
COPY_EXISTING ~arnman11.cre~ ~override~
              ~arnwar03.cre~ ~override~
  READ_BYTE  0x20 "state"
  WRITE_BYTE 0x20 ("%state%" BAND 0b11101111) // remove the STATE_INVISIBILITY flag
  BUT_ONLY_IF_IT_CHANGES

// These are all player accessible
COPY_EXISTING ~bearblsu.cre~ ~override~ // Black Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearbrsu.cre~ ~override~ // Brown Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearcasu.cre~ ~override~ // Cave Bear (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~bearposu.cre~ ~override~ // Mountain Bear (sppr602.spl -> spanim3.eff -> anisum03.2da) (sppr604.spl -> spanim04.eff -> anisum04.2da)
              ~catliosu.cre~ ~override~ // Lion (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~catliowp.cre~ ~override~ // Joolon (misc3d.itm -> figlion.eff)
              ~demglasu.cre~ ~override~ // Glabrezu (spwi807.spl -> spfiend.eff)
              ~djinnisu.cre~ ~override~ // Djinni (spwi718.spl -> spdj.eff)
              ~dogwasu.cre~  ~override~ // War Dog (sppr402.spl -> spani01.eff -> anisum01.2da)
              ~dogwisu.cre~  ~override~ // Rabid Dog (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~efreetsu.cre~ ~override~ // Efreeti (spwi717.spl -> spefreet.eff)
              ~ettercsu.cre~ ~override~ // Ettercap (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~ghastsu.cre~  ~override~ // Skeleton (sppr301.spl/spwi501.spl -> spandead.eff)
              ~gnollsu.cre~  ~override~ // Gnoll Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~haksu.cre~    ~override~ // Hakeashar (spwi719.spl -> sphack.eff)
              ~hobgobsu.cre~ ~override~ // Hobgoblin Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~koboldsu.cre~ ~override~ // Kobold Commando (spwi309.spl -> spmon1.eff -> spwi309.spl
              ~nishrusu.cre~ ~override~ // Nishruu (spwi624.spl -> spnish.eff)
              ~nymphsu.cre~  ~override~ // Nymph (sppr410.spl -> nymphsu.eff)
              ~ogregrsu.cre~ ~override~ // Ogre Berserker (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~rabbitsu.cre~ ~override~ // Rabbit (spwi919 -> wish02.cre -> spin735.spl -> rabbitsu.eff)
              ~servsu.cre~   ~override~ // Aerial Servant (sppr601.spl -> spserv.eff)
              ~skelwasu.cre~ ~override~ // Skeleton Warrior (sppr301.spl/spwi501 -> spandl15.eff)
              ~smoundsu.cre~ ~override~ // Shambling Mound (staf14.itm -> mound.eff)
              ~spidgisu.cre~ ~override~ // Giant Spider (spwi423.spl -> spidgisu.eff)
              ~spidphsu.cre~ ~override~ // Phase Spider (spwi423.spl -> spidphsu.eff)
              ~spidswsu.cre~ ~override~ // Sword Spider (spwi423.spl -> spidswsu.eff)
              ~stalke.cre~   ~override~ // Invisible Stalker (spwi601.spl -> spstalk.eff)
              ~sumdjinn.cre~ ~override~ // Djinni (ring26.itm -> sumdjinn.eff)
              ~sumelair.cre~ ~override~ // Lesser Air Elemental (staf15.itm -> staf15.eff)
              ~sumefree.cre~ ~override~ // Efreeti (misc3c.itm -> sumefr.eff)
              ~sumelear.cre~ ~override~ // Lesser Earth Elemental (staf16.itm -> staf16.eff)
              ~sumelfir.cre~ ~override~ // Lesser Fire Elemental (staf17.itm -> staf17.eff)
              ~tomegol1.cre~ ~override~ // Flesh Golem (tome01.itm -> tome01.eff)
              ~tomegol2.cre~ ~override~ // Clay Golem (tome02.itm -> tome02.eff)
              ~tomegol3.cre~ ~override~ // Stone Golem (tome03.itm -> tome03.eff
              ~tomegol4.cre~ ~override~ // Juggernaut Golem (tome04.itm -> tome04.eff)
              ~wish02.cre~   ~override~ // Djinni (spwi919.spl)
              ~wolfdisu.cre~ ~override~ // Dire Wolf (sppr402.spl -> spani01.eff -> anisum01.2da) (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~wolfwwsu.cre~ ~override~ // Winter Wolf (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~worgsu.cre~   ~override~ // Worg (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~wyvernsu.cre~ ~override~ // Wyvern (spwi619.spl -> wyvernsu.eff)
              // and these are enemy only but summoned in a familiar way
              ~c6guen.cre~   ~override~ // Guenhwyvar (c6drizz.cre -> c6drizz1.dlg)
              ~sahangu.cre~  ~override~ // Anguiliian (ar2300.are -> sahambo6.cre -> sahambo6.bcs)
              ~sahlace.cre~  ~override~ // Lacedon (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~sahskel.cre~  ~override~ // Skeleton Warrior (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~sahzomb.cre~  ~override~ // Sea Zombie (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~senstalk.cre~ ~override~ // Invisible Stalker (ar6108.bcs)
              ~telelfir.cre~ ~override~ // Greater Fire Elemental (ar3010.are -> teltan1.cre -> teltan1.bcs -> spin570.spl -> sutelfir.eff)
              ~telicesa.cre~ ~override~ // Ice Salamander (ar3010.are -> teltan2.cre -> teltan2.bcs -> spin569.spl -> sutelice.eff)
              // These are unused but of obvious intent for UB authors - spend the day ironing your doilies and polishing your lawn instead
              /*
              ~basilgsu.cre~ ~override~ // Greater Basilisk (spwi8)
              ~basillsu.cre~ ~override~ // Lesser Basilisk (spwi610.spl)
              ~beargrsu.cre~ ~override~ // Grizzly Bear
              ~catjagsu.cre~ ~override~ // Panther
              ~ghastgsu.cre~ ~override~ // Greater Ghast
              ~gibbersu.cre~ ~override~ // Gibberling
              ~hamasu.cre~   ~override~ // Hamadryad
              ~jaguarsu.cre~ ~override~ // Jaguar
              ~jellmusu.cre~ ~override~ // Mustard Jelly (spwi610.spl)
              ~ogremasu.cre~ ~override~ // Ogre Mage (spwi610.spl)
              ~sumtan01.cre~ ~override~ // Tanar'ri
              ~sumtan02.cre~ ~override~ // Tanar'ri
              ~tasloisu.cre~ ~override~ // Tasloi Elite Trooper (spwi706.spl)
              ~wolfsu.cre~   ~override~ // Wolf
              ~wolfwisu.cre~ ~override~ // Winter Wolf (spwi610.spl)
              ~wraithsu.cre~ ~override~ // Wraith
              ~xvartsu.cre~  ~override~ // Xvart Protector
              */
  PATCH_IF (SOURCE_SIZE > 0x02d3) THEN BEGIN
    WRITE_LONG 0x0014 0x00  // XP
    WRITE_LONG 0x001c 0x00  // Gelt, just hobgobsu.cre
    WRITE_BYTE 0x0240 0x00  // "Don't check morale"
    READ_LONG  0x02bc ilo   // lazy overkill no-steal no-drop patch
    FOR (READ_LONG 0x02c0 ilc; ilc > 0x00; ilc -= 0x01) BEGIN
      READ_LONG  (ilo + (ilc * 0x14) - 0x04) flg
      WRITE_LONG (ilo + (ilc * 0x14) - 0x04) (flg | 0x0a)
    END
  END
  BUT_ONLY
  
// wolfwere capt should have same DV for transformed, non-transformed creature files
COPY_EXISTING ~firamb04.cre~ ~override~
  WRITE_ASCII 0x280 ~firamb01~ #32

// lvl 6 trolls should be routed through a different knocked-down version
COPY_EXISTING ~firtrl01.cre~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
  WRITE_ASCII 0x248 ~cdtroll1~
  BUT_ONLY_IF_IT_CHANGES

// deirex killed during cutscene fix 2/2; see 2207.bcs
COPY_EXISTING ~jarlich.cre~ ~override~
  WRITE_BYTE 0x270 128 // make neutral
  BUT_ONLY_IF_IT_CHANGES

// create 'dead' or 'knocked down' versions of 'special' trolls
COPY_EXISTING ~obsice01.cre~ ~override/obsice11.cre~
  WRITE_SHORT           0x24    1            // current HP
  WRITE_SHORT           0x46   10            // natural AC
  WRITE_SHORT           0x48   10            // effective AC
  WRITE_BYTE            0x5a  100            // resist cold
  WRITE_BYTE            0x5b  100            // resist electricity
  WRITE_BYTE            0x5f  100            // resist magic cold
  WRITE_BYTE            0x60  100            // resist slashing
  WRITE_BYTE            0x61  100            // resist crushing
  WRITE_BYTE            0x62  100            // resist piercing
  WRITE_BYTE            0x63  100            // resist missile
  WRITE_BYTE            0x23c   9            // dexterity
  WRITE_BYTE            0x270 255            // enemy
  WRITE_EVALUATED_ASCII 0x248 ~%SOURCE_RES%~ // new script
  WRITE_ASCII           0x250 ~~ #32         // blanks all other script references
  WRITE_ASCII           0x2cc ~~ #8          // blanks dialog file
  // item changes
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "monhp1" = 0) OR // so they can die
               ("%item%" STRING_COMPARE_CASE "trollreg" = 0) OR // can't regenerate
               ("%item%" STRING_COMPARE_CASE "trollspi" = 0) // makes dead spirit troll invisible
             ) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) ~trolldie~
    END
  END

// add monhp1 item to trolls to prevent death; assign script to force transformation to dead form at low HP
COPY_EXISTING ~obsice01.cre~ ~override~
  ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~
  WRITE_ASCII 0x260 ~obsice11~
  
// attacking squatters in paladin-baron quest causes normal townspeople to turn hostile
COPY_EXISTING ~plfarm04.cre~ ~override~
              ~plfarm05.cre~ ~override~
              ~plfarm06.cre~ ~override~
  WRITE_ASCII 0x248 ~gensht01~ // override script
  BUT_ONLY_IF_IT_CHANGES

// prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr2.dlg, string sets
COPY_EXISTING ~sahpr4.cre~ ~override~
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "misc8q" = 0) BEGIN
      READ_BYTE   ("%itm_off%" + 0x10 + (0x14 * "%index%")) "flags"
      WRITE_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%index%")) ("%flags%" BOR   0b00001010) // adds unstealable, undroppable flags
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// name fixes
COPY_EXISTING ~sarbul04.cre~ ~override~
              ~sarbul05.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x08 68792
    WRITE_LONG 0x0c 68792
  END
  BUT_ONLY_IF_IT_CHANGES

// Orcs sound like orcs; blanks human sounds
COPY_EXISTING ~sarculto.cre~ ~override~
              ~sarorc01.cre~ ~override~
              ~saroro01.cre~ ~override~
              ~sarrein1.cre~ ~override~
              ~sartro01.cre~ ~override~
              ~sartro03.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0xa4 0xffffffff
    WRITE_LONG 0xc8 0xffffffff
    WRITE_LONG 0xec 0xffffffff
    WRITE_LONG 0xf0 0xffffffff
    WRITE_LONG 0x10c 0xffffffff
    WRITE_LONG 0x198 0xffffffff
  END
  BUT_ONLY_IF_IT_CHANGES

// Silent Sapper (uses same soundset as sewdue01)
COPY_EXISTING ~sewdue02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    SAY 0xa4 #4940
    SAY 0xec #12584
    SAY 0xf0 #12585
    SAY 0x10c #4939
    SAY 0x110 #4940
  END
  BUT_ONLY_IF_IT_CHANGES

// 'glowing pool' creature from lilarcor quest has dispellable invisibility (via mage item); add it directly as creature effect
COPY_EXISTING ~sewsw.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new effect
      WRITE_LONG  ("%fx_off%" + 0x08)  20 // opcode: invis
      WRITE_LONG  ("%fx_off%" + 0x1c)   1 // instant/permanent
      WRITE_SHORT ("%fx_off%" + 0x24) 100 // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add sleeping flag to sleeping creatures
COPY_EXISTING ~sleepdw.cre~ ~override~   // sleeping dwarf
              ~sleepfh.cre~ ~override~   // sleeping woman
              ~sleepmh.cre~ ~override~   // sleeping man
  READ_BYTE  0x20 "state"
  WRITE_BYTE 0x20 ("%state%" BOR 0b00000001) // add the STATE_SLEEPING flag
  BUT_ONLY_IF_IT_CHANGES

// knocked-down trolls should match their live counterparts
COPY_EXISTING ~troll02.cre~ ~override~
  WRITE_BYTE 0x234 8
  BUT_ONLY_IF_IT_CHANGES

// knocked-down trolls should match their live counterparts
COPY_EXISTING ~troll01.cre~ ~override/cdtroll1.cre~
              ~troll02.cre~ ~override/cdtroll2.cre~
  WRITE_BYTE   0x234 6
  WRITE_ASCIIE 0x248 ~%DEST_RES%~
  
// planar-prison guard can not make the actors hostile by shouting (Wisp)
COPY_EXISTING pcapt03.cre override
  FOR (i = 0x248; i < 0x270; i += 8) BEGIN
    READ_ASCII i script
    PATCH_IF "%script%" STRING_EQUAL_CASE shout BEGIN
      WRITE_ASCII i gensht01 (8)
    END
  END
BUT_ONLY

// A fair bunch of people are male with female sounds or vice versa (Wisp)
// Males with female sounds
COPY_EXISTING c6nerit.cre override
  WRITE_LONG 0xa4 61724 //I welcome you with outstretched hand.
  WRITE_LONG 0xb8 61732 //May the Gods protect me!
  WRITE_LONG 0xc8 61729 //Justice shall be swift and final!
  WRITE_LONG 0xec 61730
  WRITE_LONG 0xf0 61731
  WRITE_LONG 0x10c 61725 //I trust you are here in good faith.
  WRITE_LONG 0x110 61726 //May the Gods look upon you kindly.
  WRITE_LONG 0x114 61724 //I welcome you with outstretched hand.
  WRITE_LONG 0x118 61727 //All of the faithful are welcome, here.
BUT_ONLY

COPY_EXISTING vvshad2.cre override
  WRITE_LONG 0xa4 61885 //Explain your intent, and make it good!
  WRITE_LONG 0xb8 61890 //Must... return to the shadows!
  WRITE_LONG 0xc8 61886 //Beg for death and I'll make it quick!
  WRITE_LONG 0xcc 61887 //No one crosses the Shadow Thieves... and lives!
  WRITE_LONG 0xec 61888
  WRITE_LONG 0xf0 61889
  WRITE_LONG 0x10c 61882 //Good to see a like-minded friend-to-be.
  WRITE_LONG 0x110 61883 //Speak if ye will.
  WRITE_LONG 0x114 61884 //Is there something you seek?
  WRITE_LONG 0x118 61885 //Explain your intent, and make it good!
BUT_ONLY

COPY_EXISTING suelfw6.cre override
  WRITE_LONG 0xa4 61850 //Monsters!  There are monsters everywhere in Suldanessellar!
  WRITE_LONG 0xec 61853
  WRITE_LONG 0xf0 61852
  WRITE_LONG 0x10c 61847 //Wh-what has happened to the queen?  She has been taken, hasn't she!
  WRITE_LONG 0x110 61848 //It is... it is the Exile!  The Exile has returned!
  WRITE_LONG 0x114 61851 //This cannot be happening!  It cannot!
  WRITE_LONG 0x118 61850 //Monsters!  There are monsters everywhere in Suldanessellar!
BUT_ONLY

COPY_EXISTING cowenf1.cre override
  WRITE_LONG 0xa4 61862 //Declare yourself!
  WRITE_LONG 0xb8 61869 //Retreat!
  WRITE_LONG 0xc8 61866 //I'll test your mettle with cold steel!
  WRITE_LONG 0xec 61867
  WRITE_LONG 0xf0 61868
  WRITE_LONG 0x10c 61863 //Do not disturb my duties.
  WRITE_LONG 0x110 61864 //At ease, citizen.
  WRITE_LONG 0x114 61865 //I trust you have no hostile intentions.
  WRITE_LONG 0x118 61862 //Declare yourself!
BUT_ONLY

COPY_EXISTING ttser2.cre override
  WRITE_LONG 0xa4 61690 //Care to dance?
  WRITE_LONG 0xb8 61687 //Another time, another place!
  WRITE_LONG 0xc8 61779 //Plant a blade in your innards, I will!
  WRITE_LONG 0xec 61780
  WRITE_LONG 0xf0 61781
  WRITE_LONG 0x10c 61774 //Prepare to be eviscerated, fool.
  WRITE_LONG 0x110 61690 //Care to dance?
  WRITE_LONG 0x114 61777 //This will be a slow and painful process.
  WRITE_LONG 0x118 61778 //You will suffer... oh, yes.
BUT_ONLY

//Females with male sounds
COPY_EXISTING daelf.cre override
  WRITE_LONG 0xa4 11107 //Yeah?
  WRITE_LONG 0xec 11167
  WRITE_LONG 0xf0 11168
  WRITE_LONG 0x10c 11119 //Hello there.
  WRITE_LONG 0x110 11070 //Few of the fair folk concern themselves with the affairs of the state.
  WRITE_LONG 0x114 "-1"
BUT_ONLY

COPY_EXISTING kproen05.cre override
  WRITE_LONG 0xa4 61872 //I serve with my blade.
  WRITE_LONG 0xb8 61877 //Back... I must fall back!
  WRITE_LONG 0xc8 61874 //Cross blades with me and die!
  WRITE_LONG 0xec 61875
  WRITE_LONG 0xf0 61876
  WRITE_LONG 0x10c 61870 //Speak quickly, citizen, I have little time for this.
  WRITE_LONG 0x110 61871 //Good day to you.
  WRITE_LONG 0x114 61872 //I serve with my blade.
  WRITE_LONG 0x118 61873 //Do nothing stupid and there'll be no problems.
BUT_ONLY

COPY_EXISTING suelf8.cre override
  WRITE_LONG 0xa4 61856 //The Tree of Life!  'Tis the Tree that must be saved, before any of us!
  WRITE_LONG 0xec 61861
  WRITE_LONG 0xf0 61860
  WRITE_LONG 0x10c 61854 //This is the Exile's doing!
  WRITE_LONG 0x110 61855 //So... so many have died!  So many!
  WRITE_LONG 0x114 61856 //The Tree of Life!  'Tis the Tree that must be saved, before any of us!
  WRITE_LONG 0x118 61857 //Rillifane!  Rillifane save us, I beg you!
BUT_ONLY

COPY_EXISTING udelf05.cre override
  WRITE_LONG 0xa4 11063 //Greetings, adventurers.
  WRITE_LONG 0xec 11075
  WRITE_LONG 0xf0 11076
  WRITE_LONG 0x10c 11070 //Few of the fair folk concern themselves with the affairs of the state.
  WRITE_LONG 0x110 11065 //The Fair Folk will inherit the Earth.
  WRITE_LONG 0x114 11063 //Greetings, adventurers.
  WRITE_LONG 0x118 11070 //Few of the fair folk concern themselves with the affairs of the state.
BUT_ONLY

COPY_EXISTING ppmag01.cre override
  WRITE_LONG 0xa4 47345 //A woman on the high seas has t' be tougher than any mate.
  WRITE_LONG 0xec 51867
  WRITE_LONG 0xf0 51868
  WRITE_LONG 0x10c 47345 //A woman on the high seas has t' be tougher than any mate.
  WRITE_LONG 0x110 47347 //Ahhhh, don't look at me like that, or I'll gut ye where ye stand.
  WRITE_LONG 0x114 48338 //Grog.  Grog an' a bath.  Aye...
  WRITE_LONG 0x118 51494 //So I smells like fish.  Begone with ye.
  WRITE_LONG 0x1b8 47347 //Ahhhh, don't look at me like that, or I'll gut ye where ye stand.
BUT_ONLY

ACTION_IF GAME_IS tob BEGIN
  COPY_EXISTING ammonk05.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61994 //Do not anger me.
          WRITE_LONG 0xb8 "-1"
          WRITE_LONG 0xc8 61995 //You shall pay for this, and pay dearly.
          WRITE_LONG 0xcc 61996 //Suffer!
          WRITE_LONG 0xec 61997
          WRITE_LONG 0xf0 61998
          WRITE_LONG 0x10c 61993 //As always, the pleasure is mine.
        END
  BUT_ONLY
  
  COPY_EXISTING yssold16.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61980 //You are welcome in my sight.
          WRITE_LONG 0xc8 61981 //This is your end!
          WRITE_LONG 0xcc 61982 //You've made a fatal error in judgement.
          WRITE_LONG 0xec 61985
          WRITE_LONG 0xf0 61986
          WRITE_LONG 0x10c 61981 //This is your end!
          WRITE_LONG 0x110 61982 //You've made a fatal error in judgement.
        END
  BUT_ONLY
  
  COPY_EXISTING sargrd06.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 4901 //Yer a handsome bunch, ain't ya?
          WRITE_LONG 0xec 12568
          WRITE_LONG 0xf0 12569
          WRITE_LONG 0x10c 4901 //Yer a handsome bunch, ain't ya?
        END
  BUT_ONLY
  
  COPY_EXISTING yaga02.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61625 //We will be saved in the End.
          WRITE_LONG 0xb8 61630 //Aiiiieee!!  I have failed him!!
          WRITE_LONG 0xec 61628
          WRITE_LONG 0xf0 61629
          WRITE_LONG 0x10c 61625 //We will be saved in the End.
        END
  BUT_ONLY
END

//Dawnmaster Kreel's amazing wardrobe change (Wisp)
COPY_EXISTING dawnmas.cre override
  o = 0x2c
  PATCH_FOR_EACH colour IN 226 238 237 201 228 226 200 BEGIN //Values courtesy of cscleric.cre
    WRITE_BYTE o colour
    ++o
  END
  REMOVE_CRE_ITEMS
  ADD_CRE_ITEM staf01 #0 #0 #0 none weapon1 EQUIP TWOHANDED
  ADD_CRE_ITEM chan01 #0 #0 #0 none armor
  ADD_CRE_ITEM rndtre02 #0 #0 #0 none inv7
  
//Tabitha should be immune to charm (Wisp)
COPY_EXISTING coplion.cre override
  LPF ADD_CRE_EFFECT
    INT_VAR
      opcode = 101 //immunity to opcode
      parameter2 = 5
      timing = 9
  END
  LPF ADD_CRE_EFFECT
    INT_VAR
      opcode = 296 //immunity to animation
      timing = 9
    STR_VAR
      resource = spnwchrm
  END
  PATCH_FOR_EACH parameter1 IN 14672 14780 8364 BEGIN
    LPF ADD_CRE_EFFECT
      INT_VAR
        opcode = 267 //protection from display string
        parameter1
        timing = 9
    END
  END
BUT_ONLY

//Sahuagin with a gnoll soundset; strip him of all sounds, as that is how other Sahuagin roll (Wisp)
COPY_EXISTING chevil04.cre override
  PATCH_FOR_EACH offset IN 0xc8 0xcc 0xec 0xf0 0x10c 0x110 BEGIN
    WRITE_LONG offset "-1"
  END
BUT_ONLY

/////                                                  \\\\\
///// item file fixes                                  \\\\\
/////                                                  \\\\\

// ammo with prof 0 removes non-prof penalty
COPY_EXISTING ~arow01.itm~   ~override~ // arrows - arrows w/o shortbow prof
              ~arow02.itm~   ~override~ // arrows +1 - arrows w/o shortbow prof
              ~arow03.itm~   ~override~ // arrow of slaying - arrows w/o shortbow prof
              ~arow04.itm~   ~override~ // acid arrows - arrows w/o shortbow prof
              ~arow05.itm~   ~override~ // arrow of biting - arrows w/o shortbow prof
              ~arow06.itm~   ~override~ // arrows of detonation  - arrows w/o shortbow prof
              ~arow07.itm~   ~override~ // arrows of dispelling - arrows w/o shortbow prof
              ~arow08.itm~   ~override~ // arrow of fire - arrows w/o shortbow prof
              ~arow09.itm~   ~override~ // arrows of ice - arrows w/o shortbow prof
              ~arow10.itm~   ~override~ // arrows of piercing - arrows w/o shortbow prof
              ~arow11.itm~   ~override~ // arrow +2 - arrows w/o shortbow prof
              ~arow14.itm~   ~override~ // poisoned arrow - arrows w/o shortbow prof
              ~arow15.itm~   ~override~ // arrow +3 - arrows w/o shortbow prof
              ~arow1a.itm~   ~override~ // arrow +2 - arrows w/o shortbow prof
              ~bolt01.itm~   ~override~ // bolt - bolts w/o xbow prof
              ~bolt02.itm~   ~override~ // bolt +1 - bolts w/o xbow prof
              ~bolt03.itm~   ~override~ // bolt of lightning - bolts w/o xbow prof
              ~bolt04.itm~   ~override~ // bolt of biting  - bolts w/o xbow prof
              ~bolt05.itm~   ~override~ // bolt of polymorphing - bolts w/o xbow prof
              ~bolt06.itm~   ~override~ // bolt +2 - bolts w/o xbow prof
              ~bolt07.itm~   ~override~ // flasher master bruiser mate - bolts w/o xbow prof
              ~bolt08.itm~   ~override~ // blessed bolt - bolts w/o xbow prof
              ~bolt09.itm~   ~override~ // bolt +3 - bolts w/o xbow prof
              ~bull01.itm~   ~override~ // bullet - bullet w/o sling prof
              ~bull02.itm~   ~override~ // bullet +1 - bullet w/o sling prof
              ~bull03.itm~   ~override~ // bullet +2 - bullet w/o sling prof
              ~bull04.itm~   ~override~ // sunstone bullet +1 - bullet w/o sling prof
              ~bull05.itm~   ~override~ // bullet +3 - bullet w/o sling prof
              ~bull06.itm~   ~override~ // bullet +4 - bullet w/o sling prof
              ~dwbolt01.itm~ ~override~ // drow bolt of sleep - bolts w/o xbow prof
              ~dwbolt02.itm~ ~override~ // drow bolt of stunning - bolts w/o xbow prof
              ~dwbolt03.itm~ ~override~ // drow bolt +1 - bolts w/o xbow prof
              ~flam01.itm~   ~override~ // flamethrower - bolts w/o xbow prof
              ~frag01.itm~   ~override~ // frag grenade - bolts w/o xbow prof
              ~frosty.itm~   ~override~ // dr. freeze death ray - bolts w/o xbow prof
              ~iarow01.itm~  ~override~ // arrows - arrows w/o shortbow prof
              ~kuobolt.itm~  ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~kuobolt2.itm~ ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~kuobolt3.itm~ ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~laser.itm~    ~override~ // laser - bolts w/o xbow prof
              ~light.itm~    ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~puls01.itm~   ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~puls02.itm~   ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~quiv01.itm~   ~override~ // arrows - arrows w/o shortbow prof
              ~quiver01.itm~ ~override~ // quiver of plenty +1 - arrows w/o shortbow prof
              ~quiver02.itm~ ~override~ // case of plenty +1 - bolts w/o xbow prof
              ~quiver03.itm~ ~override~ // quiver of plenty +2 - arrows w/o shortbow prof
              ~quiver04.itm~ ~override~ // case of plenty +2 - bolts w/o xbow prof
              ~quiver05.itm~ ~override~ // bag of plenty +1 - bullet w/o sling prof
              ~quiver06.itm~ ~override~ // bag of plenty +2 - bullet w/o sling prof
              ~sahbolt.itm~  ~override~ // paralytic bolt - bolts w/o xbow prof
              ~secret02.itm~ ~override~ // pulse ammunition - bolts w/o xbow prof
              ~secret03.itm~ ~override~ // frag grenade - bolts w/o xbow prof
              ~secret04.itm~ ~override~ // scorcher ammunition - bolts w/o xbow prof
  READ_SHORT 0x1c "itm_type" ELSE 0
  PATCH_IF (("%itm_type%" = 14) OR    // bullets
            ("%itm_type%" = 31) OR    // bolts
            ("%itm_type%" = 5)) BEGIN // arrows w/o shortbow prof
    WRITE_BYTE 0x31 2 // non-zero prof; doesn't matter
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // SoA-only fix

  // soa black blade does not grant long sword grandmastery per descript; see also SoA-only spwi915.spl patch for duration, thac0 fixes
  COPY_EXISTING ~blakblad.itm~ ~override~
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    WRITE_SHORT 0x70 ("%fx_num%" + 1)
    INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
      WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 233 // modify proficiency
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target:self
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 5   // # pips
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 90  // in long sword
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 2   // not dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + 1)
    END
    BUT_ONLY_IF_IT_CHANGES

END

// two clubs using thrusting animations; other eight do not
COPY_EXISTING ~blun01.itm~ ~override~
              ~blun31.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        WRITE_SHORT ("%abil_off%" + 0x2c + ("%index%" * 0x38)) 50 // Overhead
        WRITE_SHORT ("%abil_off%" + 0x2e + ("%index%" * 0x38)) 50 // Backhand
        WRITE_SHORT ("%abil_off%" + 0x30 + ("%index%" * 0x38))  0 // Thrusting
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cloak of the wuff needs some work; clean up druid transformation spells and give a return to human innate
COPY_EXISTING ~clck04.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < 8 ; index2 = index2 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       172 // opcode: remove spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))         1 // target: self
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))         1 // instant/permanent
        WRITE_LONG  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))       100 // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin160~ // probability
    END
    WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + 3) * 0x30)) ~spinhum~
    WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + 4) * 0x30)) ~spwi491~
    WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + 5) * 0x30)) ~spin122~
    WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + 6) * 0x30)) ~spin123~
    WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + 7) * 0x30)) ~spin124~
    // finally, add return-to-human innate
    INSERT_BYTES  ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30)) 0x30
      WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30))       171 // opcode: give innate ability
      WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30))         1 // target: self
      WRITE_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30))       120 // duration
      WRITE_LONG  ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30))       100 // probability
      WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%" + 8) * 0x30)) ~spin122~ // resref
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) ("%abil_fx_num%" + 9)
    SET "fx_delta" = ("%fx_delta%" + 9)
  END
  BUT_ONLY_IF_IT_CHANGES

// various items stun but use held icon
COPY_EXISTING ~dart03.itm~   ~override~
              ~dartmel.itm~  ~override~
              ~paracarr.itm~ ~override~
              ~paraghas.itm~ ~override~
              ~paraghou.itm~ ~override~
              ~wand04.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 13)) BEGIN // display 'held' icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 55 // stun
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// int drain immunity should also suppress strings, icon (revised by Wisp)
COPY_EXISTING ~ipsion.itm~ ~override~
  LPF ADD_ITEM_EQEFFECT
    INT_VAR
      opcode = 169             //prevent portrait icon
      target = 1
      parameter2 = 86          //icon: int drain
      timing = 2
  END
  PATCH_FOR_EACH parameter1 IN
                 14021         // string: int modification
                 32089         // string: devour brain
  BEGIN
    LPF ADD_ITEM_EQEFFECT
      INT_VAR
        opcode = 267           //protection from display string 
        target = 1
        parameter1
        timing = 2
    END
  END
BUT_ONLY

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a.itm~ ~override/misc3aa.itm~ // zero lore copy
              ~misc3a.itm~ ~override/misc3a.itm~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "%DEST_RES%" = 0) BEGIN // original book
    WRITE_SHORT 0x42 80 // lore
  END
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END ELSE
        PATCH_IF ("%opcode%" = 123) BEGIN // remove item
          WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~%DEST_RES%~ // self
        END ELSE
        PATCH_IF ("%opcode%" = 174) BEGIN // play sound
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // sound should bypass MR
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
          WRITE_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a1.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%"))  1 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // sound should bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a2.itm~ ~override~
              ~misc3a4.itm~ ~override~
              ~misc3a5.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a3.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  5 // target: caster
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
//          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~spwi609~ #8 // priest to mage version ?
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a6.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a7.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
          WRITE_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a8.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rod o' lordly might sub-items created with no charges
COPY_EXISTING ~rodmace.itm~  ~override~
              ~rodspear.itm~ ~override~
              ~rodsword.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      WRITE_BYTE   ("%abil_off%" + 0x24 + ("%index%" * 0x38)) 1 // vanishes
      WRITE_BYTE   ("%abil_off%" + 0x27 + ("%index%" * 0x38)) 0 // recharge: unknown
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from x scrolls should be visible range
COPY_EXISTING ~scrl03.itm~ ~override~
              ~scrl04.itm~ ~override~
              ~scrl05.itm~ ~override~
              ~scrl06.itm~ ~override~
              ~scrl07.itm~ ~override~
              ~scrl08.itm~ ~override~
              ~scrl09.itm~ ~override~
              ~scrl15.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 30 // range correction
  END
  BUT_ONLY_IF_IT_CHANGES

// daystar fix: does 2d8 + 6 vs. evil undead; should be 2d8 + 8
// harder than usual because of all overlapping effs; see also daystar1.eff, daystar2.eff
// move daystar1 to melee header, apply only v undead
COPY_EXISTING ~sw1h31.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("daystar1" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
      DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
      SET "fx_num" = ("%fx_num%" - 1)
      SET "fx_delta" = ("%fx_delta%" - 1)
      SET "index" = ("%index%" - 1)
    END
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~daystar1~ // resref
      SET "fx_delta" = ("%fx_delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragonslayer fix: dragon damage gets an extra +2
COPY_EXISTING ~sw1h32.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("sw1h32a" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
      DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
      SET "fx_num" = ("%fx_num%" - 1)
      SET "fx_delta" = ("%fx_delta%" - 1)
      SET "index" = ("%index%" - 1)
    END
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
  END
  BUT_ONLY_IF_IT_CHANGES

// mage's detect evil scroll using priest spell description
COPY_EXISTING ~scrl86.itm~ ~override~
  SAY 0x54 #12219
  BUT_ONLY_IF_IT_CHANGES

// wand of cursing should cause deafness but is not
COPY_EXISTING ~wand19.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "string"
      PATCH_IF ("%opcode%" = 38) BEGIN // blindness
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 80           // opcode: deafness
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
      PATCH_IF (("%opcode%" = 139) AND ("%string%" = 14002)) BEGIN // display 'silence' string
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 54318        // string 'deaf'
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//Asp's Nest darts do 1 HP damage every second for 40 seconds but are stated to do 1 HP damage every 3 seconds for 120 seconds (Wisp)
COPY_EXISTING dart05.itm override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ao
    READ_SHORT 0x68 na
    READ_LONG  0x6a eo
    FOR (i=0;i<na;i+=1) BEGIN
      READ_SHORT ao + 0x38*i + 0x1e en ELSE 0
      READ_SHORT ao + 0x38*i + 0x20 ei ELSE 0
      FOR (j=0;j<en;j+=1) BEGIN
        READ_SHORT eo + 0x30*(ei + j) type ELSE 999
        PATCH_IF type = 25 BEGIN
          WRITE_LONG  eo + 0x30*(ei + j) + 0x4  3
          WRITE_LONG  eo + 0x30*(ei + j) + 0x8  3
          WRITE_LONG  eo + 0x30*(ei + j) + 0xe  120
        END ELSE BEGIN
          WRITE_LONG eo + 0x30*(ei + j) + 0xe 120
        END
      END
    END
  END
BUT_ONLY

//Flasher Master Bruiser Mates lack their advertised +1 to hit and have an undocumented save penalty (Wisp)
COPY_EXISTING bolt07.itm override
  READ_LONG  0x64 ao
  READ_SHORT 0x68 na
  READ_LONG  0x6a eo
  FOR (i = 0; i < na; ++i) BEGIN
    WRITE_SHORT ao + 0x38*i + 0x14 1
    READ_SHORT  ao + 0x38*i + 0x1e en
    READ_SHORT  ao + 0x38*i + 0x20 ei
    FOR (j = 0; j < en; ++j) BEGIN
      WRITE_LONG eo + 0x30*(ei + j) + 0x28 0
    END
  END
BUT_ONLY

//Give Root of the Problem a price (Wisp)
COPY_EXISTING blun10.itm override
  WRITE_LONG 0x34 2750
BUT_ONLY

//Staff of Curing does not cure portrait icons (Wisp)
COPY_EXISTING staf10.itm override
  PATCH_FOR_EACH parameter2 IN 5 6 7 BEGIN //Intoxication, poison, disease
    LPF ADD_ITEM_EFFECT
      INT_VAR
        opcode = 240
        target = 2
        power = 2
        parameter2
        timing = 1
        resist_dispel = 3
    END
  END
BUT_ONLY

//Belt of Inertial Barrier displays MR icon instead of Resistance to Magic Energy (Wisp)
COPY_EXISTING belt10.itm override
  READ_LONG  0x6a eo
  FOR (i = 0; i < SHORT_AT 0x70; ++i) BEGIN
    READ_SHORT eo + 0x30 * i type
    READ_LONG  eo + 0x30 * i + 0x8 p2
    PATCH_IF type = 142 AND p2 = 63 BEGIN //Display icon; magic resistance
      WRITE_LONG eo + 0x30 * i + 0x8 73 //Protection from Magical Energy
    END
  END
BUT_ONLY

/////                                                  \\\\\
///// spell fixes                                      \\\\\
/////                                                  \\\\\

// projected images and simulcra shouldn't have slayer and pocket plane abilities
COPY_EXISTING ~projimag.spl~ ~override~
              ~simulacr.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))  172 // remove spell opcode
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    1 // target: self
        WRITE_BYTE  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%"))   84 // duration
        WRITE_LONG  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    END
    WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin649~
    WRITE_ASCII  ("%fx_off%" + 0x44 + (0x30 * "%abil_fx_idx%")) ~spin822~
    SET "fx_delta" = "%fx_delta%" + 2
  END
  BUT_ONLY_IF_IT_CHANGES

// kensai weapon speed
COPY_EXISTING ~spcl143.spl~ ~override~
  PATCH_IF (SOURCE_SIZE = 0xca) THEN BEGIN
    READ_LONG  0x64 "ho"
    READ_LONG  0x6a "eo"
    READ_ASCII "ho" ~h1~ (0x28)
    READ_ASCII "eo" ~fx~ (0x30)
    FOR (READ_SHORT 0x68 "hc"; "hc" < 10; "hc" += 0x1) BEGIN
      INSERT_BYTES ("ho" + ("hc" * 0x28) + 0x00) 0x28
      WRITE_ASCIIE ("ho" + ("hc" * 0x28) + 0x00) ~%h1%~
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x10) ("hc" * 0x4)
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x20) "hc"
      INSERT_BYTES ("eo" + ("hc" * 0x58) + 0x00) 0x30
      WRITE_ASCIIE ("eo" + ("hc" * 0x58) + 0x00) ~%fx%~
      WRITE_LONG   ("eo" + ("hc" * 0x58) + 0x04) ("hc" + 0x1)
    END
    WRITE_SHORT 0x68 "hc"
    WRITE_LONG  0x6a ("eo" + (0x28 * ("hc" - 0x1)))
  END
BUT_ONLY

// transformation spells themselves need to nuke leftover bits from other transformations
COPY_EXISTING ~spcl611.spl~ ~override~ // druid shapeshift brown bear
              ~spcl612.spl~ ~override~ // druid shapeshift wuff
              ~spcl613.spl~ ~override~ // druid shapeshift black bear
              ~spcl632.spl~ ~override~ // avenger shapeshift spider
              ~spcl633.spl~ ~override~ // avenger shapeshift baby wyvern
              ~spcl634.spl~ ~override~ // avenger shapeshift fire salamander
              ~spcl643.spl~ ~override~ // shapeshifter shapeshift werewolf
              ~spcl644.spl~ ~override~ // shapeshifter shapeshift greater werewolf
              ~spin823.spl~ ~override~ // slayer change
              ~spin852.spl~ ~override~ // slayer change ii
              ~sppr731.spl~ ~override~ // druid hla fire elemental transformation
              ~sppr732.spl~ ~override~ // druid hla earth elemental transformation
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  SET "new_fx_6" = 0
  SET "new_fx_7" = 0
  SET "new_fx_8" = 0
  SET "new_fx_9" = 0
  SET "new_fx_10" = 0
  SET "new_fx_11" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "param"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "resref"
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin160" = 0)) BEGIN // remove spell
        SET "new_fx_6" = ("%new_fx_6%" + 1) // increment; should total 3
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhum" = 0)) BEGIN // remove spell
        SET "new_fx_7" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spwi491" = 0)) BEGIN // remove spell
        SET "new_fx_8" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin122" = 0)) BEGIN // remove spell
        SET "new_fx_9" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin123" = 0)) BEGIN // remove spell
        SET "new_fx_10" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin124" = 0)) BEGIN // remove spell
        SET "new_fx_11" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END
    END
    FOR (index3 = new_fx_6 ; index3 < 3 ; index3 = index3 + 1) BEGIN // remove 3x salamander fire breath
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin160~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_7%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spinhum~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_8%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spwi491~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_9%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin122~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_10%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin123~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_11%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin124~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) ("%abil_fx_num%")
  END
  BUT_ONLY_IF_IT_CHANGES

// monk weapon speed
COPY_EXISTING ~spcl816.spl~ ~override~
  PATCH_IF (SOURCE_SIZE = 0xca) THEN BEGIN
    READ_LONG  0x64 "ho"
    READ_LONG  0x6a "eo"
    READ_ASCII "ho" ~h1~ (0x28)
    READ_ASCII "eo" ~fx~ (0x30)
    FOR (READ_SHORT 0x68 "hc"; "hc" < 2; "hc" += 0x1) BEGIN
      INSERT_BYTES ("ho" + ("hc" * 0x28) + 0x00) 0x28
      WRITE_ASCIIE ("ho" + ("hc" * 0x28) + 0x00) ~%h1%~
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x10) ("hc" * 12)
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x20) "hc"
      INSERT_BYTES ("eo" + ("hc" * 0x58) + 0x00) 0x30
      WRITE_ASCIIE ("eo" + ("hc" * 0x58) + 0x00) ~%fx%~
      WRITE_LONG   ("eo" + ("hc" * 0x58) + 0x04) ("hc" + 0x1)
    END
    WRITE_SHORT 0x68 "hc"
    WRITE_LONG  0x6a ("eo" + (0x28 * ("hc" - 0x1)))
  END
BUT_ONLY

// wing buffet, hell knockback shouldn't be stopped by spell protections
COPY_EXISTING ~spin658.spl~ ~override~ // wing buffet
              ~spin695.spl~ ~override~ // wing buffet
  WRITE_SHORT 0x25 0 // schoolless
  WRITE_BYTE  0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon_silence's lowest level header should be level 1, not 20
COPY_EXISTING ~spin692.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  PATCH_IF ("%abil_num%" != 0) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x10) 1 // set to level 1
  END
  BUT_ONLY_IF_IT_CHANGES

// spells to transform trolls back from dead to alive
COPY_EXISTING ~spin955.spl~ ~override/cdtroll1.spl~
              ~spin955.spl~ ~override/obsice01.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 151) AND ("%eff_file%" STRING_COMPARE_CASE "troll01" = 0)) BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "%DEST_RES%" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shapeshifting return-to-human spells need to remove all shapeshifted weapons, abilities, etc.
COPY_EXISTING ~spin122.spl~ ~override~
              ~spin123.spl~ ~override~
              ~spin124.spl~ ~override~
              ~spinhum.spl~ ~override~
              ~spwi491.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "fx_delta" = 0
  SET "new_fx_1" = 0
  SET "new_fx_2" = 0
  SET "new_fx_3" = 0
  SET "new_fx_4" = 0
  SET "new_fx_5" = 0
  SET "new_fx_6" = 0
  SET "new_fx_7" = 0
  SET "new_fx_8" = 0
  SET "new_fx_9" = 0
  SET "new_fx_10" = 0
  SET "new_fx_11" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "param"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "resref"
      // first, purge sound-to-be redundant effects
      PATCH_IF ("%opcode%" = 112) BEGIN // remove item, spell
        DELETE_BYTES ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 0x30 // delete effect
        SET "fx_delta" = "%fx_delta%" - 1
        SET "index2" = "%index2%" - 1
        SET "abil_fx_num" = "%abil_fx_num%" - 1
      END
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 7)) BEGIN // reenable talk button
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 2)) BEGIN // reenable select spell
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 3)) BEGIN // reenable quick spell 1
        SET "new_fx_3" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 4)) BEGIN // reenable quick spell 2
        SET "new_fx_4" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 5)) BEGIN // reenable quick spell 3
        SET "new_fx_5" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin160" = 0)) BEGIN // remove spell
        SET "new_fx_6" = ("%new_fx_6%" + 1) // increment; should total 3
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhum" = 0)) BEGIN // remove spell
        SET "new_fx_7" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spwi491" = 0)) BEGIN // remove spell
        SET "new_fx_8" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin122" = 0)) BEGIN // remove spell
        SET "new_fx_9" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin123" = 0)) BEGIN // remove spell
        SET "new_fx_10" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin124" = 0)) BEGIN // remove spell
        SET "new_fx_11" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END
    END
    PATCH_IF ("%new_fx_1%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 7            // talk
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_2%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 2            // spell select
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_3%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 3            // quick spell 1
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_4%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 4            // quick spell 2
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_5%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 5            // quick spell 3
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    FOR (index3 = new_fx_6 ; index3 < 3 ; index3 = index3 + 1) BEGIN // remove 3x salamander fire breath
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin160~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_7%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spinhum~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_8%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spwi491~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_9%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin122~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_10%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin123~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_11%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin124~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    // insert an item creation at top
    INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
      WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
      WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 111          // create item
      WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~wolfm~ #8   // resource
    // at the end, remove the newly created wolfm
    INSERT_BYTES   ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0x30
      WRITE_ASCIIE ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~%template%~ // clone
      WRITE_SHORT  ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 112          // remove item
      WRITE_ASCII  ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~wolfm~ #8   // resource
    SET "fx_delta" = "%fx_delta%" + 2
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// remove paralysis not removing icons on target
COPY_EXISTING ~sppr308.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 240) BEGIN // remove icon opcode
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// chaotic commands not protecting against psionic maze
COPY_EXISTING ~sppr508.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing indices
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi813" = 0)) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (48)
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin774~
        SET "fx_delta" = "%fx_delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// (un)holy word not displaying deaf portrait icon for deafened characters; see icondeaf.eff
COPY_EXISTING ~sppr710.spl~ ~override~
              ~sppr715.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 177) AND ("%eff_file%" STRING_COMPARE_CASE "deafness" = 0)) BEGIN // deaf eff file
        READ_ASCII     ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%"    ) * 0x30))) "clone_fx" (48)
        INSERT_BYTES   ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) 0x30             // new effect
          WRITE_ASCIIE ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) "%clone_fx%"     // cloned effect
          WRITE_ASCII  ("%fx_off%" + 0x14 + ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) "icondeaf"       // new eff reference
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong vvc for regen at lvl 15
COPY_EXISTING ~sppr711.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND ("%resref%" STRING_COMPARE_CASE "magres" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "icwrati" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// bad targets for pfnm sound effect targeting
COPY_EXISTING ~spra303.spl~ ~override~ // avenger
              ~spwi311.spl~ ~override~ // generic arcane
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi114.spl~ ~override~ // shield
              ~spwi818.spl~ ~override~ // bigby's clenched fist
              ~spwi918.spl~ ~override~ // bigby's crushing hand
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 15 // evocation animation
  END
  BUT_ONLY_IF_IT_CHANGES

// spook's 'panic' string not properly quashed by MR
COPY_EXISTING ~spwi125.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "dispel"
      PATCH_IF ("%dispel%" = 3) BEGIN // if dispel, bypass MR...
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // change to dispel, no bypass MR
      END ELSE
      PATCH_IF ("%dispel%" = 0) BEGIN // if no dispel, bypass MR...
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 2 // change to no dispel, no bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mage detect evil using priest spell description
COPY_EXISTING ~spwi202.spl~ ~override~
  SAY 0x50 #12219
  BUT_ONLY_IF_IT_CHANGES

// horror duration incorrect
COPY_EXISTING ~spwi205.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      PATCH_IF ("%duration%" = 18) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 60
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// luck not providing saving throw and thieving skill bonuses; duration incorrect
COPY_EXISTING ~spwi209.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    // first fix duration while we're here
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF ("%duration%" = 20) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 18
      END
      PATCH_IF (("%opcode%" = 174) AND ("%resref%" STRING_EQUAL_CASE "EFF_M05")) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // fix invalid sound effect duration
      END
      PATCH_IF ("%opcode%" = 133) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (0x30)
        FOR (index3 = 33 ; index3 < 38 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0x30 // new effect
            WRITE_ASCIIE ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%clone%"
            WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%index3%" // opcode: one of them thar saves
        END
	PATCH_FOR_EACH ~thskill~ IN ~59~ ~90~ ~91~ ~92~ ~275~ ~276~ ~277~ BEGIN                   // all 7 thieving skill opcodes
        INSERT_BYTES            ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) 0x30         // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) "%clone%"    // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) "%thskill%"  // opcode
          WRITE_LONG            ("%fx_off%" + 0x04 + ("%index2%" + "%abil_fx_idx%")) 5            // param1: 5 (5% bonus)
          WRITE_LONG            ("%fx_off%" + 0x08 + ("%index2%" + "%abil_fx_idx%")) 0            // param2: 0 (cumulative bonus type)
        END
        SET "fx_delta" = ("%fx_delta%" + 12)
        SET "index2" = ("%index2%" + 12)
        SET "abil_fx_num" = ("%abil_fx_num%" + 12)
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// portrait icon for melf's acid arrow bypasses MR though spell itself does not
COPY_EXISTING ~spwi211.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    WRITE_SHORT ("%abil_off%" +        (0x28 * "%index%")) 1 // change to melee (lvl 1 header is ranged)
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 142) BEGIN
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // dispel/not bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi222.spl~ ~override~ // chaos shield
              ~spwi723.spl~ ~override~ // improved chaos shield
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 12 // abjuration animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect duration, targeting for invis 10'
COPY_EXISTING ~spwi307.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      PATCH_IF ("%duration%" = 300) BEGIN
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 7200
      END
      PATCH_IF ("%opcode%" = 174) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi409.spl~ ~override~ // contagion
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 9 // necromancy animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi424.spl~ ~override~ // farsight
              ~spwi515.spl~ ~override~ // oracle
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 16 // divination animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi505.spl~ ~override~ // shadow door
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 13 // illusion animation
  END
  BUT_ONLY_IF_IT_CHANGES

// hold monster swirly graphic craps out early; should also set icon and display 'held' string
COPY_EXISTING ~spwi507.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) THEN BEGIN
      SET "min_lev" = 9
    END
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    SET "fx_delta" = ("%fx_delta%" + 2)
    // fix duration for swirly graphic while we're here, then clone the effect
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) (6 * "%min_lev%")
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (48)
      END
    END
    INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))      0x30 // new effect
      WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // use 215 effect as base
      WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))       142 // display portrait icon
      WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%"))        13 // icon: held
    INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))      0x30 // new effect
      WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // use 215 effect as base
      WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))       139 // display string
      WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%"))     14102 // string: held
      WRITE_BYTE   ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))         1 // instant/permanent
      WRITE_BYTE   ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%"))         0 // duration
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong string for pfnw's protection from pfmw spell
COPY_EXISTING ~spwi511.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi611" = 0)) BEGIN // replace s&s descript
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 36743
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell shield does not have listed durations due to missing ability headers
COPY_EXISTING ~spwi519.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // first fix existing effects
    READ_SHORT  ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 11
    END
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass resistance
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (18 * "%min_lev%") // corrects duration
      END
    END
  END
  FOR (index3 = min_lev + 1 ; index3 < 21 ; index3 = index3 + 1) BEGIN
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    SET "abil_fx_idx" = "%abil_fx_idx%" + "%abil_fx_num%"
    INSERT_BYTES   ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_ASCIIE ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR (index4 = 0 ; index4 < abil_fx_num ; index4 = index4 + 1) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (18 * "%index3%") // corrects duration
        END
      END
    INSERT_BYTES   ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28        // inserts bytes
      WRITE_ASCIIE ("%abil_off%" +        ("%abil_num%" * 0x28)) "%ability%" // clones existing ability
      WRITE_SHORT  ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) ("%index3%") // minimum level
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) "%abil_fx_idx%"
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = ("%abil_num%" + 1)
  END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // SoA-only fix

  // SoA black blade missing lev 19, 20 headers; see also blakblad.itm SoA patch for prof fix
  COPY_EXISTING ~spwi915.spl~ ~override~
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // first fix existing effects
      READ_SHORT  ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
      PATCH_IF ("%min_lev%" = 1) BEGIN
        SET "min_lev" = 18
      END
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
        PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
          WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (21 - "%min_lev%") // adjusted for level
          WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1                  // set to value
        END
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass resistance
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (6 * "%min_lev%") // corrects duration
        END
      END
    END
    FOR (index3 = min_lev + 1 ; index3 < 21 ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
      READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
      SET "abil_fx_idx" = "%abil_fx_idx%" + "%abil_fx_num%"
      INSERT_BYTES   ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
        WRITE_ASCIIE ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
        FOR (index4 = 0 ; index4 < abil_fx_num ; index4 = index4 + 1) BEGIN    // loop to adjust effects by min level
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index4%"))) "opcode"
          READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) "duration"
          PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
            WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (21 - "%index3%") // adjusted for level
          END
          PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
            WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (6 * "%index3%") // corrects duration
          END
        END
      INSERT_BYTES   ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28        // inserts bytes
        WRITE_ASCIIE ("%abil_off%" +        ("%abil_num%" * 0x28)) "%ability%" // clones existing ability
        WRITE_SHORT  ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) ("%index3%") // minimum level
        WRITE_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) "%abil_fx_idx%"
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
    WRITE_LONG  0x6a "%fx_off%"
    WRITE_SHORT 0x68 "%abil_num%"
    BUT_ONLY_IF_IT_CHANGES

END

//Creeping Doom's panic effect does not work; replace the repeating eff with delayed effects (Wisp)
//see also flpr717a.spl
COPY_EXISTING sppr717.spl override //Creeping Doom
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ao
    READ_SHORT 0x68 na
    READ_LONG  0x6a eo
    en = 0
    ei = 0
    FOR (i=0;i<na;i+=1) BEGIN
      ei += en
      WRITE_SHORT ao + 0x28*i + 0x20 ei
      READ_SHORT  ao + 0x28*i + 0x1e en
      FOR (j=0;j<en;j+=1) BEGIN
        READ_SHORT eo + 0x30*(ei + j) type ELSE 999
        READ_ASCII eo + 0x30*(ei + j) + 0x14 rr ELSE blank
        PATCH_IF type = 272 AND "%rr%" STRING_EQUAL_CASE panic BEGIN
          DELETE_BYTES eo + 0x30*(ei + j) 0x30
          en -= 1
          j -= 1
          PATCH_FOR_EACH time IN 0 6 12 BEGIN
            INSERT_BYTES eo + 0x30*(ei + j)        0x30
            WRITE_SHORT  eo + 0x30*(ei + j)        146 //Cast spell (at creature)
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x2  2
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x3  7
            WRITE_LONG   eo + 0x30*(ei + j) + 0x8  1
            WRITE_BYTE   eo + 0x30*(ei + j) + 0xc  4
            WRITE_BYTE   eo + 0x30*(ei + j) + 0xd  1
            WRITE_LONG   eo + 0x30*(ei + j) + 0xe  time
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x12 100
            WRITE_ASCII  eo + 0x30*(ei + j) + 0x14 flpr717a #8
            en += 1
            j += 1
          END
        END
      END
      WRITE_SHORT ao + 0x28*i + 0x1e en
    END
  END
BUT_ONLY

//Creeping Doom's panic effect does not work
//see also sppr717.spl
//panic for 1 round, portrait icon, display string; save vs. spell at -2; power 0
COPY "bg2fixpack/copy/flpr717a.spl" override

//Set power of summoning spells to 0, otherwise they can get blocked if the caster is under (M)GoI (code by Wisp; general idea by lotsa people)
COPY_EXISTING
  melis03.spl override //Taint of the Slayer
  senspisu.spl override //Summon Spider
  spcl621.spl override //Summon Spirit Animal
  spcl923.spl override //Summon Deva
  //spin534.spl override //Call Dark Horde, unused
  //spin548.spl override //Gate, power is 0, unused
  //spin549.spl override //Summon the Infernal Host, power is 0
  //spin569.spl override //Summon Ice Salamander, power is 0
  //spin570.spl override //Summon Fire Elemental, power is 0, unused
  spin615.spl override //Knight
  spin616.spl override //Flames
  spin622.spl override //Skull
  //spin631.spl override //Construct, unused
  //spin637.spl override //Guile, unused
  //spin638.spl override //Triumph, unused
  //spin677.spl override //<Invalid Strref -1>, power is 0, unused
  //spin730.spl override //Summon Fungus, power is 0
  //spin735.spl override //Wish, power is 0
  //spin841.spl override //<Invalid Strref -1>, power is 0, unused
  //spin842.spl override //<Invalid Strref -1>, power is 0, unused
  //spin843.spl override //<Invalid Strref -1>, power is 0, unused
  //spin844.spl override //<Invalid Strref -1>, power is 0, unused
  //spin845.spl override //<Invalid Strref -1>, power is 0, unused
  //spin855.spl override //<Invalid Strref -1>, power is 0
  //spin856.spl override //<Invalid Strref -1>, power is 0
  //spin857.spl override //<Invalid Strref -1>, power is 0
  //spin870.spl override //<Invalid Strref -1>, power is 0
  //spin880.spl override //<Invalid Strref -1>, power is 0
  sppr301.spl override //Animate Dead
  sppr402.spl override //Animal summoning I
  sppr410.spl override //Call Woodland Beings
  sppr501.spl override //Animal summoning II
  sppr601.spl override //Aerial Servant
  sppr602.spl override //Animal summoning III
  sppr604.spl override //Conjure Animals
  sppr605.spl override //Conjure Fire Elemental
  sppr702.spl override //Conjure Earth Elemental
  sppr703.spl override //Gate
  sppr723.spl override //Elemental Summoning
  sppr724.spl override //Greater Elemental Summoning
  sppr726.spl override //Summon Deva
  sppr727.spl override //Summon Fallen Deva
  //spra304.spl override //Animal summoning I, power is 0
  spra305.spl override //Animal summoning II
  spra306.spl override //Animal summoning III
  spwi309.spl override //Monster summoning I
  spwi407.spl override //Monster summoning II
  spwi423.spl override //Spider Spawn
  spwi501.spl override //Animate Dead
  spwi504.spl override //Monster summoning III
  spwi516.spl override //Conjure Lesser Fire Elemental
  spwi520.spl override //Conjure Lesser Air Elemental
  spwi521.spl override //Conjure Lesser Earth Elemental
  spwi601.spl override //Invisible Stalker
  spwi619.spl override //Wyvern Call
  spwi620.spl override //Conjure Fire Elemental
  spwi621.spl override //Conjure Air Elemental
  spwi622.spl override //Conjure Earth Elemental
  spwi623.spl override //Carrion Summons
  spwi624.spl override //Summon Nishruu
  spwi707.spl override //Cacofiend
  spwi716.spl override //Mordenkainen's Sword
  spwi717.spl override //Summon Efreeti
  spwi718.spl override //Summon Djinni
  spwi719.spl override //Summon Hakeashar
  //spwi722.spl override //Limited Wish, power is 0
  spwi807.spl override //Summon Fiend
  spwi905.spl override //Gate
  spwi923.spl override //Summon Planetar
  spwi924.spl override //Summon Dark Planetar
  spwish18.spl override //Summon Dark Planetar
  spwm154.spl override //Cacofiend
  sumslay.spl override //Summon Slayer Shadow
  FOR (READ_LONG 0x6a fx_off ELSE 0;fx_off<SOURCE_SIZE;fx_off+=0x30) BEGIN
    WRITE_BYTE fx_off + 3 0
  END
BUT_ONLY
  
/////                                                  \\\\\
///// store fixes                                      \\\\\
/////                                                  \\\\\


/////                                                  \\\\\
///// pro fixes                                        \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// vvc fixes                                        \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// eff fixes                                        \\\\\
/////                                                  \\\\\

// new eff for holy smite; needs to display blind icon for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind.eff~
  WRITE_LONG 0x10 142 // display portrait icon
  WRITE_LONG 0x20 8   // icon: blinded

// new eff for holy smite; needs to display blinded string for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind1.eff~
  WRITE_LONG 0x10 139   // display string
  WRITE_LONG 0x1c 14674 // string: blinded

COPY ~bg2fixpack/eff/daystar2.eff~ ~override~ // for daystar fixes (see sw1h31.itm, daystar1.eff~

// daystar damage vs. evil undead fixes, pt. 2 (see sw1h31.itm, daystar2.eff)
COPY_EXISTING ~daystar1.eff~ ~override~
  WRITE_LONG  0x10        177 // use eff file
  WRITE_LONG  0x1c          3 // against mask_evil...
  WRITE_LONG  0x20          8 // ...from align.ids
  WRITE_ASCII 0x30 ~daystar2~ // then actually go to another +2 damage

// new eff for (un)holy word to display deaf icon; see sppr710.spl, sppr715.spl
COPY_EXISTING ~iconslow.eff~ ~override/icondeaf.eff~
  WRITE_LONG 0x20 112 // deafened

/////                                                  \\\\\
///// music fixes                                      \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// immunity effects batches                         \\\\\
/////                                                  \\\\\

// include macros for batch processing
INCLUDE ~bg2fixpack/lib/macro_fx_batch_prep.tph~

// make sure blindness effects always have a blind icon and string
COPY_EXISTING ~gorwom4.itm~ ~override~ // drow flail +3
              ~sorb.itm~    ~override~ // searing orb
              ~sw1h51.itm~  ~override~ // celestial fury +3
              ~wand19.itm~  ~override~ // wand of cursing
              ~spdr101.spl~ ~override~ // chromatic orb
              ~spin595.spl~ ~override~ // yellow dragon scorching sand
              ~spin878.spl~ ~override~ // level drain
              ~spin893.spl~ ~override~ // shadow dragon breath
              ~spin929.spl~ ~override~ // mist ball
              ~spin931.spl~ ~override~ // sooty ball
              ~sppr313.spl~ ~override~ // holy smite
              ~sppr707.spl~ ~override~ // sunray
              ~spwi118.spl~ ~override~ // chromatic orb
              ~spwi224.spl~ ~override~ // glitterdust
              ~spwi714.spl~ ~override~ // prismatic spray
              ~spwi815.spl~ ~override~ // power word blind
              ~spwi958.spl~ ~override~ // power word, blind
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF ("%opcode%" = 74) BEGIN // blindness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 8)) BEGIN // display blinded portrait icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 139) AND (("%param1%" = 1474) OR ("%param1%" = 14674))) BEGIN // display 'blinded' string
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "blind" = 0)) BEGIN // blindness via eff
          SET "new_fx_4" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "cdblind" = 0)) BEGIN // blindness icon via eff
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "cdblind1" = 0)) BEGIN // blindness string via eff
          SET "new_fx_6" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8            // blinded
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 139          // display string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14674        // blinded
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_4%" = 1) BEGIN
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 177          // display portrait icon
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdblind~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%"  // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 177           // display portrait icon
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdblind1~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// petrification
COPY_EXISTING ~balth02.spl~  ~override~ // lunar stance!
              ~bazdra02.cre~ ~override~ // draconis
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demosum4.cre~ ~override~ // cambion
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~fangel01.cre~ ~override~ // einhiris
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~golstone.itm~ ~override~ // ring
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorcamb.cre~  ~override~ // aesgareth
              ~gorstalk.cre~ ~override~ // guardian of air
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~innoc.itm~    ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~minhp20.itm~  ~override~ // <invalid strref -1>
              ~objring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn38.itm~   ~override~ // potion of mirrored eyes
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~scrl15.itm~   ~override~ // protection from petrification
              ~shalt01.itm~  ~override~ // ring
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl917.spl~  ~override~ // avoid death
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi108.spl~  ~override~ // protection from petrification
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h71.itm~   ~override~ // hindo's doom +4
              ~sword01.cre~  ~override~ // magical sword
              ~telpit1.cre~  ~override~ // pit fiend
              ~telslav2.itm~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 134)) BEGIN // petrification immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14665)) BEGIN // disable string "petrified"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14665        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// kill target
COPY_EXISTING ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~bazdra01.cre~ ~override~ // draconis
              ~bazdra02.cre~ ~override~ // draconis
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalrv01.cre~ ~override~ // the ravager
              ~chalslay.cre~ ~override~ // slayer
              ~demilich.cre~ ~override~ // demi-lich
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~golice01.cre~ ~override~ // ice golem
              ~gorchr.itm~   ~override~ // ring
              ~gorsal.cre~   ~override~ // saladrex
              ~hgmnd2.cre~   ~override~ // shambling mound
              ~hgmound.cre~  ~override~ // shambling mound
              ~holdring.itm~ ~override~ // ring
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~invulner.itm~ ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shararm.itm~  ~override~ // darkmail +3
              ~spcl917.spl~  ~override~ // avoid death
              ~sw1h71.itm~   ~override~ // hindo's doom +4
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~yaga01.cre~   ~override~ // yaga-shura
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 13)) BEGIN // kill target immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 64285)) BEGIN // disable string "vorpal hit"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14026)) BEGIN // disable string "death"
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 64285        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14026        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// invisibility
COPY_EXISTING ~bazpatrg.itm~ ~override~ // ring
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 20)) BEGIN // immunity to invisibility
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14773)) BEGIN // disable string "invisible"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14773        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// silence
COPY_EXISTING ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul21.itm~   ~override~ // amulet of power
              ~amul28.itm~   ~override~ // amulet of the master harper
              ~dragring.itm~ ~override~ // ring
              ~firlch01.cre~ ~override~ // fire lich
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorstalk.cre~ ~override~ // guardian of air
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~spwi219.spl~  ~override~ // vocalize
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~susuneer.cre~ ~override~ // suneer
              ~sw1h50.itm~   ~override~ // shazzellim +1
              ~telqua1.cre~  ~override~ // quasit
              ~telqua2.cre~  ~override~ // quasit
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 38)) BEGIN // silence immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14002)) BEGIN // disable string "silence"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14676)) BEGIN // disable string "silenced"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 34)) BEGIN // prevent silenced icon
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14002        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14676        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 34           // silenced
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// blindness
COPY_EXISTING ~sword01.cre~ ~override~
              ~npmisc1.itm~ ~override~
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 74)) BEGIN // immunity to blindness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1474)) BEGIN // disable string "blind"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14674)) BEGIN // disable string "blinded"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 8)) BEGIN // prevent blind icon
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1474        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14674        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8            // blind
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// deafness
COPY_EXISTING ~sword01.cre~ ~override~
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 80)) BEGIN // immunity to deafness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 54318)) BEGIN // disable string "deaf"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 112)) BEGIN // prevent deaf icon
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 54318        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 112          // deaf
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// slay
COPY_EXISTING ~balth02.spl~ ~override~ // lunar stance!
              ~spcl415.spl~ ~override~ // <invalid strref -1>
              ~spcl917.spl~ ~override~ // avoid death
              ~spin853.spl~ ~override~ // otiluke's resilient sphere
              ~sppr409.spl~ ~override~ // death ward
              ~spwi853.spl~ ~override~ // otiluke's resilient sphere
              ~sw1h71.itm~  ~override~ // hindo's doom +4
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 55)) BEGIN // immunity to slay
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 51)) BEGIN // prevent dying icon
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 51           // deaf
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// detect invisible
COPY_EXISTING ~swordi.itm~   ~override~ // <invalid strref -1>
              ~ucounter.cre~ ~override~ // <invalid strref -1>
              ~uhostile.cre~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 116)) BEGIN // immunity to detect invisible
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14109)) BEGIN // disable string "dispel invisible"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14109        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// polymorph
COPY_EXISTING ~bazdra02.cre~ ~override~ // draconis
              ~bazdra03.cre~ ~override~ // fll'yissetat
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demsuc01.cre~ ~override~ // succubus
              ~deriny01.cre~ ~override~ // erinyes
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorbat2.cre~  ~override~ // erinyes
              ~gorcamb.cre~  ~override~ // aesgareth
              ~gormistp.cre~ ~override~ // poison mist
              ~gorsuc01.cre~ ~override~ // succubus
              ~gortan2.cre~  ~override~ // succubus
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~lich.itm~     ~override~ // ring
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~sword01.cre~  ~override~ // magical sword
              ~telpit1.cre~  ~override~ // pit fiend
              ~tstatue.itm~  ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 135)) BEGIN // immunity to polymorph
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi711" = 0)) BEGIN // protection from spell, sphere of chaos
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi415" = 0)) BEGIN // protection from spell, polymorph other
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm113" = 0)) BEGIN // protection from spell, wild surge polymorph
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi711~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi415~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm113~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// sleep
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~amul17.itm~   ~override~ // greenstone amulet
              ~barl.cre~     ~override~ // barl
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chevil02.cre~ ~override~ // doppleganger
              ~chevil06.cre~ ~override~ // drow warrior
              ~chevil07.cre~ ~override~ // drow priestess
              ~chgood04.cre~ ~override~ // elven warrior
              ~chgood05.cre~ ~override~ // elven warrior
              ~chgood09.cre~ ~override~ // ellesime
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jondem05.cre~ ~override~ // glabrezu
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~killsw01.itm~ ~override~ // long sword +2
              ~lich.itm~     ~override~ // ring
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring92.itm~   ~override~ // ring
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spin117.spl~  ~override~ // berserk
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~torgal.cre~   ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 39)) BEGIN // sleep immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 217)) BEGIN // pw sleep immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 14)) BEGIN // prevent sleep icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14001)) BEGIN // disable string "sleep"
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 39           // sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 217          // pw sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14           // sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14001        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// stun
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~aldeth.itm~   ~override~ // ring of free action
              ~amul17.itm~   ~override~ // greenstone amulet
              ~beholder.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~cuphaer.cre~  ~override~ // phaere
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~drow05.cre~   ~override~ // drow
              ~elearb11.cre~ ~override~ // apparition
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~firlch01.cre~ ~override~ // fire lich
              ~freering.itm~ ~override~ // ring of free action
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~hslaywpn.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~invulner.itm~ ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage05.itm~   ~override~ // ring of free action
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~npsw01.itm~   ~override~ // sword of arvoreen
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring95.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~slayerwp.itm~ ~override~ // <invalid strref -1>
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spcl542a.spl~ ~override~ // <invalid strref -1>
              ~spcl920a.spl~ ~override~ // <invalid strref -1>
              ~spin783.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~surehp1.itm~  ~override~ // ring
              ~susuneer.cre~ ~override~ // suneer
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sword01.cre~  ~override~ // magical sword
              ~torgal.cre~   ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
              ~udphae01.cre~ ~override~ // phaere
              ~udsilver.cre~ ~override~ // adalon
              ~udsola01.cre~ ~override~ // solaufein
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_5" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 45)) BEGIN // immunity to stun
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1280)) BEGIN // disable string "stunned"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14043)) BEGIN // disable string "stun"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 55)) BEGIN // prevent stunned icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 210)) BEGIN // immunity to pw stun
          SET "new_fx_5" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_5%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 45           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1280         // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14043        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 210          // pw stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
////	V7 BETA components, coded by community, added \\\\\\
////	by DavidW				      \\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

/// Tolgerias only vanishes once (proposed by Jastey, coded by DavidW)

COPY_EXISTING ~ar1002.bcs~ ~override~
	DECOMPILE_BCS_TO_BAF
	REPLACE_TEXTUALLY CASE_INSENSITIVE ~Dead("TOLGER2")~ ~Dead("TOLGER2")Exists("tolger")~
	COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES

/// Ployer breaks the game if he meets Jaheira when she has fewer than 20 hit points. (proposed and originally coded by Icendoan, 
//// this code by DavidW)

COPY ~bg2fixpack/spl/dw#fpplo.spl~ ~override~ // this spell is a silent healing spell
	WRITE_LONG 0x9e 2 // the number of hit points healed - being done here for fine-tuning purposes

COPY_EXISTING ~cut12b.bcs~ ~override~
	DECOMPILE_BCS_TO_BAF
	REPLACE_TEXTUALLY CASE_INSENSITIVE ~ForceSpell("Jaheira",JAHEIRA_WEAKNESS)~ ~ApplySpellRES("dw#fpplo","Jaheira")SmallWait(5)ForceSpell("Jaheira",JAHEIRA_WEAKNESS)~
	COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES

/// Dirbert won't take swords from party if they don't have exactly 3 (concept by Icendoan, but recoded by DavidW)

COPY_EXISTING ~uhkid01.dlg~ ~override~
	DECOMPILE_DLG_TO_D
	REPLACE_TEXTUALLY CASE_INSENSITIVE ~NumItemsParty("SW1H01",3)~ ~NumItemsPartyGT("SW1H01",2)~
	COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES

/// The Priest of Helm's Sword of Seeking should do 2d4 damage, not 1d8 (by Wisp)

COPY_EXISTING ~sw1hseek.itm~ ~override~
  READ_LONG   0x64 abil_off ELSE 0
  READ_SHORT  0x68 abil_num ELSE 0
  FOR (index = 0; index < abil_num; index += 1) BEGIN
    READ_SHORT (%abil_off% + (0x38 * %index%)) type
    PATCH_IF %type% = 1 BEGIN //Melee ability check
      WRITE_SHORT (%abil_off% + 0x16 + (0x38 * %index%)) 4 //Die size
      WRITE_SHORT (%abil_off% + 0x18 + (0x38 * %index%)) 2 //Number of dice
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Nalia dialog fix (Taimon)

COPY_EXISTING ~naliap.dlg~ ~override~
	DECOMPILE_DLG_TO_D
	REPLACE_TEXTUALLY CASE_INSENSITIVE ~Global("EnteredAR1300","LOCALS",1)~ ~OR(2)Global("EnteredAR1300","GLOBAL",1)Global("EnteredAR1300","GLOBAL",2)~
	COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES

// Correct a minor issue in Mazzy's soundset (aVENGER)

ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
               ~mazzy8~                                                            // Mazzy at level 8 (SoA)
               ~mazzy9~                                                            // Mazzy at level 9 (SoA)
              ~mazzy11~                                                            // Mazzy at level 11 (SoA)
              ~mazzy12~                                                            // Mazzy at level 12 (SoA)
              ~mazzy15~                                                            // Mazzy at level 15 (ToB)
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN                                   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN                                        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  SAY EXISTANCE2 #29727 SAY EXISTANCE3 #-1                                         // assign the Spell Failed sound to the proper soundslot
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                // ends ACTION_FOR_EACH block

// Prevent Ice Trolls from losing their coloring upon death (aVENGER)

COPY_EXISTING ~TROLIC01.CRE~  ~override~ // Ice Troll
              ~TROLIC02.CRE~  ~override~ // Ice Troll
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    FOR (index = 0; index < fx_num; index = index + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "opcode"
      READ_LONG  ("%fx_off%" + 0x0c + ("%index%" * 0x108)) "target"
      READ_LONG  ("%fx_off%" + 0x1c + ("%index%" * 0x108)) "timing"
       PATCH_IF (("%opcode%" = "51") AND ("%target%" = "0")) BEGIN // effect #51: color strong/dark by rgb
         WRITE_LONG ("%fx_off%" + 0x0c + ("%index%" * 0x108)) "1" // change the target to 1 (target: self)
       END
       PATCH_IF (("%opcode%" = "51") AND ("%timing%" = "1")) BEGIN // effect #51: color strong/dark by rgb
         WRITE_LONG ("%fx_off%" + 0x1c + ("%index%" * 0x108)) "9" // change the timing mode to 9: permanent after death
       END
    END    
BUT_ONLY_IF_IT_CHANGES

// The Twisted Rune entrance trigger in the Bridge District should only consume a single Rogue Stone (aVENGER)

COPY_EXISTING ~tran1008.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~TakePartyItem("MISC45")~ ~TakePartyItemNum("MISC45",1)~
  COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES

// Maheer the blacksmith in Waukeen's Promenade should only take a single diamond/beljuril for upgrading the Horn of Valhalla (aVENGER)

COPY_EXISTING ~shop03.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~TakePartyItem("misc42")~ ~TakePartyItemNum("misc42",1)~ // Diamond
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~TakePartyItem("misc6z")~ ~TakePartyItemNum("misc6z",1)~ // Beljuril
  COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES

// Unlock the main door to Bodhi's lair if the player sides with her in Chapter 2 (aVENGER)

COPY_EXISTING ~AR0801.BCS~ ~override~ 
DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY EXACT_MATCH ~SetGlobal("SpawnBodhiFriends","AR0801",1)~ ~SetGlobal("SpawnBodhiFriends","AR0801",1) Unlock("DOOR03")~
COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES

// Evil hell rewards have some effects with non-zero power levels and bad targeting (Wisp)

COPY_EXISTING spin747.spl override //selfish, evil
              spin749.spl override //wrath, evil
              spin751.spl override //pride, evil
              spin753.spl override //fear, evil
              spin755.spl override //greed, evil
  READ_LONG  0x64 ab_off
  READ_SHORT 0x68 num_ab
  READ_LONG  0x6a fx_off
  FOR (i=0; i < num_ab; i +=1) BEGIN
    READ_SHORT ab_off + 0x28 * i + 0x1e num_l_fx
    READ_SHORT ab_off + 0x28 * i + 0x20 fx_idx
    FOR (j=0; j < num_l_fx; j +=1) BEGIN
      WRITE_BYTE fx_off + 0x30 * (fx_idx + j) + 0x2 2 //Target
      WRITE_BYTE fx_off + 0x30 * (fx_idx + j) + 0x3 0 //Power
    END
  END
BUT_ONLY

// Correct mismatched names and tooltips (Nythrun and aVENGER)
// Part 1: Name -> Tooltip

ACTION_FOR_EACH ~file~ IN                          // for each of the following files
            ~alphonse~                             // alphonse - servant
            ~elesah02~                             // sahuagin baronial guard - baronial guard
            ~kuotoa01~                             // kuo-toa warrior - kuo-toa
            ~obssah03~                             // sahuagin baronial guard - baronial guard
            ~sahbar01~                             // sahuagin baronial guard - baronial guard
            ~sahextra~                             // sahuagin royal guard - royal guard
            ~sahgrd01~                             // sahuagin royal guard - royal guard
            ~sahgrd02~                             // sahuagin royal guard - royal guard
            ~sahgrd03~                             // sahuagin royal guard - royal guard
BEGIN                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_LONG  0x08 "name"                           // get the creature's name field strref
  WRITE_LONG 0x0c "%name%"                         // make the creature's tooltip match its name
END                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                // ends ACTION_FOR_EACH block

// Correct mismatched names and tooltips (Nythrun and aVENGER)
// Part 2: Tooltip -> Name

ACTION_FOR_EACH ~file~ IN                          // for each of the following files
            ~behobs01~                             // beholder - observer
            ~behspe01~                             // beholder - spectator
            ~gendjn01~                             // djinni - noble djinni
            ~genefn01~                             // efreeti - noble efreeti
            ~kptrol06~                             // troll - ice troll
             ~lasmist~                             // djinni - gaseous form
            ~obsfir01~                             // efreeti - noble efreeti
            ~ppbodbat~                             // vampire - vampire bat
            ~ppdjinn2~                             // djinni - noble djinni
            ~ppmind01~                             // mind flayer - ulitharid
            ~rngbeh01~                             // beholder - death tyrant
            ~tanomist~                             // vampire - gaseous form
            ~trolfr01~                             // troll - freshwater troll
            ~trolfr02~                             // troll - freshwater troll
            ~trolsn01~                             // troll - snow troll
            ~trolsn02~                             // troll - snow troll
             ~udelder~                             // beholder - elder orb
            ~valemist~                             // vampire - gaseous form
             ~vampbat~                             // vampire - vampire bat
BEGIN                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_LONG  0x0c "tooltip"                        // get the creature's tooltip field strref
  WRITE_LONG 0x08 "%tooltip%"                      // make the creature's name match its tooltip
END                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                // ends ACTION_FOR_EACH block

// Anomen should not speak ill of the Order during his banters with Imoen unless he had failed his test (Wisp)

ACTION_IF GAME_IS tob BEGIN
<<<<<<<<inlined/dialogues/are/gauche/anomenfix.d
ALTER_TRANS bimoen25 BEGIN 14 16 END BEGIN 0 END BEGIN
"TRIGGER" ~!Alignment("Anomen",CHAOTIC_NEUTRAL)~
END
ALTER_TRANS bimoen25 BEGIN 14 16 END BEGIN 1 END BEGIN
"TRIGGER" ~Alignment("Anomen",CHAOTIC_NEUTRAL)~
END
>>>>>>>>
COMPILE "inlined/dialogues/are/gauche/anomenfix.d"
END

// Assembling the Flail of Ages piece by piece should grant an XP reward (Wisp)

COPY_EXISTING kpforge.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~TakePartyItem("\(blun14[abc]\)")[ %lnl%]+TakePartyItem("\(blun14[ghi]\)")[ %lnl%]+TakePartyItem("\(blun14[def]\)")[ %lnl%]+GiveItemCreate("BLUN14",LastTrigger,0,0,0)[%lnl%]END~ ~TakePartyItem("\1") TakePartyItem("\2") TakePartyItem("\3") GiveItemCreate("BLUN14",LastTrigger,0,0,0) AddexperienceParty(22350) SetGlobal("ForgeUsed","GLOBAL",1) END~
  COMPILE_BAF_TO_BCS
BUT_ONLY

// Yoshimo should not drop two hearts when slain by a petrification effect (Nythrun)

COPY_EXISTING yoshimox.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~^\(  Die()\)~ ~\1 !StateCheck(Myself,128)~
  COMPILE_BAF_TO_BCS
BUT_ONLY

// Hostile Planetars and Devas should not attempt to heal party members (Nythrun and aVENGER)

ACTION_FOR_EACH script IN devaevil devagood plangood BEGIN
  ACTION_IF GAME_IS ~tob~ && FILE_EXISTS_IN_GAME ~%script%.bcs~ THEN BEGIN
    COPY_EXISTING ~%script%.bcs~ override
      DECOMPILE_BCS_TO_BAF
        REPLACE_TEXTUALLY ~HaveSpell(CLERIC_LESSER_RESTORATION)~ ~HaveSpell(CLERIC_LESSER_RESTORATION) Allegiance(Myself,GOODCUTOFF)~
        REPLACE_TEXTUALLY ~HaveSpell(CLERIC_NEUTRALIZE_POISON)~ ~HaveSpell(CLERIC_NEUTRALIZE_POISON) Allegiance(Myself,GOODCUTOFF)~
        REPLACE_TEXTUALLY ~HaveSpell(CLERIC_REMOVE_FEAR)~ ~HaveSpell(CLERIC_REMOVE_FEAR) Allegiance(Myself,GOODCUTOFF)~
        REPLACE_TEXTUALLY ~HPPercentLT(MostDamagedOf(Myself),25)~ ~HPPercentLT(MostDamagedOf(Myself),25) Allegiance(Myself,GOODCUTOFF)~
        REPLACE_TEXTUALLY ~HaveSpell(CLERIC_DISPEL_MAGIC)~ ~HaveSpell(CLERIC_DISPEL_MAGIC) Allegiance(Myself,GOODCUTOFF)~
      COMPILE_BAF_TO_BCS
    BUT_ONLY
  END
END

// Hostile and out of party Minsc and Valygar shouldn't heal party members (Nythrun)

COPY_EXISTING minscx.bcs   override
              valvsed.bcs  override
              valygx.bcs   override
  REPLACE_TEXTUALLY ~^0 0 0 0 0 0 0 1 6 0 0 0 ""OB~ ~0 0 0 0 0 0 0 1 0 0 0 0 ""OB~
BUT_ONLY
IF ~^0 0 0 0 0 0 0 1 6 0 0 0 ""OB~

// Jan Jansen now properly receives his bonus spell per level for being a specialist mage (Nythrun)

COPY_EXISTING jan8.cre     override
              jan10.cre    override
              jan11.cre    override
              jan12.cre    override
              jan15.cre    override
  PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
    ADD_MEMORIZED_SPELL spwi118 #0 WIZARD
    ADD_MEMORIZED_SPELL spwi201 #1 WIZARD
    ADD_MEMORIZED_SPELL spwi302 #2 WIZARD
    PATCH_IF          ~%SOURCE_RES%~ STRING_EQUAL jan8  BEGIN
      ADD_MEMORIZED_SPELL spwi405 #3 WIZARD
    END ELSE PATCH_IF ~%SOURCE_RES%~ STRING_EQUAL jan10 BEGIN
      ADD_MEMORIZED_SPELL spwi405 #3 WIZARD
      ADD_MEMORIZED_SPELL spwi508 #4 WIZARD
    END ELSE BEGIN
      ADD_MEMORIZED_SPELL spwi401 #3 WIZARD
      ADD_MEMORIZED_SPELL spwi508 #4 WIZARD
    END
  END
BUT_ONLY

// Thieves and Bards now properly receive a Dexterity bonus upon drawing the "STAR" card from the Deck of Many Things (Nythrun)

ACTION_IF GAME_IS ~tob~ THEN BEGIN
  <<<<<<<<inlined/dialogues/are/gauche/betabetatob.d
  ALTER_TRANS domt BEGIN 19 END BEGIN 3 END BEGIN
    ~TRIGGER~ ~OR(2)
Class(LastTalkedToBy,BARD_ALL)
Class(LastTalkedToBy,THIEF_ALL)~
  END
  >>>>>>>>
  COMPILE ~inlined/dialogues/are/gauche/betabetatob.d~
END

// The Shield spell and the Shield Amulet should properly protect the recipient against TRAP_MAGIC_MISSILE (Nythrun and aVENGER)

COPY_EXISTING ~spwi114.spl~ ~override~ // Shield (WIZARD_SHIELD)
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
     READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
     READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
     READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
      PATCH_IF (("%opcode%" = "206") AND ("%resref%" STRING_EQUAL_CASE ~SPWI112~)) BEGIN           // effect #206: Protection from Spell
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // clone effect
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30                // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"        // cloned effect
          WRITE_ASCII           ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) "spwi003" #8        // resref: SPWI003 (TRAP_MAGIC_MISSILE)
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul15.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "param2"
      PATCH_IF (("%opcode%" = "142") AND ("%param2%" = "15")) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "206"        // effect #206: Protection from Spell
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "0"          // param1: 0 (empty strref)
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) "0"          // param2: 0
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spwi003~ #8 // resref: SPWI003 (TRAP_MAGIC_MISSILE)
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Prismatic Spray was erroneously blinding targets up to level five, rather than seven (Nythrun)

COPY_EXISTING spwi714.spl override
  READ_LONG  0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG  0x6a eo
  FOR (i_0 = 0x00; i_0 < hc; i_0 += 0x01) BEGIN
    READ_SHORT  ho + 0x28 * i_0 + 0x1e ec
    READ_SHORT  ho + 0x28 * i_0 + 0x20 ei
    FOR (i_1 = 0x00 opcode = 0xffff; i_1 < ec && opcode != 0x4a; i_1 += 0x01) BEGIN
      READ_SHORT eo + 0x30 * (i_1 + ei) + 0x00 opcode
      PATCH_IF opcode = 0x4a BEGIN
        WRITE_SHORT eo + 0x30 * (i_1 + ei) + 0x1c 0x07
      END
    END
  END
BUT_ONLY

// Pierce Shield now provides feedback when it lowers the target's magic resistance (Nythrun)

COPY_EXISTING spwi805.spl override
  READ_LONG  0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG  0x6a eo
  FOR (i_0 = 0x00; i_0 < hc; i_0 += 0x01) BEGIN
    READ_SHORT  ho + 0x28 * i_0 + 0x10 ml
    READ_SHORT  ho + 0x28 * i_0 + 0x1e ec
    READ_SHORT  ho + 0x28 * i_0 + 0x20 ei
    FOR (i_1 = 0x00 opcode = 0xffff; i_1 < ec && opcode != 0x8b; i_1 += 0x01) BEGIN
      READ_SHORT eo + 0x30 * (i_1 + ei) + 0x00 opcode
      PATCH_IF i_1 = 0x00 BEGIN
        READ_ASCII eo + 0x30 * ei + 0x00 ef_0 (0x30)
        INNER_PATCH_SAVE ef_0 ~%ef_0%~ BEGIN
          WRITE_SHORT  0x00 0x8b // Display String Feedback
          WRITE_LONG   0x04 ml < 17 ? 32869 : ml < 20 ? 32853 + ml : 32875 // String to run
          WRITE_LONG   0x08 0x00 // Unused
          WRITE_ASCII  0x14 ~~ #8
        END
      END
    END
    PATCH_IF opcode != 0x8b BEGIN
      WRITE_SHORT ho + 0x28 * i_0 + 0x1e ec + 0x01
      INSERT_BYTES eo + 0x30 * (ec + ei) 0x30
      WRITE_ASCIIE eo + 0x30 * (ec + ei) ~%ef_0%~
      FOR (i_1 = i_0 + 0x01; i_1 < hc; i_1 += 0x01) BEGIN
        READ_SHORT  ho + 0x28 * i_1 + 0x20 ei
        WRITE_SHORT ho + 0x28 * i_1 + 0x20 ei + 0x01
      END
    END
  END
BUT_ONLY

// Creatures shouldn't have two-handed items equipped alongside shields (Nythrun and devSin)

// Orc Archer
COPY_EXISTING firarc01.cre override
  REMOVE_CRE_ITEM shld05

// Rielev 
COPY_EXISTING rielev.cre override
  REMOVE_CRE_ITEM mage01

// Red Willy 
COPY_EXISTING trple01.cre override
  REMOVE_CRE_ITEM xbow01 bolt01

// The merchant who gets assaulted by a thug at the City Gates no longer shares a store with the Brynnlaw storekeeper (Nythrun and devSin)

<<<<<<<<bg2fixpack/inlined/is/love/aemerch_fix.d
REPLACE_TRANS_ACTION aemerch BEGIN 8 END BEGIN 0 END 
  ~StartStore("ppstor01",LastTalkedToBy())~   
  ~StartStore("cdaemerc",LastTalkedToBy(Myself))~    
>>>>>>>>  
COMPILE ~bg2fixpack/inlined/is/love/aemerch_fix.d~  
COPY_EXISTING ppstor01.sto ~override/cdaemerc.sto~
  WRITE_LONG 0x14 145 // reduce sell markup

// Waukeen's Promenade script loop fix (Nythrun)
COPY_EXISTING ar0700.bcs override
  DECOMPILE_BCS_TO_BAF 
    REPLACE_TEXTUALLY
    ~^\(  GlobalTimerExpired("Bystander","GLOBAL")\)~
    ~\1 OR(2) InMyArea("bystand1") InMyArea("bystand2")~
  COMPILE_BAF_TO_BCS
BUT_ONLY

// Lady Beth
COPY_EXISTING bystand2.cre override
  WRITE_ASCII 0x250 ~~ #8
BUT_ONLY

// An instance of Jaheira's dialogue will no longer loop endlessly if the player isn't a suitable romance partner for her (Jason Compton and Wisp)

<<<<<<<<inlined/dialogues/are/gauche/jaheirafix.d
ALTER_TRANS bjaheir BEGIN 68 END BEGIN 0 1 2 END BEGIN
"ACTION" ~IncrementGlobal("LoveTalk","LOCALS",1)~
END
>>>>>>>>
COMPILE "inlined/dialogues/are/gauche/jaheirafix.d"

// The Stiletto of Demarchess +2 and the Dart of Stunning should display the appropriate strings upon holding/stunning the target (Wisp)
COPY_EXISTING ~dagg17.itm~ ~override~ // Stiletto of Demarchess +2
              ~dart03.itm~ ~override~ // Dart of Stunning
  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0
  READ_LONG  0x6a fx_off   ELSE 0
  FOR (index = 0; index < abil_num; index += 1) BEGIN
    READ_SHORT (%abil_off% + 0x1e + (0x38 * %index%)) abil_fx_num
    READ_SHORT (%abil_off% + 0x20 + (0x38 * %index%)) abil_fx_idx
    FOR (index2 = 0; index2 < abil_fx_num; index2 += 1) BEGIN
      READ_SHORT   (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) opcode
      PATCH_IF %opcode% = 109 BEGIN //Opcode is Hold
        READ_ASCII (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) clone (0x30)
        INSERT_BYTES   (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0x30
          WRITE_ASCIIE (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) "%clone%" //Clones effect
          WRITE_SHORT  (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 139 //Display string
          WRITE_LONG   (%fx_off% + 0x4 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 14102 //Held
          WRITE_LONG   (%fx_off% + 0x8 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // param2: 0
          WRITE_BYTE   (%fx_off% + 0xc + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1 //Instant/Permanent
          WRITE_LONG   (%fx_off% + 0xe + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // duration: 0
        SET abil_fx_num += 1
        SET index2 = %abil_fx_num%
      END
      PATCH_IF %opcode% = 45  BEGIN //Opcode is Stun
        READ_ASCII (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) clone (0x30)
        INSERT_BYTES   (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0x30
          WRITE_ASCIIE (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) "%clone%" //Clones effect
          WRITE_SHORT  (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 139 //Display string
          WRITE_LONG   (%fx_off% + 0x4 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1280 //Stunned
          WRITE_BYTE   (%fx_off% + 0xc + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1 //Instant/Permanent
          WRITE_LONG   (%fx_off% + 0xe + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // duration: 0
        SET abil_fx_num += 1
        SET index2 = %abil_fx_num%
      END
      WRITE_SHORT (%abil_off% + 0x1e + (0x38 * %index%)) %abil_fx_num%
    END
  END
  BUT_ONLY

// Killing a couple of unrelated Baatezu in the Marching Mountains will no longer turn Ka'rashur and his cohort in Watcher's Keep hostile (Wisp)

ACTION_IF GAME_IS tob BEGIN
COPY_EXISTING yssumm2.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~"gorbat2"~ ~"deriny01"~
  COMPILE_BAF_TO_BCS
BUT_ONLY

COPY_EXISTING ar3005.are override
              ar3006.are override
              ar3009.are override
  READ_LONG 0xc0 rest ELSE 0
  FOR (i=0;i<10;i+=1) BEGIN
    READ_ASCII rest + 0x48 + 0x8*i cre ELSE blank
    PATCH_IF "%cre%" STRING_EQUAL_CASE gorbat5 BEGIN
      WRITE_ASCII rest + 0x48 + 0x8*i dbonef01 #8
    END
  END
BUT_ONLY

COPY_EXISTING ar6012.are override
  READ_LONG  0x54 act_off ELSE 0
  READ_SHORT 0x58 num_act ELSE 0
  FOR (i=0;i<num_act;i+=1) BEGIN
    READ_ASCII act_off + 0x110*i + 0x80 cre ELSE blank
    PATCH_IF "%cre%" STRING_EQUAL_CASE gorbat5 BEGIN
      WRITE_ASCII act_off + 0x110*i + 0x80 dbonef01 #8
    END
  END
BUT_ONLY
END

// Mithral Field Plate Armor +2 and Missile Attraction +2 armors can no longer be worn together with rings and amulets of protection (Wisp)

APPEND itemexcl.2da "bruenpla 1" UNLESS bruenpla
APPEND itemexcl.2da "leat06 1" UNLESS leat06

// The Death Spell cast by the Skull of Death should not require a saving throw nor should it allow two magic resistance and power level checks (aVENGER)

COPY_EXISTING ~HELM17.ITM~   ~override~ // Skull of Death
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN  // effect #146 - cast spell at target
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power level: 0 (the power level is handled within the spell itself)
          WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // non-magical (MR is handled within the spell itself)
          WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // saving throw: none
        END
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Runehammer (both versions) should only allow a single saving throw for its undead slaying effect (aVENGER)

ACTION_FOR_EACH ~file~ IN                                                                       // for each of the following files
              ~HAMM10~                                                                          // Runehammer +4
              ~HAMM11~                                                                          // Runehammer +5
BEGIN                                                                                           // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                                // if the referenced file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                                      // file size check
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN                                   // cycles through headers
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"                               // header type
    PATCH_IF ("%type%" = 1) BEGIN // if melee header
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = "177") AND ("%resref%" STRING_EQUAL_CASE ~DIE~)) BEGIN          // effect #177 - use EFF file and resref DIE
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "MESDIE" #8 // resref: MESDIE (needs to go first)
          WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "0"          // saving throw type: 0 (none)
          WRITE_LONG ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "0"          // saving throw bonus: 0
        END
        PATCH_IF (("%opcode%" = "177") AND ("%resref%" STRING_EQUAL_CASE ~MESDIE~)) BEGIN       // effect #177 - use EFF file and resref MESDIE
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "DIE" #8    // resref: DIE (needs to go last)
        END
      END
    END
  END
END                                                                                             // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                             // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                             // ends ACTION_FOR_EACH block

// Prevent Enhanced Bard Song from reverting back to the default version after bard characters leave and rejoin the party (aVENGER)

COPY_EXISTING ~spcl920.spl~ ~override~     // Enhanced Bard Song
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN // file size check
PATCH_FOR_EACH ~file~ IN                   // for each of the following files
            ~spcl542~                      // Skald song
            ~spcl751~                      // Jester song
             ~fjbard~                      // Bard song (BG2 fixpack OBC)
            ~fjblade~                      // Blade song (BG2 fixpack OBC)
BEGIN                                      // execute the following
SET opcode = "206"                         // effect: #206 (Protection from Spell)
SET target = "2"                           // target: 2 (pre-target)
SET timing = "9"                           // timing mode: 9 (permanent after death)
SET parameter1 = "0"                       // param1: 0
SET parameter2 = "0"                       // param2: 0
SET power = "0"                            // power: 0
SET resist_dispel = "0"                    // dispel/resistance: 0 (non-magical)
SET duration = "0"                         // duration: 0
SET probability1 = "100"                   // probability1: 100%
SET probability2 = "0"                     // probability2: 0%
SET dicenumber = "0"                       // dicenumber: 0
SET dicesize = "0"                         // dicesize: 0
SET savingthrow = "0"                      // saving throw type: 0 (none)
SET savebonus = "0"                        // save bonus: 0
SPRINT ~resource~ EVALUATE_BUFFER "%file%" // resref: the current file
SET header = "0"                           // add effect to every header
LAUNCH_PATCH_MACRO ~ADD_SPELL_EFFECT~      // add new spell effect
END                                        // ends PATCH_FOR_EACH
END                                        // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Non-magical innate abilities shouldn't be affected by Wild Magic and Dead Magic zones (aVENGER)

ACTION_FOR_EACH ~file~ IN                        // for each of the following files
             ~spcl152~                           // Barbarian Rage
             ~spcl211~                           // Paladin Lay On Hands
            ~spcl321d~                           // Berserker Enrage secondary effect (becoming winded)
             ~spcl611~                           // Druid Shapeshift Brown Bear
             ~spcl612~                           // Druid Shapeshift Wolf
             ~spcl613~                           // Druid Shapeshift Black Bear
             ~spcl632~                           // Avenger Shapeshift Spider
             ~spcl633~                           // Avenger Shapeshift Baby Wyvern
             ~spcl634~                           // Avenger Shapeshift Fire Salamander
             ~spcl643~                           // Shapeshifter Werewolf Transformation
             ~spcl644~                           // Shapeshifter Greater Werewolf Transformation
             ~spcl815~                           // Monk Lay On Hands
             ~sppr731~                           // Druid Fire Elemental Transformation
             ~sppr732~                           // Druid Earth Elemental Transformation
BEGIN                                            // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.spl~ BEGIN // if the designated file with a SPL extension exists
COPY_EXISTING ~%file%.spl~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN       // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BOR 0b01000000)     // add the Non-Magical flag
END                                              // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                              // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                              // ends ACTION_FOR_EACH block

// Standardize the school and secondary type of items which cast illusionary spells (aVENGER)

COPY_EXISTING ~ring28.itm~ ~override~                                // Ring of Air Control
              ~sw1h26.itm~ ~override~                                // Ilbratha +1
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI212B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI405B~)) BEGIN // Mirror Image or Improved Invisibility
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "5"    // school: Illusionist
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "3"    // secondary type: Illusionary Protections
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast abjuration spells (aVENGER)

COPY_EXISTING ~staf11.itm~ ~override~                                // Staff of the Magi
              ~wand18.itm~ ~override~                                // Wand of Spell Striking
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI902B~) BEGIN         // Spell Trap
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "1"    // school: Abjurer
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "1"    // secondary type: Spell Protections
      END
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI513B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI608B~)) BEGIN // Breach or Pierce Magic
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "1"    // school: Abjurer
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "4"    // secondary type: Magic Attack
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Assign the proper school and secondary type to the special ability of the Shield amulet (aVENGER)

COPY_EXISTING ~amul15.itm~ ~override~                             // Shield Amulet
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN  // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"     // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                           // only patch the magical ability header
      WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"   // school: Invoker
      WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "7"   // secondary type: Combat Protections
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast offensive spells (aVENGER)

COPY_EXISTING ~staf13.itm~ ~override~                                // Staff of Thunder and Lightning
              ~wand03.itm~ ~override~                                // Wand of Magic Missiles
              ~wand05.itm~ ~override~                                // Wand of Fire
              ~wand06.itm~ ~override~                                // Wand of Frost
              ~wand07.itm~ ~override~                                // Wand of Lightning
              ~wand11.itm~ ~override~                                // Wand of the Heavens
              ~wand13.itm~ ~override~                                // Wand of Cloudkill
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF NOT (("%icon%" STRING_EQUAL_CASE ~SPWI103B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI104B~)) BEGIN // not Burning Hands or Charm
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"    // school: Invoker
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "10"   // secondary type: Offensive Damage
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI103B~) BEGIN         // Burning Hands
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "10"   // secondary type: Offensive Damage
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~IWAND13~) BEGIN          // Wand of Cloudkill
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"    // school: Invoker
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "9"    // secondary type: Battleground
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast alteration spells (aVENGER)

COPY_EXISTING ~brac16.itm~ ~override~                                // Bracers of Blinding Strike
              ~boot12.itm~ ~override~                                // Gargoyle Boots
              ~ring29.itm~ ~override~                                // Ring of Earth Control
              ~ring39.itm~ ~override~                                // Ring of Gaxx
              ~staf16.itm~ ~override~                                // Staff of Earth +2
              ~sw1h27.itm~ ~override~                                // Arbane's Sword +2
              ~sw1h36.itm~ ~override~                                // Namarra +2
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI305B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI613B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI625B~)) BEGIN // Haste, Improved Haste or Stone to Flesh
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "13"   // secondary type: Non-Combat
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI408B~) BEGIN         // Stoneskin
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "7"    // secondary type: Combat Protections
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPPR211B~) BEGIN         // Silence 15' Radius
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "11"   // secondary type: Disabling
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES


// Standardize the school and secondary type of items which cast divination spells (aVENGER)

COPY_EXISTING ~sw1h32.itm~ ~override~                                // Dragonslayer
              ~sw1h34.itm~ ~override~                                // Albruin +1
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI203B~) BEGIN         // Detect Invisibility
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "3"    // school: Diviner
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "5"    // secondary type: Divination Attack
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Correct the position of the Western Tunnels map note in the Underdark (aVENGER)

COPY_EXISTING ~AR2100.are~ ~override~
  READ_LONG  0xc4 "note_off"
  READ_LONG  0xc8 "note_num"
    FOR (index = 0; index < note_num; index = index + 1) BEGIN // cycle through automap notes
      READ_SHORT ("%note_off%" +        ("%index%" * 0x34)) "x_coord"
      READ_SHORT ("%note_off%" + 0x02 + ("%index%" * 0x34)) "y_coord"
      PATCH_IF (("%x_coord%" = 335) AND  ("%y_coord%" = 1569)) BEGIN // Western Tunnels map note
       WRITE_SHORT ("%note_off%" +        ("%index%" * 0x34)) "250" // Coordinate X (250)
       WRITE_SHORT ("%note_off%" + 0x02 + ("%index%" * 0x34)) "1830" // Coordinate Y (1830)
      END
    END  
BUT_ONLY_IF_IT_CHANGES

// Wish: Breach on all enemies in the area should not affect friendly summoned creatures and turn them hostile. Fixed by using a different targeting method and projectile

ACTION_IF GAME_IS tob BEGIN
COPY_EXISTING ~SPWISH38.SPL~  ~override~                                           // Wish: Breach on all enemies in the area
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN                       // cycle through abilities
   READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
   READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
     WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "2" // target: 2 (preset target)
    END
  WRITE_SHORT  ("%abil_off%" + 0x26 + (0x28 * "%index%")) "254"                    // projectile: 254 (BIGNAREA)
  END
BUT_ONLY_IF_IT_CHANGES
END

// Greater Command should use the same projectile at all levels. In term, the spell will no longer affect the caster's allies at lower levels

COPY_EXISTING ~SPPR512.SPL~ ~override~                                             // Greater Command
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                         // file size sanity check
READ_LONG  0x64 ab_off
READ_SHORT 0x68 ab_num
  FOR(i=0; i<ab_num; i+=1) BEGIN                                                   // cycle through all headers
    WRITE_SHORT (ab_off+i*0x28+0x26) 159                                           // use INAREANP.PRO for the projectile
  END
END                                                                                // end file size sanity check
BUT_ONLY_IF_IT_CHANGES

// The Reflection shield should protect the wielder against Ice Arrows (Wisp)

COPY_EXISTING shld24.itm override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ab_off
    READ_SHORT 0x68 num_ab
    READ_LONG  0x6a fx_off
    READ_SHORT 0x70 num_fx
    FOR (i=0;i<num_fx;i+=1) BEGIN
      READ_SHORT fx_off + 0x30*i fx_type
      PATCH_IF fx_type = 197 BEGIN
        READ_LONG fx_off + 0x30*i + 0x8 pro
        SET $fl#pro_shld24("%pro%") = 1
      END
    END
    PATCH_FOR_EACH pro IN 1 3 4 6 9 11 13 14 15 16 19 26 29 31 34 102 BEGIN
      PATCH_IF !VARIABLE_IS_SET $fl#pro_shld24("%pro%") BEGIN
        INSERT_BYTES fx_off + 0x30*num_fx        0x30
        WRITE_SHORT  fx_off + 0x30*num_fx        197
        WRITE_BYTE   fx_off + 0x30*num_fx + 0x2  1
        WRITE_LONG   fx_off + 0x30*num_fx + 0x8  pro
        WRITE_BYTE   fx_off + 0x30*num_fx + 0xc  2
        WRITE_BYTE   fx_off + 0x30*num_fx + 0x12 100
        num_fx += 1
      END
    END
    WRITE_SHORT 0x70 num_fx
    FOR (i=0;i<num_ab;i+=1) BEGIN
      WRITE_SHORT ab_off + 0x38*i + 0x20 num_fx
      num_fx += SHORT_AT ab_off + 0x38*i + 0x1e
    END
  END
BUT_ONLY

// The Physical Mirror spell should protect the recipient against Bolts of Lightning (crossbow ammo type), Firetooth bolts (crossbow) and Arrows of Fire (bow ammo type). (Wisp)

COPY_EXISTING sppr613.spl override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ab_off
    READ_SHORT 0x68 num_ab
    READ_LONG  0x6a fx_off
    READ_SHORT 0x70 fx_idx
    num_fx = 0
    FOR (i=0;i<num_ab;i+=1) BEGIN
      fx_idx += num_fx
      READ_SHORT  ab_off + 0x28*i + 0x1e num_fx
      WRITE_SHORT ab_off + 0x28*i + 0x20 fx_idx
      FOR (j=0;j<num_fx;j+=1) BEGIN
        READ_SHORT fx_off + 0x30*(fx_idx + j) fx_type
        PATCH_IF fx_type = 197 BEGIN
          READ_LONG  fx_off + 0x30*(fx_idx + j) + 0x8 pro
          SET $fl#pro_sppr613("%i%" "%pro%") = 1
        END
      END
      PATCH_FOR_EACH pro IN 1 3 4 6 9 11 13 14 15 16 19 26 29 31 34 102 BEGIN
        PATCH_IF !VARIABLE_IS_SET $fl#pro_sppr613("%i%" "%pro%") BEGIN
          INSERT_BYTES fx_off + 0x30*num_fx        0x30
          WRITE_SHORT  fx_off + 0x30*num_fx        197
          WRITE_BYTE   fx_off + 0x30*num_fx + 0x2  1
          WRITE_LONG   fx_off + 0x30*num_fx + 0x8  pro
          WRITE_BYTE   fx_off + 0x30*num_fx + 0xc  2
          WRITE_BYTE   fx_off + 0x30*num_fx + 0x12 100
          num_fx += 1
        END
      END
      WRITE_SHORT ab_off + 0x28*i + 0x1e num_fx
    END
  END
BUT_ONLY

// Undead creatures are erroneously immune to Lightning Bolt instead of Hold Person (aVENGER)

COPY_EXISTING ~ring95.itm~ ~override~ // undead immunity ring
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN // file size sanity check
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "resref"
    PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_EQUAL_CASE ~SPWI308~)) BEGIN // Lightning Bolt
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "SPWI306" #8 // Hold Person
    END
  END
END
BUT_ONLY_IF_IT_CHANGES


// Illusionary Werewolves should not damage characters who are unarmed or wielding ranged weapons (aVENGER)

COPY_EXISTING ~illusion.itm~ ~override~                                               // Illusionary Werewolf weapon
READ_LONG 0x64 abil_off
READ_SHORT 0x68 abil_num
READ_LONG 0x6a fx_off
  FOR (i = 0; i < "%abil_num%"; i += 1) BEGIN                                         // parse each ability
    READ_BYTE (%abil_off% + %i% * 0x38) abil_type                                     // read ability type
    PATCH_IF (%abil_type% = 1) BEGIN                                                  // only patch the melee ability header
      WRITE_SHORT ("%abil_off%" + 0x1c) 0                                             // damage type (None)
      WRITE_SHORT ("%abil_off%" + 0x16) 0                                             // damage dice
    END
  END
BUT_ONLY_IF_IT_CHANGES


// All trolls should have their hit points set to 1 after getting knocked down (aVENGER)

COPY_EXISTING ~dgtrol02.bcs~ ~override~ // Druid Grove trolls that are fighting some adventurers
               ~troll03.bcs~ ~override~ // small trolls which emerge out of a bigger one on the first floor of de'Arnise Keep
              ~firamb05.bcs~ ~override~ // the troll fighting the werewolf captain in Firkraag's lair
DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY EXACT_MATCH ~PlayDead(150)~ ~ApplySpell(Myself,TROLL_SETHP1) PlayDead(150)~
  REPLACE_TEXTUALLY EXACT_MATCH ~PlayDead(300)~ ~ApplySpell(Myself,TROLL_SETHP1) PlayDead(300)~
COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES


// The Spellhold Asylum door should be unlocked and opened once (aVENGER)

COPY_EXISTING ~ar1500.bcs~ ~override~
DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY EXACT_MATCH ~GlobalGT("AsylumPlot","GLOBAL",55)~ ~GlobalGT("AsylumPlot","GLOBAL",55) Global("RR#Door1501","AR1500",0)~
  REPLACE_TEXTUALLY EXACT_MATCH ~Unlock("Door1501")~ ~SetGlobal("RR#Door1501","AR1500",1) Unlock("Door1501")~
COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES


// The beneficial effects of the Deck of Many Things should bypass the user's Magic Resistance and/or Globe of Invulnerability (aVENGER)

ACTION_IF GAME_IS tob BEGIN
COPY_EXISTING ~spin606.spl~ ~override~     // DECK_SUN (Party gains 300,000 Experience Points)
              ~spin607.spl~ ~override~     // DECK_JESTER (The user gains 50,000 Experience Points)
              ~spin609.spl~ ~override~     // DECK_GEM (The user gains several gems)
              ~spin610.spl~ ~override~     // DECK_FATES (The user gains a +1 bonus to all stats for 1 day)
              ~spin611.spl~ ~override~     // DECK_COMET (The user gains a permanent 5% increase to Fire Resistance)
              ~spin618.spl~ ~override~     // DECK_MOON (The user gains a permanent increase of 10 Hit Points)
              ~spin619.spl~ ~override~     // DECK_THRONE (Party gains 1,000,000 Experience Points)
              ~spin621.spl~ ~override~     // DECK_KEY (The user gains a Ring of Protection +3)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
      READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "dispel"
      PATCH_IF ("%dispel%" != 0) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "2" // resist/dispel: 2
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
END


//reddeath doesn't work because it uses the wrong action (Wisp)
COPY_EXISTING reddeath.bcs override
  DECOMPILE_BCS_TO_BAF
	REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ReallyForceSpell ReallyForceSpellDead
  COMPILE_BAF_TO_BCS
UNLESS 240OB
BUT_ONLY


//Kruin can spawn again if you killed him before he could talk (Wisp)
COPY_EXISTING githspwn.bcs override
  DECOMPILE_BCS_TO_BAF
	REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~!Exists("Kruin")~ ~!Exists("Kruin") !Dead("Kruin")~
  COMPILE_BAF_TO_BCS
UNLESS ~16465 0 1 0 0 "Kruin" "" OB~
BUT_ONLY


// Keldorn re-joining variable typo fix (berelinde)

COPY_EXISTING ~keldorj.dlg~ ~override~
    DECOMPILE_DLG_TO_D
	    REPLACE_TEXTUALLY ~SetGlobal("KeldornLeaves","GLOBAL",1)~  ~SetGlobal("KeldornLeave","GLOBAL",1)~
    COMPILE_D_TO_DLG
    BUT_ONLY_IF_IT_CHANGES


// A few trap spells ignore magic resistance, but they probably should not since all other trap spells don't (aVENGER)

COPY_EXISTING ~spwi001.spl~ ~override~ // Fireball (trap)
                          ~spwi002.spl~ ~override~ // Lightning Bolt (trap)
                          ~spwi003.spl~ ~override~ // Magic Missile (trap)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
        READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
        READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
        FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
          READ_SHORT ("%fx_off%" +              (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
          READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "dispel"
          PATCH_IF ("%dispel%" != 1) BEGIN
                WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "1" // resist/dispel: 1
          END
        END
  END
BUT_ONLY_IF_IT_CHANGES


// The innate immunity to psionics and mind-affecting spells of Mordenkainen Sword should not be dispellable (aVENGER)

COPY_EXISTING ~ipsion.itm~ ~override~  // Greenstone Amulet ("equipped" by Mordenkainen's Sword)
READ_LONG   0x64 "abil_off"
READ_SHORT  0x68 "abil_num"
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
        WRITE_BYTE ("%fx_off%" + 0x0d + ("%index2%" * 0x30)) "0" // dispel/resist: 0 (non-magical)
        WRITE_LONG ("%fx_off%" + 0x0e + ("%index2%" * 0x30)) "0" // duration: 0
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Aerie's "Blanket Thieves" banter which could never occur due to a duplicated PartyRested() trigger (berelinde)

COPY_EXISTING ~baerie.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY EXACT_MATCH ~PartyRested()
Gender(Player1,FEMALE)~ ~Gender(Player1,FEMALE)~
  COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES


// Fix Haer'Dalis' "Arcane muttering" banter with Edwin which could never occur due to a duplicated PartyRested() trigger (aVENGER)

COPY_EXISTING ~bhaerda.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY EXACT_MATCH ~PartyRested()
InParty("Edwin")~ ~InParty("Edwin")~
  COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES


// Jarlaxle should have enough gold to reward the party for their efforts (Ardanis)

<<<<<<<<bg2fixpack/inlined/jarlaxle.d
REPLACE_ACTION_TEXT jarlaxle ~GivePartyGold(~ ~GiveGoldForce(~
>>>>>>>>
COMPILE "bg2fixpack/inlined/jarlaxle.d"


// Fix for Jaheira having the wrong dialogue when a non-romance protagonist refuses to follow her to the Harper Hold (aVENGER)

<<<<<<<<bg2fixpack/inlined/jaheirap.d
REPLACE_TRIGGER_TEXT ~jaheirap~  ~GlobalGT("JaheiraHarperPlot","GLOBAL",3)~ ~Global("JaheiraHarperPlot","GLOBAL",3) AreaCheck("AR0300") !InParty(Myself)~
ADD_STATE_TRIGGER ~jaheirap~ 32 ~!AreaCheck("AR0300")~
>>>>>>>>
COMPILE "bg2fixpack/inlined/jaheirap.d"


// Secret Word should be able to dispel a Globe of Invulnerability (aVENGER)

COPY_EXISTING ~spwi419.spl~ ~override~ // Secret Word
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
        READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
        READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
        FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "5" // power
        END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect orientation when entering Cayia's house in Brynnlaw (CamDawg)

COPY_EXISTING ~ar1606.are~ ~override~
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF ("%name%" STRING_EQUAL_CASE "exit1600") BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 6 // northwest
    END
  END
BUT_ONLY_IF_IT_CHANGES


// The Glabrezus in the Ranger stronghold quest and inside the Suldanessalar temple don't give any XP when killed (aVENGER)

COPY_EXISTING ~demgla01.cre~   ~override~ // Ranger stronghold Glabrezu
              ~demglab2.cre~   ~override~ // Suldanessalar temple Glabrezu
WRITE_LONG 0x14 12500 // XP value
BUT_ONLY_IF_IT_CHANGES


// Fix erroneously dispellable effects on Keldorn's armor (polytype)

COPY_EXISTING ~npplat.itm~ ~override~  // Firecam Full-Plate Armor
READ_LONG   0x64 "abil_off"
READ_SHORT  0x68 "abil_num"
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index2%" * 0x30)) "0" // dispel/resist: 0 (non-magical)
    WRITE_LONG ("%fx_off%" + 0x0e + ("%index2%" * 0x30)) "0" // duration: 0
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Storm of Vengeance not displaying the relevant icon on poisoned targets (polytype)

COPY_EXISTING ~sppr722.spl~ ~override~ // Storm of Vengeance
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
     READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 25) BEGIN // clone Poison opcode
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30)
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"  // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142           // opcode: 142 (Display Special Effect Icon)
          WRITE_LONG            ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 0             // param1: 0
          WRITE_LONG            ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 6             // param2: 6 (Poisoned icon)
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix the wrong enchantment level and missing poison icon on the Dagger of Venom (aVENGER)

COPY_EXISTING ~misc75.itm~ ~override~ // Dagger of Venom
WRITE_LONG 0x60 2   // set enchantment level to 2
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 25) BEGIN // poison
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone poison opcode
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // cloned opcode
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142       // opcode: 142 (Display Special Effect Icon)
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0         // param1: 0
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 6         // param2: 6 (Poisoned icon)
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Inquisitors not getting charm immunity at level 1 (Dakk)

COPY_EXISTING ~clabpa03.2da~ ~override~ // Inquisitor ability table
  SET_2DA_ENTRY  3 2 3 ~****~
  SET_2DA_ENTRY 10 1 3 ~AP_SPCL233b~
  PRETTY_PRINT_2DA
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect thieving skill racial bonus for elves, half-elves and halflings (Hurricane and aVENGER)

COPY_EXISTING ~SKILLRAC.2DA~ ~override~
  SET_2DA_ENTRY 2 4 8 ~15~ // Elf Move Silently correction (was 20)
  SET_2DA_ENTRY 4 4 8 ~10~ // Half-Elf Move Silently correction (was 15)
  SET_2DA_ENTRY 5 4 8 ~20~ // Halfling Move Silently correction (was 25)
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect lore bonus for 15 INT/WIS (Ascension 64 and Hurricane)

COPY_EXISTING ~LOREBON.2DA~ ~override~
  SET_2DA_ENTRY 15 1 2 ~3~
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect Move Silently entry for Ranger level 2 (Ascension 64 and Hurricane)

COPY_EXISTING ~SKILLRNG.2DA~ ~override~
  SET_2DA_ENTRY 2 1 2 ~21~
BUT_ONLY_IF_IT_CHANGES



/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Optional, but cool                               \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

/////                                                  \\\\\
///// keldorn xp                                       \\\\\
/////                                                  \\\\\

BEGIN @6 DESIGNATED 100
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0100.g3~

// get xp for keldorn's reconciliation if keldorn is released from the party
COMPILE ~bg2fixpack/dlg/keldorn.d~

/////                                                  \\\\\
///// maze animations                                  \\\\\
/////                                                  \\\\\
                
BEGIN @7 DESIGNATED 101
GROUP @2

// maze animation, part 1
COPY_EXISTING ~SPWI813.SPL~ ~OVERRIDE~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN // if play 3d effect
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "animation"
        PATCH_IF ("%animation%" STRING_COMPARE_CASE "spmaze2" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // set prob to 0
        END ELSE BEGIN
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 5 // duration
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~SPSPMAZE~ #8
        END
      END ELSE
      PATCH_IF ("%opcode%" = 213) BEGIN // if maze
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// maze animation, part 2
COPY_EXISTING ~SPMAZE2.VVC~ ~OVERRIDE/SPSPMAZE.VVC~
  WRITE_ASCII 0x78 ~EFF_M74~ #8
  WRITE_BYTE 0x4c 0x08
  WRITE_BYTE 0x68 0x00
  WRITE_EVALUATED_ASCII 0x08 ~%DEST_RES%~ #8
  
// animation fixes
COPY_EXISTING ~BHAAL4B.SPL~ ~OVERRIDE~
              ~SPCL213.SPL~ ~OVERRIDE~
              ~SPIN550.SPL~ ~OVERRIDE~
              ~SPIN553.SPL~ ~OVERRIDE~
              ~SPIN558.SPL~ ~OVERRIDE~
              ~SPIN674.SPL~ ~OVERRIDE~
              ~SPIN675.SPL~ ~OVERRIDE~
              ~SPIN696.SPL~ ~OVERRIDE~
              ~SPIN826.SPL~ ~OVERRIDE~
              ~SPIN891.SPL~ ~OVERRIDE~
              ~SPPR107.SPL~ ~OVERRIDE~
              ~SPPR408.SPL~ ~OVERRIDE~
              ~SPWI113.SPL~ ~OVERRIDE~
              ~SPWI214.SPL~ ~OVERRIDE~
              ~SPWI702.SPL~ ~OVERRIDE~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    FOR (READ_LONG 0x6a effectsOffset ELSE 0x72; effectsOffset < SOURCE_SIZE; effectsOffset = effectsOffset + 0x30) BEGIN
      READ_SHORT ~%effectsOffset%~ ~effectType~ ELSE 0x00
      PATCH_IF (~%effectType%~ = 0xd7) BEGIN // play 3d effect opcode
        READ_ASCII ~%effectsOffset%~ + 0x14 ~animation~ ELSE ~~
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~ICRMPARI~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~ICSTRENI~) OR NOT
                     (~%animation%~ STRING_COMPARE_CASE ~SPPOWWRD~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPROTECT~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x02
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x02)) ? 0x02 : ~%effectLength%~
        END ELSE
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~SPDISPMA~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPTRUSEE~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x03
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x03)) ? 0x03 : ~%effectLength%~
        END ELSE
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~ICWRATI~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPNWCHRM~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x04
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x04)) ? 0x04 : ~%effectLength%~
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~cspray.pro~   ~override/burnhand.pro~
  WRITE_SHORT 0x206 64 // range (5')
  WRITE_BYTE  0x217  0 // no explosion

ADD_PROJECTILE ~override/burnhand.pro~

COPY_EXISTING ~spwi103.spl~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN
    READ_LONG  0x64 "ho"
    FOR (READ_SHORT 0x68 "hc"; "hc" > 0x00; "hc" -= 0x01) BEGIN
      WRITE_SHORT ("ho" + ("hc" * 0x28) - 0x16) 1
      WRITE_BYTE  ("ho" + ("hc" * 0x28) - 0x1c) 4
      WRITE_SHORT ("ho" + ("hc" * 0x28) - 0x02) "burnhand"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// scroll fixes: effects target
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: casting opcode
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell (scroll)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // target: any point in range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl68.itm~ ~override~ // spook
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 5 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Make Errard's Divination spell actually use the Divination casting graphics (aVENGER)

COPY_EXISTING ~SPIN541.SPL~   ~override~ // Divination
 WRITE_SHORT   0x22  16 // Casting graphics: 16 (Divination)
BUT_ONLY_IF_IT_CHANGES


/////                                                  \\\\\
///// Cromwell's forging actually takes a day          \\\\\
/////                                                  \\\\\
                
BEGIN @8 DESIGNATED 102
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0102.g3~

EXTEND_TOP ~ar0334.bcs~ ~bg2fixpack/baf/ar0334.baf~

/////                                                  \\\\\
///// Mixed-use dagger fixes                           \\\\\
/////                                                  \\\\\

BEGIN @9 DESIGNATED 103
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0103.g3~

// removes melee abilities from Fire Tooth and Boomerang dagger; change APR to be consistent 
// with other throwing daggers; alters base Fire Tooth damage to 1d4 (again for consistency); damage change now rescinded (Wisp)
COPY_EXISTING ~dagg11.itm~ ~override~
              ~dagg12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    PATCH_IF ("%opcode%" = 1) BEGIN  // attacks per round
      WRITE_LONG ("%fx_off%" + 0x04 + ("%index%" * 0x30)) 2 // number of attacks
      WRITE_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 1 // set to value
    END
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
     WRITE_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) 0
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      DELETE_BYTES ("%fx_off%" + (0x30 * ("%abil_fx_idx%" - "%fx_delta%"))) (0x30 * "%abil_fx_num%") // deletes all associated effects
      DELETE_BYTES ("%abil_off%" + ("%index%" * 0x38)) 0x38                                          // deletes ability itself
      SET "fx_delta" = ("%fx_delta%" + "%abil_fx_num%")
      SET "abil_num" = ("%abil_num%" - 1)
      SET "index" = ("%index%" - 1)
      SET "fx_off" = ("%fx_off%" - 0x38)
    END ELSE BEGIN // if non-melee ability, need to adjust effect indices
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT (0x20 + "%abil_off%" + ("%index%" * 0x38)) ("%abil_fx_idx%" - "%fx_delta%")
      //The description says 2d4, it is conistent across both headers; changing the ranged damage to 1d4 is bunk, says I
      //PATCH_IF (("%type%" = 2) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "dagg12" = 0)) BEGIN // ranged damage adjustment for Fire Tooth
      //  WRITE_SHORT (0x18 + "%abil_off%" + ("%index%" * 0x38)) 1 // only 1d4, not 2d4
      //  SAY 0x54 @135 // adjusts description
      //END
    END
  END
  WRITE_SHORT  0x68 "%abil_num%"
  WRITE_LONG   0x6a "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// Ghrey's Holy Symbol Fixes                        \\\\\
/////                                                  \\\\\

BEGIN @10 DESIGNATED 104
GROUP @2
REQUIRE_PREDICATE     FILE_EXISTS_IN_GAME ~mel01.cre~   @11 // ToB required

EXTEND_BOTTOM ~aerie.bcs~  ~bg2fixpack/baf/et_aerie.baf~
EXTEND_BOTTOM ~aeri25.bcs~ ~bg2fixpack/baf/et_aerie.baf~

EXTEND_BOTTOM ~anomen.bcs~ ~bg2fixpack/baf/et_anom.baf~
EXTEND_BOTTOM ~anom25.bcs~ ~bg2fixpack/baf/et_anom.baf~

EXTEND_BOTTOM ~viconia.bcs~ ~bg2fixpack/baf/et_vicon.baf~
EXTEND_BOTTOM ~vico25.bcs~  ~bg2fixpack/baf/et_vicon.baf~

COPY ~bg2fixpack/bam/d0baer.bam~ ~override~
     ~bg2fixpack/bam/d0shar.bam~ ~override~

// Holy Symbol of Helm Usable by Good Aligned. Poo, but necessary to let Anomen use it.
COPY_EXISTING ~belt13.itm~ ~override~
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BAND 0b11111011) // removes good flag
  BUT_ONLY_IF_IT_CHANGES

COPY ~bg2fixpack/itm/j#belt12.itm~ ~override~
  SAY NAME2 @128
  SAY IDENTIFIED_DESC @129

COPY ~bg2fixpack/itm/j#belt14.itm~ ~override~
  SAY NAME2 @130
  SAY IDENTIFIED_DESC @131

/////                                                  \\\\\
///// Jenia will wait until PC hero of trademeet       \\\\\
/////                                                  \\\\\
                
BEGIN @12 DESIGNATED 105
DEPRECATED @22

// moved into core fixes per Gaider

/////                                                  \\\\\
///// giants have penalties v shorties                 \\\\\
/////                                                  \\\\\
                
BEGIN @13 DESIGNATED 106
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0106.g3~

// giant weapons get THAC0 penalties vs. small people (revised by aVENGER)

ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
              ~giafir~                                                             // giant hammer 
             ~giafir2~                                                             // giant axe
             ~giafir3~                                                             // giant fist
            ~giants01~                                                             // giant sword
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                   // if the designated file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                         // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
// =============================================================================== // the actual work starts from here
PATCH_FOR_EACH ~eff~ IN                                                            // for each of the following EFF files
            ~giant1~                                                               // THAC0 penalty vs. dwarves
            ~giant2~                                                               // THAC0 penalty vs. halflings
            ~giant3~                                                               // THAC0 penalty vs. gnomes
BEGIN                                                                              // execute the following
SET opcode = "177"                                                                 // effect: #177 (use EFF file)
SET target = "1"                                                                   // target: 1 (self)
SET timing = "2"                                                                   // timing mode: 2 (while equipped)
SET parameter1 = "142"                                                             // param1: 142 (IDS Entry - GIANT)
SET parameter2 = "4"                                                               // param2: 4 (IDS File - RACE.IDS)
SET power = "0"                                                                    // power: 0
SET resist_dispel = "0"                                                            // dispel/resistance: 0 (non-magical)
SET duration = "0"                                                                 // duration: 0
SET probability1 = "100"                                                           // probability1: 100%
SET probability2 = "0"                                                             // probability2: 0%
SET dicenumber = "0"                                                               // dicenumber: 0
SET dicesize = "0"                                                                 // dicesize: 0
SET savingthrow = "0"                                                              // saving throw type: 0 (none)
SET savebonus = "0"                                                                // save bonus: 0
SPRINT ~resource~ EVALUATE_BUFFER "%eff%"                                          // resref: the current EFF file
LAUNCH_PATCH_MACRO ~ADD_ITEM_EQEFFECT~                                             // add new equipping effect
END                                                                                // ends PATCH_FOR_EACH block
// =============================================================================== // the actual work ends here
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                // ends ACTION_FOR_EACH block

/////                                                  \\\\\
///// Remove Dual-class Restriction from ranger kits   \\\\\
/////                                                  \\\\\
                
BEGIN @14 DESIGNATED 107
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0107.g3~

COPY_EXISTING ~dualclas.2da~ ~override~
  SET_2DA_ENTRY 32 2 7 ~1~ // archer (feralan)
  SET_2DA_ENTRY 33 2 7 ~1~ // stalker
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// Remove Wrath-Evil bonuses                        \\\\\
/////                                                  \\\\\

BEGIN @15 DESIGNATED 108
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0108.g3~

// remove bonuses here as the player is already rewarded at the door
COPY_EXISTING ~ar2905.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Global("Player1Wrath","GLOBAL",2)~ ~False()~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// summoned demon behavior                          \\\\\
/////                                                  \\\\\

BEGIN @16 DESIGNATED 109
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0109.g3~

COMPILE ~bg2fixpack/baf/demglasu.baf~
        ~bg2fixpack/baf/demnabsu.baf~
        ~bg2fixpack/baf/dempitsu.baf~

/////                                                  \\\\\
///// additional script fixes                          \\\\\
/////                                                  \\\\\
                
BEGIN @17 DESIGNATED 110
GROUP @2

// allows us to regexp match tabs and newlines
INCLUDE ~bg2fixpack/lib/extra_regexp_vars.tph~

// commoners missing scripts to turn hostile if attacked
COPY_EXISTING ~aewimer1.cre~ ~override~
              ~aewimer2.cre~ ~override~
              ~aewimer3.cre~ ~override~
              ~bdgoph01.cre~ ~override~
              ~bdgoph02.cre~ ~override~
              ~brat1.cre~    ~override~
              ~brat2.cre~    ~override~
              ~brat3.cre~    ~override~
              ~ftown1.cre~   ~override~
              ~ftown2.cre~   ~override~
              ~ftown3.cre~   ~override~
              ~ftown4.cre~   ~override~
              ~haquat.cre~   ~override~
              ~maria.cre~    ~override~
              ~mourner5.cre~ ~override~
              ~mourner6.cre~ ~override~
              ~mtown1.cre~   ~override~
              ~mtown2.cre~   ~override~
              ~mtown3.cre~   ~override~
              ~mtown4.cre~   ~override~
              ~murtlen.cre~  ~override~
              ~noblem1.cre~  ~override~
              ~noblem2.cre~  ~override~
              ~noblew1.cre~  ~override~
              ~noblew2.cre~  ~override~
              ~peony.cre~    ~override~
              ~postul1.cre~  ~override~
              ~postul3.cre~  ~override~
              ~postul5.cre~  ~override~
              ~postul6.cre~  ~override~
              ~pwauk2.cre~   ~override~
              ~radeel.cre~   ~override~
              ~scbutler.cre~ ~override~
              ~scqar.cre~    ~override~
              ~scsarles.cre~ ~override~
              ~sethle.cre~   ~override~
              ~trskin02.cre~ ~override~
              ~trtavp05.cre~ ~override~
              ~uhmer02.cre~  ~override~
              ~wellyn.cre~   ~override~
  SET "script_runenemy" = 0
  SET "script_wtrunsgt" = 0
  FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
    READ_ASCII (0x248 + ("%index%" * 0x08)) "script"
    PATCH_IF ("%script%" STRING_COMPARE_CASE "runenemy" = 0) BEGIN
      SET "script_runenemy" = 1
    END ELSE
    PATCH_IF (("%script%" STRING_COMPARE_CASE "wtrunsgt" = 0) OR
              ("%script%" STRING_COMPARE_CASE "wdrunsgt" = 0)) BEGIN
      SET "script_wtrunsgt" = 1
    END
  END
  PATCH_IF ("%script_runenemy%" + "%script_wtrunsgt%" = 1) BEGIN
    FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
      READ_ASCII (0x248 + ("%index%" * 0x08)) "script"
      PATCH_IF (("%script%" STRING_COMPARE_CASE "none" = 0) OR ("%script%" STRING_COMPARE_CASE "" = 0)) BEGIN
        PATCH_IF ("%script_runenemy%" = 0) BEGIN
          WRITE_ASCII (0x248 + ("%index%" * 0x08)) "runenemy"
          SET "script_runenemy" = 1
        END ELSE
        PATCH_IF ("%script_wtrunsgt%" = 0) BEGIN
          WRITE_ASCII (0x248 + ("%index%" * 0x08)) "wtrunsgt"
          SET "script_wtrunsgt" = 1
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// create fatigue-free restoration spell for cut59a
COPY_EXISTING ~sppr417.spl~  ~override/cdpr417.spl~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + (0x28 * "%index%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 93) BEGIN // fatigue
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // probability 0
        END
      END
    END
  END

// dragons have responses to cloud-based attacks
// was presumed to be zone of sweet air, but already included in wing buffet spell, so ref removed
COPY_EXISTING ~abazdrag.bcs~ ~override~ // abazigal
              ~dragbrow.bcs~ ~override~ // draconis
              ~draggre2.bcs~ ~override~
              ~draggree.bcs~ ~override~
              ~gorsal.bcs~   ~override~ // saladrex
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~~ // in response to death fog/incend cloud, cloudkill
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// direct target of breath attacks gets some extra damage; see drgrbrht or RED_DRAGON_HIT (spin693) in other dragon AI scripts
COPY_EXISTING ~abazdrag.bcs~ ~override~
              ~dragblue.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(LastSeenBy(Myself),0)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// unknown fourth possible option; efreet seems to be a common alternative to nishruu summoning (plus it's known to cre)
COPY_EXISTING ~amlich02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(Myself,0)~ ~SpellNoDec(Myself,WIZARD_SUMMON_EFREET)~ // other three actions--two summoning spells and move to PC
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// blank block for HaveSpell, CastSpell--only one memorized but not scripted is ADHW
COPY_EXISTING ~bheye.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_ABI_DALZIMS_HORRID_WILTING)~
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_ABI_DALZIMS_HORRID_WILTING)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// two presumably olive slimes were supposed to spawn--no such creatures
COPY_EXISTING ~ar2200.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("jeloli01",\[4422\.3524\],6)~ ~CreateCreature("jelmus01",[4422.3524],6)~ // replace w/ mustard jelly
    REPLACE_TEXTUALLY ~CreateCreature("jeloli01",\[4052\.3574\],6)~ ~CreateCreature("jelgre01",[4052.3574],6)~ // replace w/ green slime
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// script designed to turn invisible repeatedly; given level and kit, assassination seems a good fit here
COPY_EXISTING ~chalcy02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(Myself,0)~ ~SpellNoDec(Myself,ROGUE_ASSASINATION)~ // Some prep spell
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// blank block for HaveSpell, CastSpell in offensive situation--two spells memorized but not scripted: fireball and magic missile
// select MM as there's no range check for fireball safety
COPY_EXISTING ~clone1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(NearestEnemyOf(Myself),0)~
      ~HaveSpell(WIZARD_MAGIC_MISSILE) \1 Spell(NearestEnemyOf(Myself),WIZARD_MAGIC_MISSILE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// final game cutscene
COPY_EXISTING ~cut59a.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ApplySpell(\([A-Za-z0-9]+\),0)~
      ~ApplySpellRES("cdpr417",\1)~   // some form of restoration--follows resurrections and full heal
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cutscene
COPY_EXISTING ~cut67d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell("Dpimo01",0)~ ~ForceSpell("Dpimo01",CUTSCENE_DAMAGE_1)~   // irenicus doing something to Imoen
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// degardan has one messed up script
COPY_EXISTING ~degard2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY // against non-humanoids; use HM even though not memorized since used in similar blocks in other AI scripts
      ~\(!General(LastSeenBy(Myself),HUMANOID)[%tab% %lnl%%mnl%%wnl%]+\)HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
      ~\1 HaveSpell(WIZARD_HOLD_MONSTER) \2 Spell(LastSeenBy(Myself),WIZARD_HOLD_MONSTER)~
    REPLACE_TEXTUALLY // death spell? something effective against multiple enemies-- cone of cold?
      ~\(NumCreatureGT(\[ALLY\],4)[%tab% %lnl%%mnl%%wnl%]+Allegiance(Myself,ENEMY)[%tab% %lnl%%mnl%%wnl%]+See(NearestEnemyOf(Myself))[%tab% %lnl%%mnl%%wnl%]+\)HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
      ~\1 HaveSpell(WIZARD_DEATH_SPELL) \2 Spell(LastSeenBy(Myself),WIZARD_DEATH_SPELL)~
    REPLACE_TEXTUALLY // one of several generic attack responses--melf's acid arrow?
      ~SpellNoDec(LastSeenBy(Myself),0)~
      ~SpellNoDec(LastSeenBy(Myself),WIZARD_MELF_ACID_ARROW)~
    REPLACE_TEXTUALLY // anti-mage spell--hold person? do this one last, had problems with matching
      ~HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)~
      ~HaveSpell(WIZARD_HOLD_PERSON) \1 Spell(LastSeenBy(Myself),WIZARD_HOLD_PERSON)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// in between dragon fear and a wing buffet--per other dragon AI, should be lowering specific resistances to breath attack, but nothing to reduce poison resistance
COPY_EXISTING ~draggre2.bcs~ ~override~
              ~draggree.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(NearestEnemyOf(Myself),0)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/*
// gauths should be firing off more spells
COPY_EXISTING ~gauth01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ReallyForceSpell(\[PC\],0)\([%tab% %lnl%%mnl%%wnl%]+SetGlobal("GauthBehavior","LOCALS",1)\)~
      ~ReallyForceSpell([PC],0) \1~ // no idea
    REPLACE_TEXTUALLY
      ~\(!See(LeastDamagedOf(Myself))[%tab% %lnl%%mnl%%wnl%]+HPGT(Myself,35)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+ReallyForceSpell(\[PC\],BEHOLDER_HOLD_PERSON)[%tab% %lnl%%mnl%%wnl%]+\)ReallyForceSpell([PC],0)~
      ~\1 ReallyForceSpell([PC],0)~ // no idea
    REPLACE_TEXTUALLY
      ~\([^!]See(LeastDamagedOf(Myself))[%tab% %lnl%%mnl%%wnl%]+HPGT(Myself,35)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+ReallyForceSpell(\[PC\],BEHOLDER_HOLD_PERSON)[%tab% %lnl%%mnl%%wnl%]+\)ReallyForceSpell([PC],0)~
      ~\1 ReallyForceSpell([PC],0)~ // no idea
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/
/*
// missing spell in heal-?-restoration sequence
COPY_EXISTING ~gorgua01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,FORCE_DISPEL_MAGIC)~ // between full heal and restore--dispel effects?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/

// gphealer has two HaveSpell, Spell blocks with unknown IDS entries--something offensive with a 5' radius
// found near-identical sequence for mage symbol spells in gpmage1
COPY_EXISTING ~gphealer.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~\(IF[%tab% %lnl%%mnl%%wnl%]+\)HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+!HasBounceEffects(LastSeenBy(Myself))[%tab% %lnl%%mnl%%wnl%]+!Range(LastSeenBy(Myself),5)[%tab% %lnl%%mnl%%wnl%]+RandomNum(2,1)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)\([%tab% %lnl%%mnl%%wnl%]+END[%tab% %lnl%%mnl%%wnl%]+IF[%tab% %lnl%%mnl%%wnl%]+\)HaveSpell(0)\([%tab% %lnl%%mnl%%wnl%]+!HasBounceEffects(LastSeenBy(Myself))[%tab% %lnl%%mnl%%wnl%]+!Range(LastSeenBy(Myself),5)[%tab% %lnl%%mnl%%wnl%]+RandomNum(2,1)[%tab% %lnl%%mnl%%wnl%]+THEN[%tab% %lnl%%mnl%%wnl%]+RESPONSE #100[%tab% %lnl%%mnl%%wnl%]+\)Spell(LastSeenBy(Myself),0)\([%tab% %lnl%%mnl%%wnl%]+END\)~
      ~\1 HaveSpell(CLERIC_SYMBOL_DEATH) \2 Spell(LastSeenBy(Myself),CLERIC_SYMBOL_DEATH) \3 HaveSpell(CLERIC_SYMBOL_STUN) \4 Spell(LastSeenBy(Myself),CLERIC_SYMBOL_STUN) \5~ //
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// gpmage1 is missing IDS refs in a HaveSpell, Spell block
// gpmage2 has identical block
COPY_EXISTING ~gpmage1.bcs~  ~override~
              ~magehigh.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_DISPEL_MAGIC)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),WIZARD_DISPEL_MAGIC)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block--offensive/disabling spell
// every mage12 ends with a magic missile block before melee
COPY_EXISTING ~lyros.bcs~   ~override~
              ~mage12b.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_MAGIC_MISSILE)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_MAGIC_MISSILE)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block--offensive/disabling spell
// based on sequencing, chaos is a good guess here
COPY_EXISTING ~mage12e.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_CHAOS)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_CHAOS)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block for > 6 opponents
// kproen02 has exact same sequencing
COPY_EXISTING ~mage14d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_DEATH_SPELL)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),WIZARD_DEATH_SPELL)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// one possible attack with mag missile and fireball--no bounce, indiv target, range > 5
// except for two extra response options, similar to many symbol sequences
COPY_EXISTING ~meliss01.bcs~ ~override~
              ~meliss02.bcs~ ~override~
              ~meliss03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(LastSeenBy(Myself),0)~ ~SpellNoDec(LastSeenBy(Myself),WIZARD_SYMBOL_DEATH)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// big, high-level spell: only against 75% HP+. similar blocks are very high-level spells--comet, bigby, bone blades
COPY_EXISTING ~meliss03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(LastSeenBy(Myself),0)~ ~ForceSpell(LastSeenBy(Myself),WIZARD_DRAGONS_BREATH)~ // dragon's breath?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// lilarcor sound
COPY_EXISTING ~pipe04.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~PlaySound("MISC_02A")~ ~PlaySound("EFF_P54")~ // Cromwell's forging sound
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// some fire mephit attack
COPY_EXISTING ~mepfir.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(NearestEnemyOf(Myself),0)~ ~ForceSpell(NearestEnemyOf(Myself),MEPHIT_FLAME_FAN)~ // attack spell
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// two missing actions in four-action blocks; blocks seem identical
// for fire slamanders; should be offensive fire spell
COPY_EXISTING ~salgrfir.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(NearestEnemyOf(Myself),0)~ ~SpellNoDec(NearestEnemyOf(Myself),WIZARD_AGANNAZAR_SCORCHER)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/*
// viekang's scripts; allegiance check to destroy minhp1
COPY_EXISTING ~sarvie01.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,EVILBUTBLUE)~ // third allegiance check?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/

// one of four attack options--others all cleric damage/disabling spells
COPY_EXISTING ~tahazz.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(NearestEnemyOf(Myself),0)~ ~ForceSpell(NearestEnemyOf(Myself),CLERIC_FLAME_STRIKE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// demon knights
COPY_EXISTING ~uddeath.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ReallyForceSpell(LastSeenBy(Myself),0)~
      ~ReallyForceSpell(LastSeenBy(Myself),WIZARD_SYMBOL_STUN)~ // one of five attack options--symbol stun?
    REPLACE_TEXTUALLY 
      ~ForceSpell(LastSeenBy(Myself),0)\([%tab% %lnl%%mnl%%wnl%]+SetGlobal("DeathKnightFireball","LOCALS",1)\)~
      ~ForceSpell(LastSeenBy(Myself),WIZARD_FIREBALL) \1~ // one of two attack options--fireball?
    REPLACE_TEXTUALLY 
      ~ForceSpell(LastSeenBy(Myself),0)\([%tab% %lnl%%mnl%%wnl%]+SetGlobal("DeathAttack","LOCALS",1)\)~
      ~ForceSpell(LastSeenBy(Myself),WIZARD_SYMBOL_DEATH) \1~ // one of three attack options--symbol death?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// bard song fixes                                  \\\\\
/////                                                  \\\\\
                
BEGIN @18 DESIGNATED 111
GROUP @2

COPY ~bg2fixpack/spl/fjbard.spl~   ~override~
     ~bg2fixpack/spl/fjbarda.spl~  ~override~
     ~bg2fixpack/spl/fjbardb.spl~  ~override~
     ~bg2fixpack/spl/fjblade.spl~  ~override~
     ~bg2fixpack/spl/fjbladeb.spl~ ~override~

// apply song to trueclass bards and blades
COPY_EXISTING ~clabba01.2da~ ~override~
  PATCH_IF (SOURCE_SIZE > 0) BEGIN
    SET_2DA_ENTRY 3 1 3 ~AP_FJBARD  ~
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clabba02.2da~ ~override~
  PATCH_IF (SOURCE_SIZE > 0) BEGIN
    SET_2DA_ENTRY 3 1 3 ~AP_FJBLADE ~
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// wizard slayer ranged attacks                     \\\\\
/////                                                  \\\\\

BEGIN @19 DESIGNATED 112
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0112.g3~

COPY_EXISTING ~spcl133.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 248) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%clone%"
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 249  // ranged hit effect
        SET "abil_fx_num" = ("%abil_fx_num%" + 1)
        SET "delta" = ("%delta%" + 1)
        SET "index2" = ("%index2%" + 1)
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// wiz slayer description update
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  STRING_SET 25203 @145

END ELSE BEGIN

  STRING_SET 25203 @144

END

/////                                                  \\\\\
///// additional alignment fixes                       \\\\\
/////                                                  \\\\\

BEGIN @21 DESIGNATED 113
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0113.g3~

// alignment corrections from Oversight
COPY_EXISTING ~garkid01.cre~ ~override~ // Iltha
              ~garkid02.cre~ ~override~ // Taar
                  ~alex.cre~ ~override~ // Sir Beverus
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 17 // alignment: lawful good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte3.cre~ ~override~ // Watchknight Aabir
              ~bdact05.cre~  ~override~ // Zaren
              ~bdhigg01.cre~ ~override~ // Higgold
              ~gftown01.cre~ ~override~ // Commoner
              ~gmtown02.cre~ ~override~ // Commoner
              ~helmbyr.cre~  ~override~ // Acolyte Byron
              ~helmkni1.cre~ ~override~ // Shield Knight
              ~helmpr.cre~   ~override~ // Sir Lothtyran
              ~prophelm.cre~ ~override~ // Shield Knight
              ~sctelwyn.cre~ ~override~ // Guardian Telwyn
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 18 // alignment: lawful neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amtgen01.cre~ ~override~ // Jamis Tombelthen
              ~bounha.cre~   ~override~ // Bounty Hunter
              ~bounha04.cre~ ~override~ // Bounty Hunter
              ~jade2.cre~    ~override~ // Thenry
              ~jade3.cre~    ~override~ // Jeremon
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 19 // alignment: lawful evil
  END
  BUT_ONLY_IF_IT_CHANGES
  
// alignment corrections from Oversight
COPY_EXISTING ~jarev1.cre~   ~override~ // Harper
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 50 // alignment: chaotic neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~priss.cre~    ~override~ // Priss
              ~rumar.cre~    ~override~ // Rumar
              ~victown1.cre~ ~override~ // Commoner
              ~victown2.cre~ ~override~ // Commoner
              ~victown3.cre~ ~override~ // Nobleman
                ~drow07.cre~ ~override~ // Drow Priestess
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 51 // alignment: chaotic evil
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// free action prevents against stun                \\\\\
/////                                                  \\\\\

BEGIN @23 DESIGNATED 114
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0114.g3~

// include macros for batch processing
INCLUDE ~bg2fixpack/lib/macro_fx_batch_prep.tph~

// add stun immunity to free action items
COPY_EXISTING ~blun30.itm~  ~override~ // foa +5
              ~potn45.itm~  ~override~ // potion of freedom
              ~ring09.itm~  ~override~ // ring of free action
              ~sper12.itm~  ~override~ // ixil's spike +6
              ~sppr403.spl~ ~override~ // spell of free action
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // hold immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 210          // pw stun immunity
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 45           // stun immunity
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun icon
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1280         // strref
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14043        // strref
        SET "new_fx" = ("%new_fx%" + 5)
        SET "counter" = ("%counter%" + 5)
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// shapeshifter paw fixes                           \\\\\
/////                                                  \\\\\

BEGIN @24 DESIGNATED 115
GROUP @2
REQUIRE_PREDICATE FILE_EXISTS_IN_GAME ~tobex_ini/tobexcore.ini~ @1100              // This component requires TobEx

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0115.g3~

// Add the non-dispellable flag to shapechange weapons if TobEx is detected
// This will prevent the natural weapons of the shapechange forms (i.e. claws and such) from being removed by Dispel Magic and Dead Magic Zones
ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
               ~brblp~                                                             // Shapeshifts Black Bear
               ~brbrp~                                                             // Shapeshifts Brown Bear, Shapeshifts Werewolf, Shapeshifts Greater Werewolf
              ~druear~                                                             // earth elemental transformation
              ~drufir~                                                             // fire elemental transformation
             ~earthrn~                                                             // Shapechange Earth Elemental
              ~firern~                                                             // Shapechange Fire Elemental
              ~goliro~                                                             // used by iron golems, Shapechange Iron Golem
            ~mindflay~                                                             // used by mind flayers, Shapechange Mind Flayer
            ~plyjelly~                                                             // jelly from cloak of sewers
             ~plysala~                                                             // Fire Salamander (Avenger kit form)
             ~plyspid~                                                             // Sword Spider (Avenger kit form)
            ~plytroll~                                                             // troll from cloak of sewers
            ~plywyvrn~                                                             // Baby Wyvern shape attack
             ~polyrat~                                                             // rat from cloak of sewers
             ~shakti1~                                                             // short sword +4
            ~slayerwp~                                                             // slayer, Slayer Change
              ~squirp~                                                             // Sphere of Chaos
            ~trollall~                                                             // Shapechange Giant Troll
              ~wolfgr~                                                             // Shapechange Greater Wolfwere
               ~wolfm~                                                             // Shapeshifts Wolf
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                   // if the designated file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN                                         // protects against invalid files
// =============================================================================== // the actual work starts from here
    READ_BYTE 0x1b "flags"
    PATCH_IF (("%flags%" BAND "0b00000001") = "0b00000000") BEGIN                  // if bit 24 isn't set
      WRITE_BYTE "0x1b" ("%flags%" BOR "0b00000001")                               // set bit 24
    END
// =============================================================================== // the actual work ends here
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                // ends ACTION_FOR_EACH block


/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Who loves ya baby? The Fixpack Team, that's who! \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

// need to uncomment the following line to get this component at install time
//BEGIN ~SUPER SECRET COMPONENT~ DESIGNATED 10000

// For some of the common 'I don't like this' requests, I had some free time and decided to code
// this for players. See something you don't like? Should just be a few un-comments away.
// Want to change something not here? Ask in the 'I *hate* this fix' thread:
// http://forums.gibberlings3.net/index.php?showtopic=7890

// want Jaheira to know Zone of Sweet Air? Uncomment the block below
/*
COPY_EXISTING ~jaheir7.cre~  ~override~
              ~jaheir8.cre~  ~override~
              ~jaheir11.cre~ ~override~
              ~jaheir12.cre~ ~override~
              ~jahei12b.cre~ ~override~
              ~jahei14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE >0x2d3) BEGIN
    ADD_KNOWN_SPELL ~sppr318~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// Adds Holy Smite back to Viconia
/*
COPY_EXISTING ~viconi6.cre~  ~override~
              ~viconi8.cre~  ~override~
              ~viconi9.cre~  ~override~
              ~viconi11.cre~ ~override~
              ~viconi13.cre~ ~override~
              ~viconi16.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_KNOWN_SPELL ~sppr313~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// removes elven/half-elven sleep/charm immunities
/*
COPY_EXISTING_REGEXP GLOB ~^cdelfcm[0-6]\.eff$~ ~override~
                          ~^cdelfsl[0-4]\.eff$~ ~override~
  WRITE_SHORT 0x2c 0
  BUT_ONLY_IF_IT_CHANGES
*/

// undo monk item usability fixes
/*
COPY_EXISTING ~amul21.itm~   ~override~ // Amulet of power
              ~brac21.itm~   ~override~ // gauntlets of ex specialization
              ~ring22.itm~   ~override~ // ring o' holiness
              ~ring35.itm~   ~override~ // ring of lock picking
              ~ring40.itm~   ~override~ // ring of acuity
              ~scrl8c.itm~   ~override~ // stone to flesh
              ~wa2ring.itm~  ~override~ // mercykiller ring
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_BYTE  0x21 "mu"
    WRITE_BYTE 0x21 ("mu" & (` 0xdf)) // removes monk unusability flag
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// Innate Draw Upon Holy Might is fast casting
/*
COPY_EXISTING spin103.spl override // duhm innate
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 2
  END
BUT_ONLY
*/
